[
    {
        "detailed_description": "The public class StringNumberHandler is a specialized class that extends the AbstractCellHandler class with a generic type of String. This class is designed to handle operations related to Excel cells that contain numeric data represented as strings. \n\nThe getCellValue method is overridden from the parent class and is responsible for retrieving the value of a cell in an Excel sheet. It takes three arguments: a SheetContext object, an ExcelFieldConfig object, and a CellResult object. The method first retrieves the numeric value from the CellResult object and converts it into a BigDecimal. It then retrieves the Java format for the Excel field configuration and uses this format to convert the BigDecimal into a string.\n\nThe setCellValue method is also overridden from the parent class and is responsible for setting the value of a cell in an Excel row. It takes four arguments: a RowContext object, an ExcelFieldConfig object, a Cell object, and a String value. The method converts the string value into a BigDecimal and then into a double value, which is set as the value of the cell.\n\nThe getExcelType method is overridden from the parent class and returns the ExcelType of the cell, which in this case is NUMERIC, indicating that the cell contains numeric data.\n\nThe getDefaultExcelFormat method is also overridden from the parent class and returns the default Excel format for the cell, which in this case is \"0.00\". This format indicates that the cell's numeric value should be displayed with two decimal places.",
        "sketchy_description": "The public class StringNumberHandler, which extends the abstract class AbstractCellHandler with a generic type of String, is specifically tailored to manage the conversion and formatting of numeric strings within Excel cells. This class provides a set of protected and public methods that interact with Excel cells and their contents.\n\nThe `getCellValue` method is a protected method that takes a SheetContext, an ExcelFieldConfig, and a CellResult as parameters. It is responsible for retrieving the numeric value from the firstCellResult, and then formatting it as a String according to the rules defined in the ExcelFieldConfig. This method is essential for ensuring that numeric values are correctly represented as strings when extracted from Excel cells.\n\nThe `setCellValue` method is another protected method that accepts a RowContext, an ExcelFieldConfig, a Cell, and a String value as arguments. Its purpose is to convert the provided String value back into a numeric value and then set this value into the specified Cell. This method is crucial for populating Excel cells with numeric values that have been input or modified as strings.\n\nThe `getExcelType` method is a public method that returns an ExcelType enumeration value. This value indicates that the cells being handled by this class are numeric cells. This information can be used by other components of the Excel handling system to apply appropriate processing or formatting to these cells.\n\nLastly, the `getDefaultExcelFormat` method is a public method that returns a String representing the default Excel format for numeric cells. This format string can be used to ensure that numeric values are displayed in a consistent and expected manner within Excel cells, adhering to standard numeric formatting conventions.\n\nTogether, these methods provide a comprehensive interface for managing the conversion and formatting of numeric strings within the context of Excel cell operations, ensuring that numeric data is accurately represented and manipulated within spreadsheets.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/string/StringNumberHandler.java",
        "class_name": "StringNumberHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "StringNumberHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/StringNumberHandlerTest.java"
        },
        "task_id": 0,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.string;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.context.SheetContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.handler.AbstractCellHandler;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport io.github.zouzhiy.excel.metadata.result.CellResult;\nimport io.github.zouzhiy.excel.utils.ExcelNumberUtils;\nimport org.apache.poi.ss.usermodel.Cell;\n\nimport java.math.BigDecimal;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class StringNumberHandler extends AbstractCellHandler<String> {\n\n    @Override\n    protected String getCellValue(SheetContext sheetContext, ExcelFieldConfig excelFieldConfig, CellResult firstCellResult) {\n        BigDecimal bigDecimal = firstCellResult.getNumberValue();\n        String javaFormat = this.getJavaFormat(excelFieldConfig);\n        return ExcelNumberUtils.format(bigDecimal, javaFormat);\n    }\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, String value) {\n        cell.setCellValue(new BigDecimal(value).doubleValue());\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.NUMERIC;\n    }\n\n\n    @Override\n    public String getDefaultExcelFormat() {\n        return \"0.00\";\n    }\n}\n"
    },
    {
        "detailed_description": "The public class DoubleNumberHandler is a subclass of the AbstractDoubleCellHandler class. This class is designed to handle double number cells in an Excel spreadsheet. It overrides two methods from its superclass. The first method, setCellValue, takes four parameters: a RowContext object, an ExcelFieldConfig object, a Cell object, and a Double value. This method is responsible for setting the value of a specific cell in the spreadsheet. The second method, getExcelType, returns the type of Excel cell that this handler is designed to work with, which in this case is numeric. This class is useful for manipulating numeric data in Excel spreadsheets, such as performing calculations or formatting cells.\"",
        "sketchy_description": "The public class DoubleNumberHandler, which extends the AbstractDoubleCellHandler, is specifically designed to manage the assignment of double-precision floating-point values to cells within an Excel spreadsheet. This functionality is crucial when dealing with numerical data in Excel, as it ensures that values are accurately and appropriately stored in cells.\n\nThe class provides a protected method setCellValue, which takes a RowContext, an ExcelFieldConfig, a Cell, and a Double as parameters. This method is tasked with setting the value of a specific cell in an Excel sheet to the double value provided. This operation is fundamental for populating Excel sheets with numerical data, which can then be used for various calculations, data analysis, or reporting purposes.\n\nAdditionally, the class offers a public method getExcelType, which returns an ExcelType enumeration value. This value corresponds to the numeric data type, indicating that the handler is associated with numerical values within Excel. This method is particularly useful for ensuring that the data types used in Excel cells are consistent with the expected types, thereby reducing the likelihood of data type mismatches and potential errors during data manipulation or analysis.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/doubles/DoubleNumberHandler.java",
        "class_name": "DoubleNumberHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "DoubleNumberHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/DoubleNumberHandlerTest.java"
        },
        "task_id": 1,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.doubles;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport org.apache.poi.ss.usermodel.Cell;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class DoubleNumberHandler extends AbstractDoubleCellHandler {\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, Double value) {\n        cell.setCellValue(value);\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.NUMERIC;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class BuiltJar is designed to represent a built Java Archive (JAR) file. This class contains several public static final variables, each representing a specific built JAR file. Each of these variables is initialized using the fromFormat method, which takes a string format as an argument and returns a new instance of the BuiltJar class with the file name formatted according to the provided format and the current version of the SleeperVersion.\n\nThe BuiltJar class has a private instance variable, fileName, which stores the name of the JAR file. This variable is initialized in the private constructor of the class, which takes a string representing the file name as an argument.\n\nThe class also provides a public method, getFileName, which returns the name of the JAR file. This method can be used to retrieve the name of the JAR file at any point after the object has been created.\n\nThe fromFormat method is a static method that creates a new instance of the BuiltJar class. It takes a string format as an argument, formats it with the current version of the SleeperVersion, and returns a new BuiltJar object with the formatted string as the file name. This method is used to initialize the public static final variables of the class.\"",
        "sketchy_description": "The public class BuiltJar is designed to represent various types of built JAR (Java ARchive) files that adhere to specific naming conventions. These JAR files are typically used in Java applications to aggregate many files into a single archive file that can be executed or used as a library. The class contains a series of predefined static final BuiltJar instances, each corresponding to a different type of JAR file used within a system, such as Athena, Bulk Import Starter, Ingest Starter, and others. Each of these instances is created using a specific naming format that includes a placeholder for a version string or other unique identifier.\n\nThe constructor of the BuiltJar class is private, indicating that instances should be created through the provided static method rather than directly instantiated. This constructor takes a single String argument representing the file name of the JAR and initializes the BuiltJar instance with this file name.\n\nThe static method fromFormat is a factory method that allows the creation of new BuiltJar instances by providing a format string. This method utilizes the current SleeperVersion to replace the placeholder in the format string with the appropriate version information, resulting in a fully formatted file name for the JAR.\n\nFinally, the getFileName method is a public instance method that returns the file name of the BuiltJar. This method can be used to retrieve the exact file name of the JAR file represented by a BuiltJar instance, which is useful for referencing the file in file system operations or within the application that uses these JAR files.",
        "file": "sleeper/java/cdk/src/main/java/sleeper/cdk/jars/BuiltJar.java",
        "class_name": "BuiltJar",
        "repo_metadata": {
            "repo_name": "sleeper"
        },
        "evaluation_metadata": {
            "test_class_name": "BuiltJarTest",
            "test_file": "sleeper/java/cdk/src/test/java/sleeper/cdk/jars/BuiltJarTest.java"
        },
        "task_id": 2,
        "ground_truth_class_body": "/*\n * Copyright 2022-2023 Crown Copyright\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage sleeper.cdk.jars;\n\nimport sleeper.core.SleeperVersion;\n\npublic class BuiltJar {\n\n    public static final BuiltJar ATHENA = fromFormat(\"athena-%s.jar\");\n    public static final BuiltJar BULK_IMPORT_STARTER = fromFormat(\"bulk-import-starter-%s.jar\");\n    public static final BuiltJar INGEST_STARTER = fromFormat(\"ingest-starter-%s.jar\");\n    public static final BuiltJar GARBAGE_COLLECTOR = fromFormat(\"lambda-garbagecollector-%s.jar\");\n    public static final BuiltJar COMPACTION_JOB_CREATOR = fromFormat(\"lambda-jobSpecCreationLambda-%s.jar\");\n    public static final BuiltJar COMPACTION_TASK_CREATOR = fromFormat(\"runningjobs-%s.jar\");\n    public static final BuiltJar PARTITION_SPLITTER = fromFormat(\"lambda-splitter-%s.jar\");\n    public static final BuiltJar QUERY = fromFormat(\"query-%s.jar\");\n    public static final BuiltJar CUSTOM_RESOURCES = fromFormat(\"cdk-custom-resources-%s.jar\");\n    public static final BuiltJar METRICS = fromFormat(\"metrics-%s.jar\");\n\n    private final String fileName;\n\n    private BuiltJar(String fileName) {\n        this.fileName = fileName;\n    }\n\n    public static BuiltJar fromFormat(String format) {\n        return new BuiltJar(String.format(format, SleeperVersion.getVersion()));\n    }\n\n    public String getFileName() {\n        return fileName;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class StringFieldDecoder is designed to decode strings from byte buffers, particularly in UTF-8 format. It uses a thread-local buffer and a simple byte buffer pool to manage memory and improve performance. The class has a private static final integer THREAD_LOCAL_BUFFER_SIZE, which defines the size of the thread-local buffer. It also has a private static final ThreadLocal object THREAD_LOCAL_BUFFER, which is a thread-local storage of byte arrays. \n\nThe class has a private byte array threadLocalBuffer and a private SimpleByteBufferPool object pool. It also has a private ByteBuffer object bufferFromPool. The constructor of the class takes a SimpleByteBufferPool object as an argument and initializes the pool and threadLocalBuffer.\n\nThe class has a public method decodeUTF8 which takes a ByteBuffer object, an integer fieldLen, and two boolean values start and end as arguments. This method is responsible for decoding the byte buffer into a UTF-8 string. If the start and end are true and the fieldLen is less than or equal to THREAD_LOCAL_BUFFER_SIZE, it uses the thread-local buffer for decoding. Otherwise, it uses the buffer from the pool. If the end is true, it releases the buffer back to the pool after decoding and returns the decoded string. If the end is false, it keeps the buffer for future use and returns null.\"",
        "sketchy_description": "The public class StringFieldDecoder is designed to decode strings from byte buffers, specifically using UTF-8 encoding. This class is particularly useful when dealing with byte data that needs to be converted into human-readable strings, such as when processing network packets or reading files that use UTF-8 encoding.\n\nTo optimize performance, the class uses a thread-local buffer, which is a static final variable that each thread can use without affecting other threads. This buffer is initialized with a size of 32 kilobytes, which is a reasonable default for many applications. Additionally, the class provides a constructor that accepts a SimpleByteBufferPool object, which is used to manage byte buffers more efficiently and reduce the overhead of creating and destroying buffers frequently.\n\nThe decodeUTF8 method is a public method that takes a ByteBuffer, an integer representing the length of the field to decode, and two boolean flags indicating whether this is the start and end of the string to be decoded. If the string is small enough to fit within the thread-local buffer and both the start and end flags are true, the method will use this buffer to avoid the overhead of using a buffer from the pool. If the end flag is false, the method will store the partial result, allowing for the string to be completed in a subsequent call. This functionality is particularly useful for processing streams of data where the entire string may not be available in a single ByteBuffer.",
        "file": "dongting/client/src/main/java/com/github/dtprj/dongting/net/StringFieldDecoder.java",
        "class_name": "StringFieldDecoder",
        "repo_metadata": {
            "repo_name": "dongting"
        },
        "evaluation_metadata": {
            "test_class_name": "StringFieldDecoderTest",
            "test_file": "dongting/client/src/test/java/com/github/dtprj/dongting/net/StringFieldDecoderTest.java"
        },
        "task_id": 3,
        "ground_truth_class_body": "/*\n * Copyright The Dongting Project\n *\n * The Dongting Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage com.github.dtprj.dongting.net;\n\nimport com.github.dtprj.dongting.buf.SimpleByteBufferPool;\n\nimport java.nio.ByteBuffer;\nimport java.nio.charset.StandardCharsets;\n\n/**\n * This class can only be used in io threads.\n *\n * @author huangli\n */\npublic class StringFieldDecoder {\n\n    private static final int THREAD_LOCAL_BUFFER_SIZE = 32 * 1024;\n    private static final ThreadLocal<byte[]> THREAD_LOCAL_BUFFER = ThreadLocal.withInitial(() -> new byte[THREAD_LOCAL_BUFFER_SIZE]);\n    private final byte[] threadLocalBuffer;\n    private final SimpleByteBufferPool pool;\n\n    private ByteBuffer bufferFromPool;\n\n    StringFieldDecoder(SimpleByteBufferPool pool) {\n        this.pool = pool;\n        this.threadLocalBuffer = THREAD_LOCAL_BUFFER.get();\n    }\n\n    public String decodeUTF8(ByteBuffer buf, int fieldLen, boolean start, boolean end) {\n        if (start && end && fieldLen <= THREAD_LOCAL_BUFFER_SIZE) {\n            byte[] threadLocalBuffer = this.threadLocalBuffer;\n            buf.get(threadLocalBuffer, 0, fieldLen);\n            return new String(threadLocalBuffer, 0, fieldLen, StandardCharsets.UTF_8);\n        }\n        ByteBuffer bufferFromPool;\n        if (start) {\n            bufferFromPool = pool.borrow(fieldLen);\n        } else {\n            bufferFromPool = this.bufferFromPool;\n        }\n        bufferFromPool.put(buf);\n\n        if (end) {\n            String s = new String(bufferFromPool.array(), 0, bufferFromPool.position(), StandardCharsets.UTF_8);\n            pool.release(bufferFromPool);\n            this.bufferFromPool = null;\n            return s;\n        } else {\n            this.bufferFromPool = bufferFromPool;\n            return null;\n        }\n    }\n}\n"
    },
    {
        "detailed_description": "The public class LocalDateNumberHandler is a subclass of the AbstractLocalDateCellHandler class. This class is designed to handle the conversion of LocalDate objects to numeric values that can be used in Excel spreadsheets. The class overrides two methods from its superclass. \n\nThe first overridden method is setCellValue. This method takes four parameters: a RowContext object, an ExcelFieldConfig object, a Cell object, and a LocalDate object. The method first converts the LocalDate object to a double value that represents the equivalent Excel date using the DateUtil.getExcelDate method. This double value is then set as the value of the Cell object using the setCellValue method. \n\nThe second overridden method is getExcelType. This method does not take any parameters and returns an ExcelType enumeration value. Specifically, it returns ExcelType.NUMERIC, indicating that this handler is used for numeric Excel cells. This method is useful for determining the type of Excel cell that the handler is designed to work with.\"",
        "sketchy_description": "The public class LocalDateNumberHandler, which extends the AbstractLocalDateCellHandler, is specifically designed to handle the conversion of LocalDate objects into the numeric Excel format. This is particularly useful when dealing with cell values in Excel spreadsheets, where dates need to be represented in a format that Excel can understand and manipulate. The class provides a protected method setCellValue, which takes a RowContext, an ExcelFieldConfig, a Cell, and a LocalDate object as parameters. This method is responsible for setting the cell's value to the numeric Excel date representation of the provided LocalDate. This ensures that dates are stored correctly in Excel spreadsheets, allowing for proper date-related operations within Excel.\n\nAdditionally, the class offers a public method getExcelType, which returns an ExcelType enumeration value that corresponds to 'numeric'. This method is useful for determining the type of Excel cell format that should be used when dealing with numeric representations of dates, ensuring consistency and compatibility with Excel's formatting and data handling capabilities.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/localdate/LocalDateNumberHandler.java",
        "class_name": "LocalDateNumberHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "LocalDateNumberHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/LocalDateNumberHandlerTest.java"
        },
        "task_id": 4,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.localdate;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport org.apache.poi.ss.usermodel.Cell;\nimport org.apache.poi.ss.usermodel.DateUtil;\n\nimport java.time.LocalDate;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class LocalDateNumberHandler extends AbstractLocalDateCellHandler {\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, LocalDate value) {\n        double excelLocalDate = DateUtil.getExcelDate(value);\n        cell.setCellValue(excelLocalDate);\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.NUMERIC;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class QueueTokenVerifier is designed to verify the validity of a queue token. It contains several public static final strings that define the issuers and claims of the token. It also has a private static final Logger object for logging purposes. \n\nThe main method in this class is the static verify method. This method takes a token, a list of secret candidates, and a queue as arguments. The method first checks if the list of secret candidates is null or empty. If it is, it throws a WebApplicationException indicating that the server is not configured with secrets to verify the queue token. \n\nThe method then attempts to verify the token with each secret in the list of secret candidates. If the token verification fails with a secret, it logs a warning and stores the exception. If the token cannot be verified with any of the secrets, it throws a WebApplicationException indicating that the server failed to verify the queue token. \n\nThe method then checks the issuer of the token. If the issuer is null, empty, or not one of the defined issuers, it throws a WebApplicationException indicating that the queue token is not valid due to no issuer or unsupported issuer. \n\nThe method then gets the claim from the token. If the claim is null or empty, it throws a WebApplicationException indicating that the queue token is not valid due to no claim. \n\nThe method then tries to convert the claim to an array or a list of strings. If the conversion fails, it logs a warning. If the converted claim does not contain the given queue, it throws a WebApplicationException indicating that the queue token does not allow the given queue. \n\nThis class is useful for verifying the validity of queue tokens in a server environment, ensuring that only valid tokens are used to access the queues.\"",
        "sketchy_description": "The public class QueueTokenVerifier is designed to handle the security aspect of queue management by verifying the validity of queue tokens. This class is equipped with constants that define the possible issuers of the tokens, such as \"admin\" and \"airflow\", as well as a claim key for allowed queues. It also maintains a static logger instance for logging purposes.\n\nThe core functionality of this class is encapsulated in the static method verify, which takes a JWT token, a list of secret candidates, and a queue name as parameters. The method's purpose is to ensure that the provided token is valid, has been issued by a recognized authority, and contains the necessary claims that permit access to the specified queue. If any of these conditions are not met, the method will throw a WebApplicationException, indicating that the token verification process has failed.\n\nThe parameters for the verify method are as follows:\n- token: A string representing the JWT token that needs to be verified.\n- secretCandidates: A list of strings, each a potential secret that could be used to decode the token.\n- queue: A string representing the name of the queue that the token should grant access to.\n\nThe method throws a WebApplicationException in several scenarios, such as when the token cannot be verified, lacks an issuer, has an unsupported issuer, does not contain the allowed queues claim, or when the specified queue is not included in the token's allowed queues list. This exception handling ensures that only valid and authorized tokens can grant access to the queue, thereby maintaining the integrity and security of the queue management system.",
        "file": "batch-processing-gateway/src/main/java/com/apple/spark/core/QueueTokenVerifier.java",
        "class_name": "QueueTokenVerifier",
        "repo_metadata": {
            "repo_name": "batch-processing-gateway"
        },
        "evaluation_metadata": {
            "test_class_name": "QueueTokenVerifierTest",
            "test_file": "batch-processing-gateway/src/test/java/com/apple/spark/core/QueueTokenVerifierTest.java"
        },
        "task_id": 5,
        "ground_truth_class_body": "/*\n *\n * This source file is part of the Batch Processing Gateway open source project\n *\n * Copyright 2022 Apple Inc. and the Batch Processing Gateway project authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.apple.spark.core;\n\nimport com.apple.spark.util.JwtUtils;\nimport com.auth0.jwt.exceptions.JWTVerificationException;\nimport com.auth0.jwt.interfaces.Claim;\nimport com.auth0.jwt.interfaces.DecodedJWT;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport javax.ws.rs.WebApplicationException;\nimport javax.ws.rs.core.Response;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class QueueTokenVerifier {\n\n  public static final String ISSUER_ADMIN = \"admin\";\n  public static final String ISSUER_AIRFLOW = \"airflow\";\n  public static final String CLAIM_ALLOWED_QUEUES = \"allowedQueues\";\n  private static final Logger logger = LoggerFactory.getLogger(QueueTokenVerifier.class);\n\n  // Verify whether the token is a valid queue token using given secrets to decode it.\n  // Multiple decoding secrets here is to support secret rotation.\n  // The method will also verify the queue token has a claim allowedQueues which contain the given\n  // queue.\n  public static void verify(String token, List<String> secretCandidates, String queue) {\n    if (secretCandidates == null || secretCandidates.isEmpty()) {\n      throw new WebApplicationException(\n          \"Server not configured with secrets to verify queue token\",\n          Response.Status.INTERNAL_SERVER_ERROR);\n    }\n\n    Throwable lastException = null;\n    DecodedJWT jwt = null;\n\n    for (int i = 0; i < secretCandidates.size(); i++) {\n      try {\n        String secret = secretCandidates.get(i);\n        jwt = JwtUtils.verifyToken(token, secret);\n      } catch (Throwable ex) {\n        logger.warn(String.format(\"Failed to verify token with secret %s\", i), ex);\n        lastException = ex;\n      }\n    }\n\n    if (jwt == null) {\n      if (lastException == null || !(lastException instanceof JWTVerificationException)) {\n        throw new WebApplicationException(\n            \"Server failed to verify queue token. Please contact service support.\",\n            Response.Status.INTERNAL_SERVER_ERROR);\n      } else {\n        throw new WebApplicationException(\n            String.format(\n                \"Queue token is not valid: %s. Please provide a valid queue token, or contact\"\n                    + \" service support.\",\n                lastException.getMessage()),\n            Response.Status.BAD_REQUEST);\n      }\n    }\n\n    String issuer = jwt.getIssuer();\n    if (issuer == null || issuer.isEmpty()) {\n      throw new WebApplicationException(\n          \"Queue token is not valid: no issuer. Please provide a valid queue token, or contact\"\n              + \" service support.\",\n          Response.Status.BAD_REQUEST);\n    }\n\n    if (!issuer.equalsIgnoreCase(ISSUER_ADMIN) && !issuer.equalsIgnoreCase(ISSUER_AIRFLOW)) {\n      throw new WebApplicationException(\n          String.format(\n              \"Queue token is not valid due to unsupported issuer: %s. Please provide a valid queue\"\n                  + \" token, or contact service support.\",\n              issuer),\n          Response.Status.BAD_REQUEST);\n    }\n\n    Claim claim = jwt.getClaim(CLAIM_ALLOWED_QUEUES);\n    if (claim == null || claim.isNull()) {\n      throw new WebApplicationException(\n          String.format(\n              \"Queue token is not valid due to no claim: %s. Please provide a valid queue token, or\"\n                  + \" contact service support.\",\n              CLAIM_ALLOWED_QUEUES),\n          Response.Status.BAD_REQUEST);\n    }\n\n    Set<String> allowedQueues = new HashSet<>();\n\n    try {\n      String[] values = claim.asArray(String.class);\n      for (String str : values) {\n        allowedQueues.add(str);\n      }\n    } catch (Throwable ex) {\n      logger.warn(String.format(\"Failed to convert claim %s to array\", claim), ex);\n    }\n\n    if (allowedQueues.isEmpty()) {\n      try {\n        List<String> values = claim.asList(String.class);\n        allowedQueues.addAll(values);\n      } catch (Throwable ex) {\n        logger.warn(String.format(\"Failed to convert claim %s to list\", claim), ex);\n      }\n    }\n\n    if (allowedQueues.isEmpty()) {\n      throw new WebApplicationException(\n          \"Queue token has no allowed queues. Please provide a valid queue token, or contact\"\n              + \" service support.\",\n          Response.Status.BAD_REQUEST);\n    }\n\n    if (!allowedQueues.contains(queue)) {\n      throw new WebApplicationException(\n          String.format(\n              \"Queue token does not allow queue %s. Please provide a valid queue token, or contact\"\n                  + \" service support.\",\n              queue),\n          Response.Status.BAD_REQUEST);\n    }\n  }\n}\n"
    },
    {
        "detailed_description": "The class AbstractSplitFilter is an implementation of the PipeFilter interface. This class is designed to handle the splitting of images. The execute method is overridden from the PipeFilter interface and takes a list of BufferedImages as an argument. This method first checks if the list of images is null or empty, throwing an exception if either condition is met. If the list contains more than one image, a HandlingException is thrown, as the splitting of multiple images is not supported. If the list contains only one image, the split method is called on that image. The split method is an abstract method, meaning it must be implemented by any class that extends AbstractSplitFilter. This method takes a single BufferedImage as an argument and returns a list of BufferedImages, representing the result of splitting the original image into multiple images.\"",
        "sketchy_description": "The class AbstractSplitFilter, which implements the PipeFilter interface, is designed to represent a filter that can take a single image and split it into multiple images. This functionality is particularly useful in image processing pipelines where an image may need to be divided into smaller segments for further analysis or manipulation.\n\nThe execute method is a public method that takes a list of BufferedImage objects as input and applies the filter to split the first image in the list into multiple images. This method is designed to handle specific conditions and will throw an exception if the input list is null, empty, or contains more than one image. This ensures that the filter operates as expected and provides clear feedback to the user in case of improper usage.\n\nThe split method is a protected abstract method that must be implemented by subclasses of AbstractSplitFilter. This method takes a single BufferedImage object and is responsible for defining the logic to split this image into multiple images. The abstract nature of this method allows for different implementations to provide their own unique splitting strategies, making the AbstractSplitFilter class flexible and extensible for various image splitting requirements.",
        "file": "imglib/pipe/src/main/java/cn/pipe/ypipe/AbstractSplitFilter.java",
        "class_name": "AbstractSplitFilter",
        "repo_metadata": {
            "repo_name": "imglib"
        },
        "evaluation_metadata": {
            "test_class_name": "AbstractSplitFilterTest",
            "test_file": "imglib/pipe/src/test/java/cn/pipe/ypipe/AbstractSplitFilterTest.java"
        },
        "task_id": 6,
        "ground_truth_class_body": "package cn.pipe.ypipe;\n\nimport cn.core.PipeFilter;\nimport cn.core.ex.HandlingException;\nimport cn.core.utils.CollectionUtils;\nimport cn.core.utils.ObjectUtils;\n\nimport java.awt.image.BufferedImage;\nimport java.util.List;\n\n/**\n * An abstract pipe filter which used to split one images into multiple slices.\n *\n * @author tracy\n * @since 0.2.1\n */\npublic abstract class AbstractSplitFilter implements PipeFilter {\n\n    @Override\n    public List<BufferedImage> execute(List<BufferedImage> images) {\n        ObjectUtils.excNull(images, \"Source images is null.\");\n        CollectionUtils.excEmpty(images, \"Not any source image was found.\");\n        if (images.size() > 1) {\n            throw new HandlingException(\"Splitting of multiple images is not supported.\");\n        }\n        return split(images.get(0));\n    }\n\n    /**\n     * Split one image into multiple images.\n     *\n     * @param image The source image.\n     * @return The final images after split.\n     */\n    protected abstract List<BufferedImage> split(BufferedImage image);\n}\n"
    },
    {
        "detailed_description": "The public class TimestampNumberHandler is a subclass of the AbstractTimestampCellHandler class. This class is designed to handle timestamp data in Excel cells, specifically by converting the timestamp into a numeric format that Excel can understand. The class overrides two methods from its superclass. The first method, setCellValue, is responsible for setting the value of a cell in an Excel row. It takes four arguments: a RowContext object that represents the current row, an ExcelFieldConfig object that contains configuration information for the Excel field, a Cell object that represents the cell to be modified, and a Timestamp object that represents the value to be set. The method converts the timestamp to a local date-time object, then converts that to an Excel date using the DateUtil.getExcelDate method, and finally sets the cell's value to this date. The second method, getExcelType, returns the ExcelType of the cell, which in this case is NUMERIC. This indicates that the cell's value should be interpreted as a number.\"",
        "sketchy_description": "The public class TimestampNumberHandler, which extends the AbstractTimestampCellHandler, is specialized in handling the conversion of Timestamp values into a numeric format that is compatible with Excel cells. This functionality is particularly useful when dealing with the export or manipulation of date and time data within Excel spreadsheets.\n\nThe class provides a protected method setCellValue, which takes a RowContext, an ExcelFieldConfig, a Cell, and a Timestamp as parameters. This method is responsible for converting the given Timestamp value into Excel's numeric date format and then setting this value as the content of the specified cell. This conversion ensures that the date and time information is accurately represented within the Excel environment, allowing for proper formatting and calculations.\n\nAdditionally, the class includes a public method getExcelType, which returns an ExcelType enumeration value that corresponds to 'numeric'. This method indicates the type of data that the handler deals with, which in this case is numeric representations of dates and times. This information can be used by other components of the system to make decisions about how to process or format the data handled by this class.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/timestamp/TimestampNumberHandler.java",
        "class_name": "TimestampNumberHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "TimestampNumberHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/TimestampNumberHandlerTest.java"
        },
        "task_id": 7,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.timestamp;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport org.apache.poi.ss.usermodel.Cell;\nimport org.apache.poi.ss.usermodel.DateUtil;\n\nimport java.sql.Timestamp;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class TimestampNumberHandler extends AbstractTimestampCellHandler {\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, Timestamp value) {\n        cell.setCellValue(DateUtil.getExcelDate(value.toLocalDateTime()));\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.NUMERIC;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class RecordComparator implements the Comparator interface for objects of the Record type. This class is designed to compare two Record objects based on certain criteria. It contains four private fields: two List<String> fields named rowKeyNames and sortKeyNames, and two KeyComparator fields named rowKeyComparator and sortKeyComparator. \n\nThe constructor of this class takes a Schema object as an argument. It initializes the rowKeyNames and sortKeyNames fields with the row key field names and sort key field names from the schema, respectively. It also initializes the rowKeyComparator and sortKeyComparator fields with new KeyComparator objects, using the row key types and sort key types from the schema, respectively.\n\nThe class overrides the compare method from the Comparator interface. This method takes two Record objects as arguments and returns an integer. It first gets the values of the row keys and sort keys from the two records. It then compares the row keys using the rowKeyComparator. If the row keys are not equal, it returns the result of this comparison. If the row keys are equal, it compares the sort keys using the sortKeyComparator and returns the result of this comparison. This method is used to sort a collection of Record objects based on the row keys and sort keys.\"",
        "sketchy_description": "The public class RecordComparator, which implements the Comparator interface for Record objects, is designed to provide a custom comparison logic that is based on a given schema. This class is particularly useful when sorting or ordering collections of Record objects according to specific criteria defined by the schema. The class contains private final variables that hold the names of the row keys and sort keys, as well as comparators for these keys, which are used in the comparison process.\n\nThe constructor of the RecordComparator class takes a Schema object as an argument and uses this schema to initialize the comparators for both the row keys and the sort keys. These comparators are then used to define the ordering of the Record objects.\n\nThe compare method is a crucial part of the class, as it overrides the compare method from the Comparator interface. It takes two Record objects as parameters and compares them by first looking at their row keys and then at their sort keys. The comparison is performed in a way that respects the ordering defined by the schema, and the method returns an integer value that indicates the relative ordering of the two records. A negative value means the first record is less than the second, zero means they are equal, and a positive value means the first record is greater than the second. This method enables the sorting of Record objects in collections such as lists or trees according to the specified schema.",
        "file": "sleeper/java/core/src/main/java/sleeper/core/record/RecordComparator.java",
        "class_name": "RecordComparator",
        "repo_metadata": {
            "repo_name": "sleeper"
        },
        "evaluation_metadata": {
            "test_class_name": "RecordComparatorTest",
            "test_file": "sleeper/java/core/src/test/java/sleeper/core/record/RecordComparatorTest.java"
        },
        "task_id": 8,
        "ground_truth_class_body": "/*\n * Copyright 2022-2023 Crown Copyright\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage sleeper.core.record;\n\nimport sleeper.core.key.Key;\nimport sleeper.core.schema.Schema;\n\nimport java.util.Comparator;\nimport java.util.List;\n\n/**\n * Compares {@link Record}s by row keys then sort keys.\n */\npublic class RecordComparator implements Comparator<Record> {\n    private final List<String> rowKeyNames;\n    private final List<String> sortKeyNames;\n    private final KeyComparator rowKeyComparator;\n    private final KeyComparator sortKeyComparator;\n\n    public RecordComparator(Schema schema) {\n        this.rowKeyNames = schema.getRowKeyFieldNames();\n        this.sortKeyNames = schema.getSortKeyFieldNames();\n        this.rowKeyComparator = new KeyComparator(schema.getRowKeyTypes());\n        this.sortKeyComparator = new KeyComparator(schema.getSortKeyTypes());\n    }\n\n    // TODO Optimise by avoiding creating lists of row keys and sort keys, and\n    // just do the comparison directly here?\n    @Override\n    public int compare(Record record1, Record record2) {\n        List<Object> record1Key = record1.getValues(rowKeyNames);\n        List<Object> record2Key = record2.getValues(rowKeyNames);\n        int keyComparison = rowKeyComparator.compare(Key.create(record1Key), Key.create(record2Key));\n        if (0 != keyComparison) {\n            return keyComparison;\n        }\n        List<Object> record1SortFields = record1.getValues(sortKeyNames);\n        List<Object> record2SortFields = record2.getValues(sortKeyNames);\n        return sortKeyComparator.compare(Key.create(record1SortFields), Key.create(record2SortFields));\n    }\n}\n"
    },
    {
        "detailed_description": "The public class BigDecimalStringHandler is a subclass of the AbstractBigDecimalCellHandler class. This class is designed to handle BigDecimal values in Excel cells, specifically by converting them into String format. The class overrides two methods from its superclass. \n\nThe first overridden method is setCellValue. This method takes four parameters: a RowContext object, an ExcelFieldConfig object, a Cell object, and a BigDecimal value. The method first retrieves the Java format for the Excel field configuration using the getJavaFormat method. It then formats the BigDecimal value into a String using the ExcelNumberUtils.format method, with the retrieved Java format as one of the parameters. The formatted String value is then set as the value of the Cell object using the setCellValue method.\n\nThe second overridden method is getExcelType. This method does not take any parameters and returns an ExcelType enumeration value. Specifically, it returns ExcelType.STRING, indicating that this handler is used for Excel cells that are expected to contain String values.\"",
        "sketchy_description": "The public class BigDecimalStringHandler, which extends the AbstractBigDecimalCellHandler, is specifically designed to handle the conversion of BigDecimal values into their String representations for use within Excel cells. This functionality is particularly important when dealing with numerical data that requires precise representation, such as financial figures or statistical data, which need to be accurately displayed in Excel spreadsheets.\n\nThe class provides a protected method setCellValue, which takes a RowContext, an ExcelFieldConfig, a Cell, and a BigDecimal value as parameters. This method is responsible for setting the cell's value in the spreadsheet. It does so by formatting the BigDecimal value into a string based on the formatting rules specified in the ExcelFieldConfig. This ensures that the numerical value is represented in the cell as a string in a way that adheres to the desired formatting conventions, such as the number of decimal places or the use of commas for thousands.\n\nAdditionally, the class includes a public method getExcelType, which returns an ExcelType enumeration value. This method specifically returns the enumeration value that corresponds to the STRING type, indicating that this handler deals with the conversion of BigDecimal values to their String representations, rather than to any other data type that might be supported by Excel.\n\nThese methods are crucial for developers who are working with Excel file generation and manipulation in Java, as they provide the necessary tools to ensure that BigDecimal values are properly formatted and represented as strings within the cells of an Excel spreadsheet.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/bigdecimal/BigDecimalStringHandler.java",
        "class_name": "BigDecimalStringHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "BigDecimalStringHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/BigDecimalStringHandlerTest.java"
        },
        "task_id": 9,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.bigdecimal;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport io.github.zouzhiy.excel.utils.ExcelNumberUtils;\nimport org.apache.poi.ss.usermodel.Cell;\n\nimport java.math.BigDecimal;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class BigDecimalStringHandler extends AbstractBigDecimalCellHandler {\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, BigDecimal value) {\n        String javaFormat = this.getJavaFormat(excelFieldConfig);\n        String strValue = ExcelNumberUtils.format(value, javaFormat);\n        cell.setCellValue(strValue);\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.STRING;\n    }\n\n\n}\n"
    },
    {
        "detailed_description": "The public class InputStreamImageSource implements the BufferedImageSource interface, which is designed to handle images from an InputStream source. The class contains a protected InputStream object named 'source', a boolean 'readCompleted' to indicate if the reading process is completed, and a String 'originalFormatName' to store the original format of the image.\n\nThe constructor of this class takes an InputStream object as an argument. If the provided InputStream is null, it throws a NullPointerException. Otherwise, it assigns the InputStream to the 'source' member.\n\nThe class overrides four methods from the BufferedImageSource interface:\n\n1. The 'read' method reads an image from the InputStream. It creates an ImageInputStream from the source, gets an iterator of ImageReaders that can decode the image, and checks if there are any suitable ImageReaders. If there are no suitable ImageReaders, it throws an UnsupportedFormatException. Otherwise, it reads the image using the first suitable ImageReader and stores the format name in 'originalFormatName'. After reading the image, it sets 'readCompleted' to true and returns the image.\n\n2. The 'getOriginalFormatName' method returns the original format of the image.\n\n3. The 'getSource' method returns the InputStream source.\n\n4. The 'isReadCompleted' method returns the value of 'readCompleted', indicating whether the reading process is completed.\"",
        "sketchy_description": "The public class InputStreamImageSource implements the BufferedImageSource interface specifically for InputStreams, providing the functionality to read images from an InputStream source. This class is equipped with a constructor that takes an InputStream as an argument and initializes the object with it, ensuring that the provided InputStream is not null to avoid a NullPointerException.\n\nThe class exposes several methods to interact with the InputStream and the images it contains. The read method is designed to read an image from the InputStream and return it as a BufferedImage object. This method can throw an IOException if an error occurs during the reading process, and it can also throw an UnsupportedFormatException if the format of the image is not recognized by any available ImageReader.\n\nAdditionally, the class provides a method to retrieve the original format name of the image that was read, which can be useful for processing or displaying the image correctly. The getSource method allows access to the original InputStream, enabling further operations or reading additional data if necessary.\n\nFinally, the isReadCompleted method indicates whether the image reading process has been completed successfully. This can be particularly useful for checking the state of the reading process, especially in asynchronous or multi-threaded environments where the reading operation might be performed separately from the main program flow.",
        "file": "imglib/core/src/main/java/cn/core/in/InputStreamImageSource.java",
        "class_name": "InputStreamImageSource",
        "repo_metadata": {
            "repo_name": "imglib"
        },
        "evaluation_metadata": {
            "test_class_name": "InputStreamImageSourceTest",
            "test_file": "imglib/core/src/test/java/cn/core/in/InputStreamImageSourceTest.java"
        },
        "task_id": 10,
        "ground_truth_class_body": "package cn.core.in;\n\nimport cn.core.ex.UnsupportedFormatException;\nimport cn.core.utils.ObjectUtils;\nimport javax.imageio.ImageIO;\nimport javax.imageio.ImageReadParam;\nimport javax.imageio.ImageReader;\nimport javax.imageio.stream.ImageInputStream;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Iterator;\n\n/**\n * Buffered image data source whose from input stream.\n *\n * @author tracy\n * @since 0.2.1\n */\npublic class InputStreamImageSource implements BufferedImageSource<InputStream> {\n\n    protected final InputStream source;\n    protected boolean readCompleted = false;\n    protected String originalFormatName;\n\n    public InputStreamImageSource(InputStream source) {\n        if (ObjectUtils.isNull(source)) {\n            throw new NullPointerException(\"InputStream is null.\");\n        }\n        this.source = source;\n    }\n\n    @Override\n    public BufferedImage read() throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(source);\n        Iterator<ImageReader> readers = ImageIO.getImageReaders(iis);\n        if (!readers.hasNext()) {\n            // can not parse input stream\n            iis.close();\n            throw new UnsupportedFormatException(\"No suitable ImageReader found for source input stream.\");\n        }\n\n        ImageReader reader = readers.next();\n        ImageReadParam param = reader.getDefaultReadParam();\n        reader.setInput(iis);\n\n        BufferedImage image;\n        try {\n            // original format name\n            originalFormatName = reader.getFormatName();\n            // read image\n            image = reader.read(0, param);\n        } finally {\n            reader.dispose();\n            iis.close();\n        }\n\n        readCompleted = true;\n        return image;\n    }\n\n\n    @Override\n    public String getOriginalFormatName() {\n        return originalFormatName;\n    }\n\n    @Override\n    public InputStream getSource() {\n        return source;\n    }\n\n    @Override\n    public boolean isReadCompleted() {\n        return readCompleted;\n    }\n\n}\n"
    },
    {
        "detailed_description": "The public class ByteArrayStringHandler is a specialized class that extends the AbstractCellHandler class, specifically designed to handle byte arrays. This class is primarily used for handling Excel cells that contain string data, which it converts to and from byte arrays. \n\nThe class overrides three methods from the AbstractCellHandler class. The first method, getCellValue, takes a SheetContext object, an ExcelFieldConfig object, and a CellResult object as parameters. It retrieves the string value from the first cell result, converts it to a byte array using the UTF-8 character set, and returns this byte array.\n\nThe second method, setCellValue, takes a RowContext object, an ExcelFieldConfig object, a Cell object, and a byte array as parameters. It converts the byte array back into a string using the UTF-8 character set and sets this string as the value of the cell.\n\nThe third method, getExcelType, returns the ExcelType of the cell, which in this case is always STRING. This method is used to ensure that the cell data is being handled correctly based on its type.\"",
        "sketchy_description": "The public class ByteArrayStringHandler, which extends AbstractCellHandler, is specifically designed to manage the conversion between byte arrays and strings within the context of Excel cells. This functionality is particularly useful when dealing with data that needs to be encoded or decoded while working with Excel sheets.\n\nThe class provides a protected method named getCellValue, which takes a SheetContext, an ExcelFieldConfig, and a CellResult as parameters. This method is responsible for converting the string value retrieved from the first cell result into a byte array, using UTF-8 encoding. This is essential for ensuring that the data is correctly encoded for further processing or storage.\n\nAnother protected method, setCellValue, is provided to perform the reverse operation. It takes a RowContext, an ExcelFieldConfig, a Cell, and a byte array as parameters. The method sets the cell's value to a string that is created from the byte array, again using UTF-8 encoding. This ensures that the data is properly decoded when being placed back into the Excel sheet.\n\nLastly, the class includes a public method called getExcelType, which returns the ExcelType enumeration value corresponding to strings. This indicates the type of data that the handler is dealing with, which in this case, is strings. This method is useful for identifying the data type within the Excel environment and ensuring that the handler is used appropriately for string data.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/bytes/ByteArrayStringHandler.java",
        "class_name": "ByteArrayStringHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "ByteArrayStringHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/ByteArrayStringHandlerTest.java"
        },
        "task_id": 11,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.bytes;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.context.SheetContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.handler.AbstractCellHandler;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport io.github.zouzhiy.excel.metadata.result.CellResult;\nimport org.apache.poi.ss.usermodel.Cell;\n\nimport java.nio.charset.StandardCharsets;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class ByteArrayStringHandler extends AbstractCellHandler<byte[]> {\n\n    @Override\n    protected byte[] getCellValue(SheetContext sheetContext, ExcelFieldConfig excelFieldConfig, CellResult firstCellResult) {\n        String value = firstCellResult.getStringValue();\n        return value.getBytes(StandardCharsets.UTF_8);\n    }\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, byte[] value) {\n        cell.setCellValue(new String(value, StandardCharsets.UTF_8));\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.STRING;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class EmptySourceBuilder is a subclass of the AbstractSourceBuilder class, with EmptySourceBuilder as its generic type. This class is designed to build a source of images, which are generated by ImageGenerator objects. \n\nThe class contains a protected List of ImageGenerator objects named 'captors'. This list is initialized as an empty ArrayList. \n\nThe class provides two public methods for registering ImageGenerator objects. The first method, 'register', takes a single ImageGenerator object as an argument, checks if it is null, and if it is not, adds it to the 'captors' list. The method then returns the current instance of EmptySourceBuilder, allowing for method chaining. \n\nThe second 'register' method is an overloaded version that takes an array of ImageGenerator objects. It checks if the array is null or empty, and if it is not, adds all the ImageGenerator objects in the array to the 'captors' list. This method also returns the current instance of EmptySourceBuilder. \n\nThe class also contains a protected method 'checkReadiness' that checks if the 'captors' list is null or empty. If it is, it throws a HandlingException with a message indicating that no captors are registered. \n\nFinally, the class overrides the 'obtainSourceImages' method from the AbstractSourceBuilder class. This method first calls the 'checkReadiness' method to ensure that there are ImageGenerator objects registered. It then creates a new List of BufferedImages, and for each ImageGenerator in the 'captors' list, it calls the 'generate' method on the ImageGenerator and adds the resulting BufferedImage to the list. The method then returns the list of BufferedImages.\"",
        "sketchy_description": "The public class EmptySourceBuilder, which extends AbstractSourceBuilder, is designed to facilitate the construction of a source that utilizes registered ImageGenerators. This class maintains a protected list of ImageGenerator objects, which are used to generate images. The class provides methods to register ImageGenerators, either individually or in multiples, to the builder. The register method that accepts a single ImageGenerator argument adds that generator to the builder, and it will throw an exception if the provided ImageGenerator is null. Similarly, the register method that accepts a variable number of ImageGenerator arguments allows for the registration of multiple generators at once, and it will throw an exception if the provided array is null or empty.\n\nAdditionally, the class includes a protected method, checkReadiness, which verifies that at least one ImageGenerator has been registered before proceeding with any operations that require the generators. If no ImageGenerators are registered, this method will throw an exception.\n\nFinally, the class overrides the obtainSourceImages method from its superclass. This method is responsible for obtaining a list of source images from the registered ImageGenerators. It ensures that the builder is in a ready state, with at least one registered ImageGenerator, before attempting to obtain the images. This method is a key part of the image generation process, as it collects the images that are ultimately used by the builder.",
        "file": "imglib/all/src/main/java/cn/usage/builder/EmptySourceBuilder.java",
        "class_name": "EmptySourceBuilder",
        "repo_metadata": {
            "repo_name": "imglib"
        },
        "evaluation_metadata": {
            "test_class_name": "EmptySourceBuilderTest",
            "test_file": "imglib/all/src/test/java/cn/usage/builder/EmptySourceBuilderTest.java"
        },
        "task_id": 12,
        "ground_truth_class_body": "package cn.usage.builder;\n\nimport cn.usage.AbstractSourceBuilder;\nimport cn.core.ImageGenerator;\nimport cn.core.ex.HandlingException;\nimport cn.core.utils.CollectionUtils;\nimport cn.core.utils.ObjectUtils;\nimport java.awt.image.BufferedImage;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * A source builder which have no source.\n *\n * @author tracy\n * @since 0.2.1\n */\npublic class EmptySourceBuilder extends AbstractSourceBuilder<EmptySourceBuilder> {\n\n    protected List<ImageGenerator> captors = new ArrayList<>();\n\n    public EmptySourceBuilder register(ImageGenerator ig) {\n        ObjectUtils.excNull(ig, \"ImageGenerator is null.\");\n        captors.add(ig);\n        return this;\n    }\n\n    public EmptySourceBuilder register(ImageGenerator... igs) {\n        ObjectUtils.excNull(igs, \"No ImageGenerator was found.\");\n        CollectionUtils.excEmpty(igs, \"Empty ImageGenerator array.\");\n        captors.addAll(Arrays.asList(igs));\n        return this;\n    }\n\n    protected void checkReadiness() {\n        if (CollectionUtils.isNullOrEmpty(captors)) {\n            throw new HandlingException(\"No captors are registered.\");\n        }\n    }\n\n    @Override\n    protected List<BufferedImage> obtainSourceImages(){\n        checkReadiness();\n        List<BufferedImage> images = new ArrayList<>();\n        for (ImageGenerator ca : captors) {\n            images.add(ca.generate());\n        }\n        return images;\n    }\n\n}\n"
    },
    {
        "detailed_description": "The public class FloatStringHandler is a subclass of the AbstractFloatCellHandler class. This class is designed to handle the conversion of float values to string values in the context of an Excel spreadsheet. The class overrides two methods from its superclass. \n\nThe first overridden method is setCellValue. This method takes four parameters: a RowContext object, an ExcelFieldConfig object, a Cell object, and a Float value. The method first retrieves the Java format for the Excel field configuration using the getJavaFormat method. It then formats the float value into a string using the ExcelNumberUtils.format method, with the retrieved Java format as one of the parameters. The formatted string value is then set as the value of the cell.\n\nThe second overridden method is getExcelType. This method returns an enumeration value of ExcelType.STRING, indicating that the Excel cell type that this handler deals with is a string.\"",
        "sketchy_description": "The public class FloatStringHandler, which extends AbstractFloatCellHandler, is specifically designed to manage the conversion of floating-point numbers into string representations for use within Excel cells. This functionality is particularly useful when dealing with numerical data that needs to be formatted and displayed as text within a spreadsheet.\n\nThe class provides a protected method setCellValue, which takes a RowContext, an ExcelFieldConfig, a Cell, and a Float as parameters. This method is tasked with formatting the float value according to the Java format specified in the ExcelFieldConfig and then setting the formatted string as the value of the provided Cell. This allows for a consistent and customizable way to present numerical data as strings within Excel.\n\nAdditionally, the class includes a public method getExcelType, which returns the enum ExcelType.STRING. This indicates that the FloatStringHandler is dedicated to handling the conversion of float values to string data types within Excel. This method is essential for the system to understand the type of data conversion the handler is responsible for, ensuring that float values are processed correctly when generating Excel documents.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/floats/FloatStringHandler.java",
        "class_name": "FloatStringHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "FloatStringHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/FloatStringHandlerTest.java"
        },
        "task_id": 13,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.floats;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport io.github.zouzhiy.excel.utils.ExcelNumberUtils;\nimport org.apache.poi.ss.usermodel.Cell;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class FloatStringHandler extends AbstractFloatCellHandler {\n\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, Float value) {\n        String javaFormat = this.getJavaFormat(excelFieldConfig);\n        String strValue = ExcelNumberUtils.format(value, javaFormat);\n        cell.setCellValue(strValue);\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.STRING;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class WrappedKeyComparator is designed to compare two keys based on a given schema. This class implements the Comparator interface for the Key type and is also Serializable, meaning it can be converted into a byte stream and restored from it. The class has a serialVersionUID, which is used for version control during the serialization process. \n\nThe class has two private fields: a String 'schemaAsString' and a transient KeyComparator 'keyComparator'. The 'schemaAsString' field stores the schema in a string format, while the 'keyComparator' field is used to compare keys. The 'transient' keyword indicates that the 'keyComparator' field should not be serialized.\n\nThe constructor of the class takes a string argument representing the schema and initializes the 'schemaAsString' field with it.\n\nThe class overrides the 'compare' method from the Comparator interface. This method takes two Key objects as arguments and returns an integer. If the 'keyComparator' field is null, the method creates a new Schema object from the 'schemaAsString' field using the SchemaSerDe class, gets the row and sort key types from the schema, and initializes the 'keyComparator' field with a new KeyComparator object created with these types. Finally, the method uses the 'keyComparator' to compare the two Key objects and returns the result.\"",
        "sketchy_description": "The public class WrappedKeyComparator is designed to provide a comparison logic for Key objects, which is essential for sorting or ordering collections of keys. This class implements the Comparator interface, which requires the definition of a compare method, and it is also marked as Serializable, allowing instances of this class to be serialized for storage or transmission. The class contains a static final long serialVersionUID, which is a unique identifier for Serializable classes and is used to ensure that a deserialized object matches the serialized object. Additionally, the class holds a schemaAsString variable, which represents the schema that dictates the comparison logic.\n\nThe constructor of the WrappedKeyComparator class takes a single String argument, schemaAsString, which is used to initialize the comparator with a specific schema. This schema is then utilized within the compare method to determine how two Key objects should be compared to each other.\n\nThe compare method, which is annotated with @Override to indicate that it is overriding a method from the Comparator interface, takes two Key objects as parameters. It uses a dynamically created KeyComparator, which is based on the provided schema, to compare the two keys. The result of this comparison is an integer that indicates the relative ordering of the keys: a negative integer if the first key is less than the second key, zero if they are equal, or a positive integer if the first key is greater than the second key. This method enables collections of Key objects to be sorted according to the specified schema.",
        "file": "sleeper/java/bulk-import/bulk-import-runner/src/main/java/sleeper/bulkimport/job/runner/rdd/WrappedKeyComparator.java",
        "class_name": "WrappedKeyComparator",
        "repo_metadata": {
            "repo_name": "sleeper"
        },
        "evaluation_metadata": {
            "test_class_name": "WrappedKeyComparatorTest",
            "test_file": "sleeper/java/bulk-import/bulk-import-runner/src/test/java/sleeper/bulkimport/job/runner/rdd/WrappedKeyComparatorTest.java"
        },
        "task_id": 14,
        "ground_truth_class_body": "/*\n * Copyright 2022-2023 Crown Copyright\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage sleeper.bulkimport.job.runner.rdd;\n\nimport sleeper.core.key.Key;\nimport sleeper.core.record.KeyComparator;\nimport sleeper.core.schema.Schema;\nimport sleeper.core.schema.SchemaSerDe;\nimport sleeper.core.schema.type.PrimitiveType;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\n\n\n/**\n * The {@link WrappedKeyComparator} is a {@link Comparator} of Sleeper {@link Key}s\n * that sorts them in the natural way as defined by the Sleeper schema, i.e.\n * it sorts by the row keys and then the sort keys.\n */\npublic class WrappedKeyComparator implements Comparator<Key>, Serializable {\n    private static final long serialVersionUID = 7448396149070034670L;\n    private final String schemaAsString;\n    private transient KeyComparator keyComparator;\n\n    public WrappedKeyComparator(String schemaAsString) {\n        this.schemaAsString = schemaAsString;\n    }\n\n    @Override\n    public int compare(Key key1, Key key2) {\n        if (null == keyComparator) {\n            Schema schema = new SchemaSerDe().fromJson(schemaAsString);\n            List<PrimitiveType> rowAndSortKeyTypes = new ArrayList<>();\n            rowAndSortKeyTypes.addAll(schema.getRowKeyTypes());\n            rowAndSortKeyTypes.addAll(schema.getSortKeyTypes());\n            keyComparator = new KeyComparator(rowAndSortKeyTypes);\n        }\n        return keyComparator.compare(key1, key2);\n    }\n}\n"
    },
    {
        "detailed_description": "The class AbstractMergeFilter is an abstract class that implements the PipeFilter interface. This class is designed to merge multiple images into one. The execute method is overridden from the PipeFilter interface and takes a list of BufferedImages as an argument. This method first checks if the list of images is null or empty, throwing an exception if either condition is met. If the list is not null and contains at least one image, the method calls the merge method with the list of images as an argument and returns a list containing the single, merged image. The merge method is an abstract method that takes a list of BufferedImages and returns a single BufferedImage. This method is intended to be implemented by subclasses of AbstractMergeFilter, allowing different merging strategies to be used.\"",
        "sketchy_description": "The class AbstractMergeFilter, which implements the PipeFilter interface, serves as a template for creating filters that can merge multiple BufferedImage objects into a single image. This functionality is particularly useful in image processing where combining several images into one is a common task.\n\nThe execute method is a public method that takes a list of BufferedImage objects as input and applies the filter process to these images. The result of this process is a list containing the merged image, which is then returned to the caller. This method leverages the abstract merge method to perform the actual merging operation.\n\nThe merge method is a protected abstract method that defines the signature for merging multiple BufferedImage objects into a single image. Since it is abstract, it does not provide an implementation; instead, it must be implemented by any subclass that extends AbstractMergeFilter. The implementation will dictate the specific way in which the images are combined, which can vary depending on the desired merging strategy.",
        "file": "imglib/pipe/src/main/java/cn/pipe/ypipe/AbstractMergeFilter.java",
        "class_name": "AbstractMergeFilter",
        "repo_metadata": {
            "repo_name": "imglib"
        },
        "evaluation_metadata": {
            "test_class_name": "AbstractMergeFilterTest",
            "test_file": "imglib/pipe/src/test/java/cn/pipe/ypipe/AbstractMergeFilterTest.java"
        },
        "task_id": 15,
        "ground_truth_class_body": "package cn.pipe.ypipe;\n\nimport cn.core.PipeFilter;\nimport cn.core.utils.CollectionUtils;\nimport cn.core.utils.ObjectUtils;\n\nimport java.awt.image.BufferedImage;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * An abstract pipe filter which used to merge multiple images into one image.\n *\n * @author tracy\n * @since 0.2.1\n */\npublic abstract class AbstractMergeFilter implements PipeFilter {\n\n    @Override\n    public List<BufferedImage> execute(List<BufferedImage> images) {\n        ObjectUtils.excNull(images, \"Source images is null.\");\n        CollectionUtils.excEmpty(images, \"Not any source image was found.\");\n        return Collections.singletonList(merge(images));\n    }\n\n    /**\n     * Merge multiple images into one image.\n     *\n     * @param images The source images.\n     * @return The final image after merged.\n     */\n    protected abstract BufferedImage merge(List<BufferedImage> images);\n}\n"
    },
    {
        "detailed_description": "The public class CalendarNumberHandler is a subclass of the AbstractCalendarCellHandler class. This class is designed to handle calendar cells in an Excel spreadsheet. It overrides two methods from its superclass. \n\nThe first overridden method is setCellValue. This method is designed to set the value of a cell in a row. It takes four parameters: a RowContext object, an ExcelFieldConfig object, a Cell object, and a Calendar object. The method first converts the Calendar object into an Excel date using the DateUtil.getExcelDate method. Then, it sets the value of the cell to this Excel date.\n\nThe second overridden method is getExcelType. This method returns the type of Excel cell that this handler is designed to work with. In this case, the method returns ExcelType.NUMERIC, indicating that this handler is designed to work with numeric cells in an Excel spreadsheet.\"",
        "sketchy_description": "The public class CalendarNumberHandler, which extends the AbstractCalendarCellHandler, is designed to handle the conversion of Calendar values into a format that can be used within Excel cells. This class is particularly useful when dealing with dates and times in the context of Excel spreadsheets, as it allows for the seamless translation of Java's Calendar data type into Excel's numeric date representation.\n\nThe setCellValue method is a protected method that takes a RowContext, an ExcelFieldConfig, a Cell, and a Calendar value as parameters. Its primary function is to set the value of an Excel cell to the numeric date representation that corresponds to the provided Calendar value. This method ensures that dates are displayed correctly within Excel cells, adhering to Excel's internal date formatting.\n\nThe getExcelType method is a public method that returns an ExcelType enumeration value. This value corresponds to the numeric type, indicating that the data handled by this class is represented numerically within Excel. This method is essential for defining the data type that the CalendarNumberHandler is concerned with when interfacing with Excel spreadsheets.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/calendar/CalendarNumberHandler.java",
        "class_name": "CalendarNumberHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "CalendarNumberHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/CalendarNumberHandlerTest.java"
        },
        "task_id": 16,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.calendar;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport org.apache.poi.ss.usermodel.Cell;\nimport org.apache.poi.ss.usermodel.DateUtil;\n\nimport java.util.Calendar;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class CalendarNumberHandler extends AbstractCalendarCellHandler {\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, Calendar value) {\n        double excelDate = DateUtil.getExcelDate(value.getTime());\n        cell.setCellValue(excelDate);\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.NUMERIC;\n    }\n}\n"
    },
    {
        "detailed_description": "The class ParameterChecker is designed to validate parameters in a LinkedHashMap. It is a utility class, as indicated by its private constructor, which prevents the instantiation of this class. \n\nThe class exposes four static methods, all of which are public and can be accessed without creating an instance of the class. \n\nThe first method, checkParameter, takes a LinkedHashMap of parameters, a String parameter, and a Class object as arguments. It checks if the specified parameter is present in the LinkedHashMap and if its type matches the specified Class object. \n\nThe second method, checkOrParameters, takes a LinkedHashMap of parameters and two String parameters. It checks if at least one of the specified parameters is present in the LinkedHashMap. If neither parameter is present, it throws a BinanceConnectorException.\n\nThe third method, checkRequiredParameter, takes a LinkedHashMap of parameters and a String parameter. It checks if the specified parameter is present in the LinkedHashMap. If the parameter is not present, it throws a BinanceConnectorException.\n\nThe fourth method, checkParameterType, takes an Object parameter, a Class object, and a String name. It checks if the type of the Object parameter matches the specified Class object. If the types do not match, or if the parameter is a String and is empty, it throws a BinanceConnectorException. \n\nThese methods are useful for validating parameters in a LinkedHashMap, ensuring that they are present and of the correct type, and throwing an exception if they are not.\"",
        "sketchy_description": "The `ParameterChecker` class is a utility class designed to validate parameters within a `LinkedHashMap`. It provides static methods to ensure that parameters exist, match expected types, and meet certain conditions. The class constructor is private, which prevents the instantiation of the class, reinforcing its utility nature.\n\nThe `checkParameter` method is used to verify that a parameter with a specific key exists within the `LinkedHashMap` and that its value is of the expected type. This is crucial for functions that rely on specific types of input to operate correctly.\n\nThe `checkOrParameters` method extends this functionality by allowing the check to pass if at least one of two specified parameters is present. This is useful in scenarios where a function can proceed with one of several possible inputs.\n\nThe `checkRequiredParameter` method ensures that a parameter deemed necessary for operation is present in the map. This is often used to enforce the presence of mandatory parameters without which a function cannot proceed.\n\nLastly, the `checkParameterType` method provides a more granular check, not only verifying the type of the parameter but also ensuring that if the parameter is a string, it is not empty. This prevents common errors where a parameter is present but contains no meaningful value.\n\nTogether, these methods provide a robust framework for parameter validation in `LinkedHashMap` objects, helping to prevent runtime errors and ensuring that functions receive the inputs they require to perform correctly.",
        "file": "binance-futures-connector-java/src/main/java/com/binance/connector/futures/client/utils/ParameterChecker.java",
        "class_name": "ParameterChecker",
        "repo_metadata": {
            "repo_name": "binance-futures-connector-java"
        },
        "evaluation_metadata": {
            "test_class_name": "TestParameterChecker",
            "test_file": "binance-futures-connector-java/src/test/java/unit/TestParameterChecker.java"
        },
        "task_id": 17,
        "ground_truth_class_body": "package com.binance.connector.futures.client.utils;\n\nimport com.binance.connector.futures.client.exceptions.BinanceConnectorException;\nimport java.util.LinkedHashMap;\n\npublic final class ParameterChecker {\n\n    private ParameterChecker() {\n    }\n\n    public static void checkParameter(LinkedHashMap<String, Object> parameters, String parameter, Class t) {\n        checkRequiredParameter(parameters, parameter);\n        checkParameterType(parameters.get(parameter), t, parameter);\n    }\n\n    public static void checkOrParameters(LinkedHashMap<String, Object> parameters, String parameter, String parameter2) {\n        if (!parameters.containsKey(parameter) && (!parameters.containsKey(parameter2))) {\n            throw new BinanceConnectorException(String.format(\"Either \\\"%s\\\" or \\\"%s\\\" is required!\", parameter, parameter2));\n        }\n    }\n\n    public static void checkRequiredParameter(LinkedHashMap<String, Object> parameters, String parameter) {\n        if (!parameters.containsKey(parameter)) {\n            throw new BinanceConnectorException(String.format(\"\\\"%s\\\" is a mandatory parameter!\", parameter));\n        }\n    }\n\n    public static void checkParameterType(Object parameter, Class t, String name) {\n        if (!t.isInstance(parameter)) {\n            throw new BinanceConnectorException(String.format(\"\\\"%s\\\" must be of %s type.\", name, t));\n        } else if (t == String.class && parameter.toString().trim().equals(\"\")) {\n            throw new BinanceConnectorException(String.format(\"\\\"%s\\\" must not be empty.\", name));\n        }\n    }\n}\n"
    },
    {
        "detailed_description": "The public class DeptTreeDataPermissionChecker is a subclass of the AbstractDataPermissionChecker class. This class is designed to check the data permissions of a department tree in a system. It contains a private member, deptService, of type ISysDeptService, which is presumably a service interface for interacting with department data.\n\nThe class overrides the check method from its superclass. This method takes two parameters: a loginUser of type LoginUser and a condition of type DataCondition. The method first checks if either of these parameters is null, and if so, it returns false, indicating that the check has failed.\n\nNext, it checks if the department ID of the loginUser or the target department ID in the condition is null. If either is null, it again returns false.\n\nIf both checks pass, it retrieves the department ID of the loginUser and the target department ID from the condition. It then checks if the target department is a child of the department of the loginUser or if the department of the loginUser is the same as the target department. It does this by calling the isChildOfTheDept method on the deptService member, passing in the department ID of the loginUser and the target department ID, and by comparing the department ID of the loginUser and the target department ID using the equals method of the Objects class.\n\nThe method finally returns true if either the target department is a child of the department of the loginUser or the department of the loginUser is the same as the target department. Otherwise, it returns false. This method is useful for checking if a user has permission to access data related to a specific department in a department tree.\"",
        "sketchy_description": "The public class DeptTreeDataPermissionChecker, which extends the class AbstractDataPermissionChecker, is designed to manage data permissions within an organizational structure based on departmental hierarchy. The class relies on a private instance of ISysDeptService, which is presumably a service that provides department-related functionalities.\n\nThe primary method of this class is check, which takes a LoginUser object representing the logged-in user and a DataCondition object that encapsulates the conditions under which data access is being requested. The method's purpose is to determine whether the logged-in user has the appropriate permissions to access the data in question. It does this by comparing the user's department with the target department specified in the condition. If the user's department is the same as, or a parent of, the target department, the method returns true, indicating that the user has permission to access the data. If not, the method returns false, indicating that the user does not have the necessary permissions. This method is crucial for maintaining data security and ensuring that users can only access data that is relevant to their departmental level or below.",
        "file": "AgileBoot-Back-End/agileboot-infrastructure/src/main/java/com/agileboot/infrastructure/web/domain/permission/checker/DeptTreeDataPermissionChecker.java",
        "class_name": "DeptTreeDataPermissionChecker",
        "repo_metadata": {
            "repo_name": "AgileBoot-Back-End"
        },
        "evaluation_metadata": {
            "test_class_name": "DeptTreeDataPermissionCheckerTest",
            "test_file": "AgileBoot-Back-End/agileboot-infrastructure/src/test/java/com/agileboot/infrastructure/web/domain/permission/checker/DeptTreeDataPermissionCheckerTest.java"
        },
        "task_id": 18,
        "ground_truth_class_body": "package com.agileboot.infrastructure.web.domain.permission.checker;\n\nimport com.agileboot.infrastructure.web.domain.login.LoginUser;\nimport com.agileboot.infrastructure.web.domain.permission.AbstractDataPermissionChecker;\nimport com.agileboot.infrastructure.web.domain.permission.DataCondition;\nimport com.agileboot.orm.system.service.ISysDeptService;\nimport java.util.Objects;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n/**\n * \u6570\u636e\u6743\u9650\u6d4b\u8bd5\u63a5\u53e3\n * @author valarchie\n */\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class DeptTreeDataPermissionChecker extends AbstractDataPermissionChecker {\n\n    private ISysDeptService deptService;\n\n    @Override\n    public boolean check(LoginUser loginUser, DataCondition condition) {\n        if (condition == null || loginUser == null) {\n            return false;\n        }\n\n        if (loginUser.getDeptId() == null || condition.getTargetDeptId() == null) {\n            return false;\n        }\n\n        Long currentDeptId = loginUser.getDeptId();\n        Long targetDeptId = condition.getTargetDeptId();\n\n        boolean isContainsTargetDept = deptService.isChildOfTheDept(loginUser.getDeptId(), targetDeptId);\n        boolean isSameDept = Objects.equals(currentDeptId, targetDeptId);\n\n        return isContainsTargetDept || isSameDept;\n    }\n\n}\n"
    },
    {
        "detailed_description": "The public class SketchesSerDeToS3 is designed to handle serialization and deserialization of Sketches objects to and from the Hadoop File System (HDFS). It contains a private static final Logger object, LOGGER, for logging information. It also contains a private final Schema object, schema, which represents the schema of the Sketches objects.\n\nThe constructor of this class takes a Schema object as an argument and initializes the schema field with it.\n\nThe class provides two overloaded saveToHadoopFS methods. The first one takes a Path object, a Sketches object, and a Configuration object as arguments. It writes the Sketches object to the Hadoop File System at the specified path and logs the operation. The second saveToHadoopFS method takes a String representing the file system, a String representing the file, a Sketches object, and a Configuration object. It constructs a Path object from the file system and file strings and calls the first saveToHadoopFS method.\n\nSimilarly, the class provides two overloaded loadFromHadoopFS methods for loading Sketches objects from the Hadoop File System. The first method takes a Path object and a Configuration object as arguments. It reads a Sketches object from the specified path in the Hadoop File System and logs the operation. The second loadFromHadoopFS method takes a String representing the file system, a String representing the file, and a Configuration object. It constructs a Path object from the file system and file strings and calls the first loadFromHadoopFS method.\"",
        "sketchy_description": "The public class SketchesSerDeToS3 is designed to handle the serialization and deserialization of Sketches objects specifically for interaction with the Hadoop File System (HDFS). This class includes a static final Logger, which is used to log information related to the operations performed by the class methods.\n\nThe constructor of the SketchesSerDeToS3 class takes a Schema object as an argument and initializes the class with this schema, setting up the necessary environment for subsequent serialization and deserialization tasks.\n\nThe class provides two pairs of methods for saving to and loading from HDFS. The first pair, `saveToHadoopFS(Path path, Sketches sketches, Configuration conf)` and `loadFromHadoopFS(Path path, Configuration conf)`, deal with saving and loading Sketches objects to and from a specified Path in HDFS using a provided Configuration object. These methods are useful when the Path is already known or constructed outside the method call.\n\nThe second pair of methods, `saveToHadoopFS(String fs, String file, Sketches sketches, Configuration conf)` and `loadFromHadoopFS(String fs, String file, Configuration conf)`, allow for saving and loading Sketches objects by constructing the Path from a given filesystem string and file string, using the provided Configuration object. This is convenient when the Path needs to be constructed from its constituent parts, such as the filesystem and file location.\n\nAll methods that interact with HDFS can throw an IOException, which must be handled by the caller to ensure proper error management and resource cleanup. These methods are essential for applications that need to persist and retrieve Sketches objects within a Hadoop-based environment.",
        "file": "sleeper/java/sketches/src/main/java/sleeper/sketches/s3/SketchesSerDeToS3.java",
        "class_name": "SketchesSerDeToS3",
        "repo_metadata": {
            "repo_name": "sleeper"
        },
        "evaluation_metadata": {
            "test_class_name": "SketchesSerDeToS3Test",
            "test_file": "sleeper/java/sketches/src/test/java/sleeper/sketches/s3/SketchesSerDeToS3Test.java"
        },
        "task_id": 19,
        "ground_truth_class_body": "/*\n * Copyright 2022-2023 Crown Copyright\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage sleeper.sketches.s3;\n\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.FSDataInputStream;\nimport org.apache.hadoop.fs.FSDataOutputStream;\nimport org.apache.hadoop.fs.Path;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport sleeper.core.schema.Schema;\nimport sleeper.sketches.SketchSerialiser;\nimport sleeper.sketches.Sketches;\n\nimport java.io.IOException;\n\npublic class SketchesSerDeToS3 {\n    private static final Logger LOGGER = LoggerFactory.getLogger(SketchesSerDeToS3.class);\n\n    private final Schema schema;\n\n    public SketchesSerDeToS3(Schema schema) {\n        this.schema = schema;\n    }\n\n    public void saveToHadoopFS(Path path, Sketches sketches, Configuration conf) throws IOException {\n        try (FSDataOutputStream dataOutputStream = path.getFileSystem(conf).create(path)) {\n            new SketchSerialiser(schema).serialise(sketches, dataOutputStream);\n            LOGGER.info(\"Wrote sketches to {}\", path);\n        }\n    }\n\n    public void saveToHadoopFS(String fs, String file, Sketches sketches, Configuration conf) throws IOException {\n        Path path = new Path(fs + file);\n        saveToHadoopFS(path, sketches, conf);\n    }\n\n    public Sketches loadFromHadoopFS(Path path, Configuration conf) throws IOException {\n        Sketches sketches;\n        try (FSDataInputStream dataInputStream = path.getFileSystem(conf).open(path)) {\n            sketches = new SketchSerialiser(schema).deserialise(dataInputStream);\n        }\n        LOGGER.info(\"Loaded sketches from {}\", path);\n        return sketches;\n    }\n\n    public Sketches loadFromHadoopFS(String fs, String file, Configuration conf) throws IOException {\n        Path path = new Path(fs + file);\n        return loadFromHadoopFS(path, conf);\n    }\n}\n"
    },
    {
        "detailed_description": "The public class DefaultSheetContext implements the SheetContext interface and is designed to handle operations related to a sheet in an Excel workbook. It has private fields for WorkbookContext, ExcelClassConfig, SheetParameter, Sheet, MergedRegion, and Drawing. \n\nThe constructor for this class takes three arguments: WorkbookContext, ExcelClassConfig, and SheetParameter, and initializes the object with these values. \n\nThe class provides getter methods for WorkbookContext, Configuration, Workbook, ExcelClassConfig, SheetParameter, Sheet, MergedRegion, Drawing, and Row. It also provides a method to get a list of rows from the sheet. \n\nThe class has methods to check if the workbook has an InputStream and to get the maximum rowspan for a given row index. \n\nThe class also provides methods to put and get cell styles for title, head, and data. \n\nThe getSheet method is responsible for getting the sheet from the workbook based on the sheet name, sheet index, or title. If the sheet does not exist, it creates a new sheet. \n\nThe getMergedRegion method is responsible for getting the merged regions from the sheet. \n\nThe getMaxRowspan method is responsible for getting the maximum rowspan for a given row index. \n\nThe getDrawing method is responsible for creating a drawing patriarch if it does not exist. \n\nThe getRow method is responsible for getting a row from the sheet based on the row index. \n\nThe getRowList method is responsible for getting a list of rows from the sheet based on the first and last row index. \n\nThe getLasRowIndex method is responsible for getting the last row index from the sheet. \n\nThe getFormulaEvaluator method is responsible for getting the formula evaluator from the workbook context. \n\nThe putTitleCellStyle, putHeadCellStyle, and putDataCellStyle methods are responsible for putting cell styles for title, head, and data respectively. \n\nThe getTitleCellStyle, getHeadCellStyle, and getDataCellStyle methods are responsible for getting cell styles for title, head, and data respectively. \n\nThe createSheet method is responsible for creating a new sheet in the workbook. \n\nThe isNotEmpty method is a helper method used to check if a string is not empty.\"",
        "sketchy_description": "The public class DefaultSheetContext implements the SheetContext interface and is responsible for providing a context for a specific sheet within an Excel workbook. This context includes various configurations and parameters that are essential for managing and manipulating the sheet. The class is initialized through a constructor that takes in a WorkbookContext, an ExcelClassConfig, and a SheetParameter, setting up the necessary environment for sheet operations.\n\nThe class exposes several methods that allow users to interact with the sheet and its associated workbook. These methods include getters for retrieving the workbook context, Excel class configuration, sheet parameters, and the sheet itself. Additionally, there are methods to check for the presence of an input stream, get the merged region, calculate the maximum rowspan for a row, and retrieve or create the drawing patriarch for the sheet.\n\nFurthermore, the class provides functionality to get and set cell styles for titles, headers, and data within the workbook context. These methods are crucial for ensuring consistent formatting across the workbook. The class also includes utility methods for creating a new sheet and checking if a string is not empty or null, which are used internally to support the main functionalities.\n\nOverall, the DefaultSheetContext class serves as a comprehensive tool for managing the context of a sheet within an Excel workbook, providing a wide range of methods to access, modify, and maintain the sheet and its related components.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/context/defualts/DefaultSheetContext.java",
        "class_name": "DefaultSheetContext",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "DefaultSheetContextTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/context/defualts/DefaultSheetContextTest.java"
        },
        "task_id": 20,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.context.defualts;\n\nimport io.github.zouzhiy.excel.context.SheetContext;\nimport io.github.zouzhiy.excel.context.WorkbookContext;\nimport io.github.zouzhiy.excel.metadata.CellSpan;\nimport io.github.zouzhiy.excel.metadata.Configuration;\nimport io.github.zouzhiy.excel.metadata.MergedRegion;\nimport io.github.zouzhiy.excel.metadata.config.ExcelClassConfig;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport io.github.zouzhiy.excel.metadata.parameter.SheetParameter;\nimport io.github.zouzhiy.excel.metadata.result.CellStyleResultSet;\nimport org.apache.poi.ss.usermodel.*;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class DefaultSheetContext implements SheetContext {\n\n    private final WorkbookContext workbookContext;\n\n    private final ExcelClassConfig excelClassConfig;\n\n    private final SheetParameter sheetParameter;\n\n    private Sheet sheet;\n\n    private MergedRegion mergedRegion;\n\n    private Drawing<?> drawing;\n\n\n    public DefaultSheetContext(WorkbookContext workbookContext, ExcelClassConfig excelClassConfig, SheetParameter sheetParameter) {\n        this.workbookContext = workbookContext;\n        this.excelClassConfig = excelClassConfig;\n        this.sheetParameter = sheetParameter;\n    }\n\n    @Override\n    public WorkbookContext getWorkbookContext() {\n        return workbookContext;\n    }\n\n    @Override\n    public Configuration getConfiguration() {\n        return this.getWorkbookContext().getConfiguration();\n    }\n\n    @Override\n    public Workbook getWorkbook() {\n        return this.getWorkbookContext().getWorkbook();\n    }\n\n    @Override\n    public ExcelClassConfig getExcelClassConfig() {\n        return excelClassConfig;\n    }\n\n    @Override\n    public SheetParameter getSheetParameter() {\n        return sheetParameter;\n    }\n\n    @Override\n    public boolean hasInputStream() {\n        return this.workbookContext.getWorkbookParameter().getInputStream() != null;\n    }\n\n    @Override\n    public Sheet getSheet() {\n        Sheet sheet = this.sheet;\n        if (sheet != null) {\n            return sheet;\n        }\n\n        Workbook workbook = workbookContext.getWorkbook();\n        String sheetName = sheetParameter.getSheetName();\n        if (isNotEmpty(sheetName)) {\n            sheet = workbook.getSheet(sheetName);\n        }\n\n        Integer sheetIndex = sheetParameter.getSheetIndex();\n        int numberOfSheets = workbook.getNumberOfSheets();\n        if (sheet == null && sheetIndex != null && sheetIndex < numberOfSheets) {\n            sheet = workbook.getSheetAt(sheetIndex);\n        }\n\n        String title = sheetParameter.getTitle();\n        if (sheet == null && isNotEmpty(title)) {\n            sheet = workbook.getSheet(title);\n        }\n\n        if (sheet == null) {\n            sheet = createSheet(workbook);\n        }\n\n        this.sheet = sheet;\n\n        return sheet;\n    }\n\n\n    @Override\n    public MergedRegion getMergedRegion() {\n        if (mergedRegion == null) {\n            mergedRegion = new MergedRegion(this.getSheet().getMergedRegions());\n        }\n        return mergedRegion;\n    }\n\n\n    @Override\n    public int getMaxRowspan(int rowIndex) {\n        SheetParameter sheetParameter = this.getSheetParameter();\n        MergedRegion mergedRegion = this.getMergedRegion();\n        Sheet sheet = this.getSheet();\n        Row row = sheet.getRow(rowIndex);\n        if (row == null) {\n            return 1;\n        }\n        short lastCellNum = row.getLastCellNum();\n        int curColumnIndex = sheetParameter.getDataColumnStartIndex();\n\n        int maxRowspan = 1;\n        while (curColumnIndex < lastCellNum) {\n            CellSpan cellSpan = mergedRegion.getCellSpan(rowIndex, curColumnIndex);\n            curColumnIndex += cellSpan.getColspan();\n            maxRowspan = Math.max(maxRowspan, cellSpan.getRowspan());\n        }\n        return maxRowspan;\n    }\n\n    @Override\n    public Drawing<?> getDrawing() {\n        if (drawing == null) {\n            drawing = this.getSheet().createDrawingPatriarch();\n        }\n        return drawing;\n    }\n\n    @Override\n    public Row getRow(int rowIndex) {\n        return this.getSheet().getRow(rowIndex);\n    }\n\n    @Override\n    public List<Row> getRowList(int firstRowIndex, int lastRowIndex) {\n        List<Row> rowList = new ArrayList<>();\n        Sheet sheet = this.getSheet();\n        for (int i = firstRowIndex; i <= lastRowIndex; i++) {\n            Row row = sheet.getRow(i);\n            rowList.add(row);\n        }\n\n        return rowList;\n    }\n\n    @Override\n    public int getLasRowIndex() {\n        return this.getSheet().getLastRowNum();\n    }\n\n    @Override\n    public FormulaEvaluator getFormulaEvaluator() {\n        return workbookContext.getFormulaEvaluator();\n    }\n\n    @Override\n    public void putTitleCellStyle(ExcelClassConfig excelClassConfig, CellStyle cellStyle) {\n        workbookContext.putTitleCellStyle(excelClassConfig, cellStyle);\n    }\n\n    @Override\n    public void putHeadCellStyle(CellStyleResultSet headCellStyleResultSet) {\n        workbookContext.putHeadCellStyle(headCellStyleResultSet);\n    }\n\n    @Override\n    public void putDataCellStyle(CellStyleResultSet dataCellStyleResultSet) {\n        workbookContext.putDataCellStyle(dataCellStyleResultSet);\n    }\n\n    @Override\n    public CellStyle getTitleCellStyle(ExcelClassConfig excelClassConfig) {\n        return workbookContext.getTitleCellStyle(excelClassConfig);\n    }\n\n    @Override\n    public CellStyle getHeadCellStyle(ExcelFieldConfig excelFieldConfig) {\n        return workbookContext.getHeadCellStyle(excelFieldConfig);\n    }\n\n    @Override\n    public CellStyle getDataCellStyle(ExcelFieldConfig excelFieldConfig, String defaultDataFormat) {\n        return workbookContext.getDataCellStyle(excelFieldConfig, defaultDataFormat);\n    }\n\n    private Sheet createSheet(Workbook workbook) {\n        String realSheetName = null;\n        String sheetName = sheetParameter.getSheetName();\n        if (isNotEmpty(sheetName)) {\n            realSheetName = sheetName;\n        }\n        String title = sheetParameter.getTitle();\n        if (realSheetName == null && isNotEmpty(title)) {\n            realSheetName = title;\n        }\n\n        Integer sheetIndex = sheetParameter.getSheetIndex();\n        if (realSheetName == null && sheetIndex != null) {\n            realSheetName = \"Sheet\" + (sheetIndex + 1);\n        }\n        if (realSheetName == null) {\n            int numberOfSheets = workbook.getNumberOfSheets();\n            realSheetName = \"Sheet\" + (numberOfSheets + 1);\n            while (workbook.getSheet(realSheetName) != null) {\n                numberOfSheets += 1;\n                realSheetName = \"Sheet\" + (numberOfSheets + 1);\n            }\n        }\n\n        return workbook.createSheet(realSheetName);\n    }\n\n    private boolean isNotEmpty(String str) {\n        return str != null && str.trim().length() != 0;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class BigDecimalBooleanHandler is a subclass of the AbstractBigDecimalCellHandler class. This class is designed to handle cells in an Excel spreadsheet that contain BigDecimal values and convert them into Boolean values. The class contains a private static final variable TRUE_VALUE, which is set to BigDecimal.ONE. This variable represents the BigDecimal equivalent of a Boolean true value. \n\nThe class overrides two methods from its superclass. The first method, setCellValue, takes four parameters: a RowContext object, an ExcelFieldConfig object, a Cell object, and a BigDecimal value. This method sets the value of the cell to true if the BigDecimal value is equal to TRUE_VALUE (i.e., BigDecimal.ONE), and false otherwise. This is done by comparing the BigDecimal value to TRUE_VALUE using the compareTo method and checking if the result is 0 (which indicates that the two values are equal). \n\nThe second method that is overridden is getExcelType. This method does not take any parameters and returns an ExcelType enumeration value. Specifically, it returns ExcelType.BOOLEAN, indicating that this handler is used for cells that are intended to contain Boolean values.\"",
        "sketchy_description": "The public class BigDecimalBooleanHandler, which extends the AbstractBigDecimalCellHandler, is specialized in handling the conversion of BigDecimal values to boolean values within Excel cells. This is particularly useful when dealing with data that needs to be represented as boolean (true/false) in Excel spreadsheets. The class defines a constant TRUE_VALUE which is set to BigDecimal.ONE, and this value is used as a reference to determine the boolean state.\n\nThe protected method setCellValue takes multiple parameters including a RowContext, an ExcelFieldConfig, a Cell, and a BigDecimal value. Its primary function is to set the cell's value within an Excel sheet. If the BigDecimal value passed to this method is equal to the predefined TRUE_VALUE, the cell's value is set to true; otherwise, it is set to false. This method ensures that BigDecimal values are appropriately translated to their boolean counterparts when populating Excel cells.\n\nAdditionally, the public method getExcelType returns the enum ExcelType.BOOLEAN. This indicates that the handler is specifically dealing with boolean values in Excel. This information can be used by other components of the system to ensure that the data is processed and formatted correctly when generating or manipulating Excel documents.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/bigdecimal/BigDecimalBooleanHandler.java",
        "class_name": "BigDecimalBooleanHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "BigDecimalBooleanHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/BigDecimalBooleanHandlerTest.java"
        },
        "task_id": 21,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.bigdecimal;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport org.apache.poi.ss.usermodel.Cell;\n\nimport java.math.BigDecimal;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class BigDecimalBooleanHandler extends AbstractBigDecimalCellHandler {\n\n    private final static BigDecimal TRUE_VALUE = BigDecimal.ONE;\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, BigDecimal value) {\n        cell.setCellValue(value.compareTo(TRUE_VALUE) == 0);\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.BOOLEAN;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class LocalDateStringHandler is a specialized class that extends the AbstractLocalDateCellHandler class. This class is designed to handle the conversion of LocalDate objects to string format for use in Excel cells. \n\nThe getExcelType method is overridden from the parent class and returns the ExcelType.STRING, indicating that this handler is used for string data types in Excel. \n\nThe getDefaultJavaFormat method is also overridden and returns a string representing the default date format (\"yyyy-MM-dd\") that this handler uses to format LocalDate objects. \n\nThe setCellValue method is a protected method that is also overridden from the parent class. This method is responsible for setting the value of a cell in an Excel row. It takes four arguments: a RowContext object that represents the current row, an ExcelFieldConfig object that contains configuration information for the Excel field, a Cell object that represents the cell to be set, and a LocalDate object that represents the value to be set. \n\nInside the setCellValue method, the getJavaFormat method is called to get the Java date format string from the ExcelFieldConfig object. The ExcelDateFormatUtils.format method is then used to format the LocalDate value into a string using the obtained date format. Finally, the setCellValue method of the Cell object is called to set the cell's value to the formatted string.\"",
        "sketchy_description": "The public class LocalDateStringHandler, which extends the AbstractLocalDateCellHandler, is specifically designed to manage the conversion process between LocalDate objects and their String representations within Excel cells. This class overrides several methods to provide functionality tailored to handling LocalDate types in the context of Excel spreadsheets.\n\nThe getExcelType method, which is overridden, returns the ExcelType.STRING, indicating that this handler deals with string representations of data in Excel. This is particularly important for ensuring that LocalDate values are correctly interpreted as text within the spreadsheet.\n\nThe getDefaultJavaFormat method, also overridden, provides the default formatting pattern for LocalDate objects, which is \"yyyy-MM-dd\". This standard format is widely used for representing dates in a clear and unambiguous way, which is essential for consistency and ease of understanding when viewing dates in Excel cells.\n\nLastly, the setCellValue method is a protected method that is overridden to perform the actual conversion of a LocalDate value to a String and then set that value into a cell within an Excel sheet. It takes into account the RowContext, ExcelFieldConfig, and the Cell to which the value is to be set, along with the LocalDate value itself. The method ensures that the date is formatted according to the specified Java format before being placed into the cell, allowing for a seamless transition of date information from a Java application to an Excel document.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/localdate/LocalDateStringHandler.java",
        "class_name": "LocalDateStringHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "LocalDateStringHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/LocalDateStringHandlerTest.java"
        },
        "task_id": 22,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.localdate;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport io.github.zouzhiy.excel.utils.ExcelDateFormatUtils;\nimport org.apache.poi.ss.usermodel.Cell;\n\nimport java.time.LocalDate;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class LocalDateStringHandler extends AbstractLocalDateCellHandler {\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.STRING;\n    }\n\n    @Override\n    public String getDefaultJavaFormat() {\n        return \"yyyy-MM-dd\";\n    }\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, LocalDate value) {\n        String javaFormat = this.getJavaFormat(excelFieldConfig);\n        String strValue = ExcelDateFormatUtils.format(value, javaFormat);\n        cell.setCellValue(strValue);\n    }\n}\n"
    },
    {
        "detailed_description": "The public class BigDecimalNumberHandler is a subclass of the AbstractBigDecimalCellHandler class. This class is designed to handle operations related to cells in an Excel spreadsheet that contain BigDecimal numbers. BigDecimal is a class in Java that provides operations for arithmetic, scale manipulation, rounding, comparison, hashing, and format conversion. \n\nThe BigDecimalNumberHandler class overrides two methods from its superclass. The first method, setCellValue, is responsible for setting the value of a cell in a row. It takes four parameters: a RowContext object that represents the context of the row in the spreadsheet, an ExcelFieldConfig object that contains configuration details for the Excel field, a Cell object that represents the cell in the spreadsheet, and a BigDecimal value that is the value to be set in the cell. The method converts the BigDecimal value to a double and sets it as the value of the cell.\n\nThe second method that is overridden is getExcelType. This method does not take any parameters and returns an ExcelType enumeration. In this case, the method returns ExcelType.NUMERIC, indicating that the type of Excel cell that this handler deals with is numeric.\"",
        "sketchy_description": "The public class BigDecimalNumberHandler, which extends AbstractBigDecimalCellHandler, is designed to handle the insertion of BigDecimal values into cells within an Excel spreadsheet. This functionality is crucial for ensuring that numerical data is accurately represented when working with financial or scientific data that requires a high degree of precision.\n\nThe class provides a protected method setCellValue, which takes a RowContext, an ExcelFieldConfig, a Cell, and a BigDecimal as parameters. This method is responsible for setting the value of a specific cell in an Excel sheet to the double representation of the provided BigDecimal value. This conversion is necessary because Excel cells do not natively support the BigDecimal data type, so the value must be converted to a double before it can be inserted into the cell.\n\nAdditionally, the class offers a public method getExcelType, which returns an ExcelType enumeration value that corresponds to the numeric type. This method is useful for determining the type of data that is being handled by the BigDecimalNumberHandler, particularly when interfacing with Excel's data typing system.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/bigdecimal/BigDecimalNumberHandler.java",
        "class_name": "BigDecimalNumberHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "BigDecimalNumberHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/BigDecimalNumberHandlerTest.java"
        },
        "task_id": 23,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.bigdecimal;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport org.apache.poi.ss.usermodel.Cell;\n\nimport java.math.BigDecimal;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class BigDecimalNumberHandler extends AbstractBigDecimalCellHandler {\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, BigDecimal value) {\n        cell.setCellValue(value.doubleValue());\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.NUMERIC;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class KeySerDe is designed to handle serialization and deserialization of keys. It contains two private static final variables, NULL_STRING_MARKER and NULL_BYTE_ARRAY_MARKER, which are used to represent null values for strings and byte arrays respectively. \n\nThe class also contains two private final variables, rowKeyTypes and numRowKeysInSchema. rowKeyTypes is a list of PrimitiveType objects that represent the types of the row keys, and numRowKeysInSchema is an integer that represents the number of row keys in the schema.\n\nThe class has two constructors. The first constructor takes a Schema object as an argument, retrieves the row key types from the schema, and assigns the size of the row key types list to numRowKeysInSchema. The second constructor takes a list of PrimitiveType objects as an argument, assigns a new ArrayList to rowKeyTypes, adds all elements from the argument list to rowKeyTypes, and assigns the size of rowKeyTypes to numRowKeysInSchema.\n\nThe class provides two public methods, serialise and deserialise. The serialise method takes a Key object as an argument and returns a byte array. It writes the number of keys to serialise to a DataOutputStream object, then writes each key to the stream according to its type. If a key is null, it writes a boolean value of true and a marker to represent the null value. If a key is not null, it writes a boolean value of false and the key itself. The deserialise method takes a byte array as an argument and returns a Key object. It reads the number of serialised keys from a DataInputStream object, then reads each key from the stream according to its type. If a key is represented by a null marker, it adds null to the key list. If a key is not represented by a null marker, it adds the key itself to the key list. After all keys have been read, it creates a new Key object from the key list and returns it.\"",
        "sketchy_description": "The public class KeySerDe is responsible for the serialization and deserialization of keys, which is a process of converting data into a byte stream for storage, transfer, and reconstruction later on. This class is particularly designed to work with keys that are based on a predefined schema, ensuring that the keys are handled consistently according to the specified format.\n\nThe class constructor takes either a Schema object or a list of PrimitiveType objects representing the row key types. When a Schema object is provided, the constructor extracts the necessary information about the row key types and the number of row keys present in the schema. Alternatively, when a list of PrimitiveType objects is provided, the constructor sets up the internal structures that will be used for the serialization and deserialization processes.\n\nThe KeySerDe class provides two main methods for working with Key objects. The serialise method takes a Key object and converts it into a byte array. This method is capable of handling various data types and also accounts for null values, which are represented by predefined markers. The deserialise method performs the opposite operation; it takes a byte array and reconstructs a Key object from it. Similar to the serialise method, it handles various data types and null values, ensuring that the original Key object can be accurately reconstructed from its serialized form.\n\nBoth methods throw an IOException, which indicates that input/output operations may fail, and such failures need to be handled by the calling code. This is a common pattern in Java for methods that deal with data serialization and deserialization, as these operations are often subject to external factors that can cause errors, such as file system issues or network problems.",
        "file": "sleeper/java/core/src/main/java/sleeper/core/key/KeySerDe.java",
        "class_name": "KeySerDe",
        "repo_metadata": {
            "repo_name": "sleeper"
        },
        "evaluation_metadata": {
            "test_class_name": "KeySerDeTest",
            "test_file": "sleeper/java/core/src/test/java/sleeper/core/key/KeySerDeTest.java"
        },
        "task_id": 24,
        "ground_truth_class_body": "/*\n * Copyright 2022-2023 Crown Copyright\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage sleeper.core.key;\n\nimport sleeper.core.schema.Schema;\nimport sleeper.core.schema.type.ByteArrayType;\nimport sleeper.core.schema.type.IntType;\nimport sleeper.core.schema.type.LongType;\nimport sleeper.core.schema.type.PrimitiveType;\nimport sleeper.core.schema.type.StringType;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * Serialises key. Fewer key than there are row key in the schema may be\n * serialised, but they must be in the same order as in the schema, e.g. if\n * the row key types in the schema are int, string, then (5, \"A\") can be\n * serialised, as can (5), but (\"A\") cannot be serialised.\n */\npublic class KeySerDe {\n    private static final String NULL_STRING_MARKER = \"SLEEPER-NULL-STRING\";\n    private static final byte[] NULL_BYTE_ARRAY_MARKER = \"SLEEPER-NULL-BYTE-ARRAY\".getBytes(Charset.forName(\"UTF-8\"));\n\n    private final List<PrimitiveType> rowKeyTypes;\n    private final int numRowKeysInSchema;\n\n    public KeySerDe(Schema schema) {\n        this.rowKeyTypes = schema.getRowKeyTypes();\n        this.numRowKeysInSchema = this.rowKeyTypes.size();\n    }\n\n    public KeySerDe(List<PrimitiveType> rowKeyTypes) {\n        this.rowKeyTypes = new ArrayList<>();\n        this.rowKeyTypes.addAll(rowKeyTypes);\n        this.numRowKeysInSchema = this.rowKeyTypes.size();\n    }\n\n    public byte[] serialise(Key key) throws IOException {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        DataOutputStream dos = new DataOutputStream(baos);\n        int numKeys = key.size();\n        int numKeysToSerialise = Math.min(numKeys, numRowKeysInSchema);\n        dos.writeInt(numKeysToSerialise);\n        for (int i = 0; i < numKeysToSerialise; i++) {\n            PrimitiveType type = rowKeyTypes.get(i);\n            if (type instanceof IntType) {\n                if (null == key.get(i)) {\n                    // A partition can have a maximum value of null to indicate\n                    // that any int is less than it (the partition consisting\n                    // of all integers needs to have null as the max because\n                    // the max of a partition is not contained within the\n                    // partition and the root partition for an int key needs\n                    // to contain all ints, hence we cannot use Integer.MAX_VALUE\n                    // as the maximum).\n                    dos.writeBoolean(true);\n                } else {\n                    dos.writeBoolean(false);\n                    dos.writeInt((int) key.get(i));\n                }\n            } else if (type instanceof LongType) {\n                if (null == key.get(i)) {\n                    dos.writeBoolean(true);\n                } else {\n                    dos.writeBoolean(false);\n                    dos.writeLong((long) key.get(i));\n                }\n            } else if (type instanceof StringType) {\n                if (null == key.get(i)) {\n                    dos.writeUTF(NULL_STRING_MARKER);\n                } else {\n                    dos.writeUTF((String) key.get(i));\n                }\n            } else if (type instanceof ByteArrayType) {\n                byte[] bytes;\n                if (null == key.get(i)) {\n                    bytes = NULL_BYTE_ARRAY_MARKER;\n                } else {\n                    bytes = (byte[]) key.get(i);\n                }\n                dos.writeInt(bytes.length);\n                dos.write(bytes);\n            } else {\n                throw new IllegalArgumentException(\"Unknown type \" + type);\n            }\n        }\n        dos.close();\n        return baos.toByteArray();\n    }\n\n    public Key deserialise(byte[] bytes) throws IOException {\n        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n        DataInputStream dis = new DataInputStream(bais);\n        int numSerialisedKeys = dis.readInt();\n        List<Object> key = new ArrayList<>();\n        for (int i = 0; i < numSerialisedKeys; i++) {\n            PrimitiveType type = rowKeyTypes.get(i);\n            if (type instanceof IntType) {\n                if (dis.readBoolean()) {\n                    key.add(null);\n                } else {\n                    key.add(dis.readInt());\n                }\n            } else if (type instanceof LongType) {\n                if (dis.readBoolean()) {\n                    key.add(null);\n                } else {\n                    key.add(dis.readLong());\n                }\n            } else if (type instanceof StringType) {\n                String s = dis.readUTF();\n                if (NULL_STRING_MARKER.equals(s)) {\n                    key.add(null);\n                } else {\n                    key.add(s);\n                }\n            } else if (type instanceof ByteArrayType) {\n                int length = dis.readInt();\n                byte[] byteArray = new byte[length];\n                dis.readFully(byteArray);\n                if (Arrays.equals(NULL_BYTE_ARRAY_MARKER, byteArray)) {\n                    key.add(null);\n                } else {\n                    key.add(byteArray);\n                }\n            } else {\n                throw new IllegalArgumentException(\"Unknown type \" + type);\n            }\n        }\n        dis.close();\n        return Key.create(key);\n    }\n}\n"
    },
    {
        "detailed_description": "The public class SleeperPartitioner extends the Partitioner class. This class is designed to partition data into different segments or sections. It has a unique serial version ID for serialization and deserialization purposes. \n\nThe class has several private members. The 'broadcastPartitions' member is a broadcast variable that can be used to share a read-only variable cached on each machine rather than sending a copy of it with tasks. The 'schemaAsString' member is a string representation of the schema. The 'numRowKeyFields', 'partitionTree', 'numLeafPartitions', and 'partitionIdToInt' members are transient, meaning they are not serialized.\n\nThe constructor for this class takes two arguments: a string representation of the schema and a broadcast variable of a list of partitions. It initializes the 'schemaAsString' and 'broadcastPartitions' members with these values.\n\nThe 'init' method is a private method that initializes the 'numRowKeyFields', 'partitionTree', 'numLeafPartitions', and 'partitionIdToInt' members. It first deserializes the schema from the 'schemaAsString' member, then gets the list of partitions from the 'broadcastPartitions' member and builds a partition tree from them. It also counts the number of leaf partitions and maps each partition ID to an integer.\n\nThe 'numPartitions' method overrides the method from the Partitioner class. It returns the number of leaf partitions. If the 'partitionTree' member is null, it calls the 'init' method to initialize it.\n\nThe 'getPartition' method also overrides the method from the Partitioner class. It takes an object as an argument and returns the integer corresponding to the partition ID of the leaf partition that the object belongs to. If the 'partitionTree' member is null, it calls the 'init' method to initialize it. It first creates a list of row keys from the object, then gets the leaf partition of the row key from the 'partitionTree' member and returns the corresponding integer from the 'partitionIdToInt' member.\"",
        "sketchy_description": "The public class SleeperPartitioner, which extends the Partitioner class, is designed to provide a custom strategy for distributing data across different partitions. This is particularly useful in distributed computing environments where data needs to be evenly distributed to optimize parallel processing. The class includes a unique identifier (serialVersionUID) for serialization purposes, a broadcast variable containing a list of partitions, a string representation of the schema, and several transient variables for internal bookkeeping.\n\nThe constructor of the SleeperPartitioner class takes a string representing the schema and a broadcast variable containing a list of partitions. It is responsible for initializing the partitioner with these parameters, setting up the necessary structures for the partitioning logic.\n\nThe init method is a private method that initializes internal structures such as the partition tree and mappings based on the provided schema and broadcast partitions. This method is crucial for setting up the partitioning logic that will be used to determine the appropriate partition for each data element.\n\nThe numPartitions method is a public method that returns the number of leaf partitions, which represent the final level of partitioning. If the internal structures have not been initialized, this method will trigger the initialization process before returning the count.\n\nFinally, the getPartition method is responsible for determining the appropriate partition index for a given key. This method also ensures that the internal structures are initialized before performing the partitioning logic. The partition index is used to assign each data element to a specific partition, which is a critical step in the data distribution process.",
        "file": "sleeper/java/bulk-import/bulk-import-runner/src/main/java/sleeper/bulkimport/job/runner/rdd/SleeperPartitioner.java",
        "class_name": "SleeperPartitioner",
        "repo_metadata": {
            "repo_name": "sleeper"
        },
        "evaluation_metadata": {
            "test_class_name": "SleeperPartitionerTest",
            "test_file": "sleeper/java/bulk-import/bulk-import-runner/src/test/java/sleeper/bulkimport/job/runner/rdd/SleeperPartitionerTest.java"
        },
        "task_id": 25,
        "ground_truth_class_body": "/*\n * Copyright 2022-2023 Crown Copyright\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage sleeper.bulkimport.job.runner.rdd;\n\nimport org.apache.spark.Partitioner;\nimport org.apache.spark.broadcast.Broadcast;\n\nimport sleeper.core.key.Key;\nimport sleeper.core.partition.Partition;\nimport sleeper.core.partition.PartitionTree;\nimport sleeper.core.schema.Schema;\nimport sleeper.core.schema.SchemaSerDe;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport java.util.stream.Collectors;\n\n/**\n * A {@link SleeperPartitioner} is a custom {@link Partitioner} which uses the\n * Sleeper partitions to split the data into different partitions.\n */\npublic class SleeperPartitioner extends Partitioner {\n    private static final long serialVersionUID = -4686777638868174263L;\n\n    private final Broadcast<List<Partition>> broadcastPartitions;\n    private final String schemaAsString;\n    private transient int numRowKeyFields;\n    private transient PartitionTree partitionTree;\n    private transient int numLeafPartitions;\n    private transient Map<String, Integer> partitionIdToInt;\n\n    public SleeperPartitioner(String schemaAsString, Broadcast<List<Partition>> broadcastPartitions) {\n        this.schemaAsString = schemaAsString;\n        this.broadcastPartitions = broadcastPartitions;\n    }\n\n    private void init() {\n        Schema schema = new SchemaSerDe().fromJson(schemaAsString);\n        numRowKeyFields = schema.getRowKeyFields().size();\n        List<Partition> partitions = broadcastPartitions.getValue();\n        partitionTree = new PartitionTree(schema, partitions);\n        numLeafPartitions = (int) partitions.stream().filter(Partition::isLeafPartition).count();\n        partitionIdToInt = new HashMap<>();\n        List<String> leafPartitions = partitions.stream()\n                .filter(Partition::isLeafPartition)\n                .map(p -> p.getId())\n                .collect(Collectors.toList());\n        SortedSet<String> sortedPartitionIds = new TreeSet<>(leafPartitions);\n        int i = 0;\n        for (String partitionId : sortedPartitionIds) {\n            partitionIdToInt.put(partitionId, i);\n            i++;\n        }\n    }\n\n    @Override\n    public int numPartitions() {\n        if (null == partitionTree) {\n            init();\n        }\n        return numLeafPartitions;\n    }\n\n    @Override\n    public int getPartition(Object obj) {\n        if (null == partitionTree) {\n            init();\n        }\n        Key key = (Key) obj;\n        List<Object> rowKeys = new ArrayList<>(numRowKeyFields);\n        for (int i = 0; i < numRowKeyFields; i++) {\n            rowKeys.add(key.get(i));\n        }\n        Key rowKey = Key.create(rowKeys);\n        String partitionId = partitionTree.getLeafPartition(rowKey).getId();\n        int partitionAsInt = partitionIdToInt.get(partitionId);\n        return partitionAsInt;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class DateStringHandler is a specialized class that extends the AbstractDateCellHandler class. This class is designed to handle date strings in Excel cells. It overrides three methods from the AbstractDateCellHandler class. \n\nThe getExcelType method is overridden to return ExcelType.STRING, indicating that this handler is designed to work with string representations of dates in Excel. \n\nThe getDefaultJavaFormat method is overridden to return a string representing the default date format in Java, which is \"yyyy-MM-dd HH:mm:ss\". This format is used when converting date objects to strings. \n\nThe setCellValue method is overridden to set the value of a cell in an Excel row. This method takes four arguments: a RowContext object representing the current row, an ExcelFieldConfig object representing the configuration of the Excel field, a Cell object representing the cell to be set, and a Date object representing the value to be set. The method first retrieves the Java format for the date from the ExcelFieldConfig object, then formats the Date object into a string using this format. Finally, it sets the value of the cell to this string.\"",
        "sketchy_description": "The public class DateStringHandler, which extends the AbstractDateCellHandler, is specialized in the conversion of Date objects into their String representations suitable for display in Excel cells. This class overrides several methods from its parent class to provide functionality specific to handling dates as strings within Excel.\n\nThe getExcelType method, which is overridden, returns the ExcelType.STRING, indicating that this handler deals with date values as strings within Excel. This is important for ensuring that dates are represented in a text format that can be correctly displayed and understood in the context of an Excel spreadsheet.\n\nThe getDefaultJavaFormat method, also overridden, provides the default Java date format string \"yyyy-MM-dd HH:mm:ss\". This format is commonly used for representing dates and times in a standard and easily readable form. By providing this default format, the handler ensures consistency in how dates are formatted across different cells and spreadsheets.\n\nThe setCellValue method is a protected method that is overridden to take a RowContext, an ExcelFieldConfig, a Cell, and a Date value as parameters. This method is responsible for setting the cell's value to a formatted date string. It uses the provided Java format and the Date value to create a string representation of the date, which is then set as the value of the cell. This allows for the dynamic formatting of date values based on the configuration provided, ensuring that dates are displayed in a user-friendly manner within the Excel cells.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/date/DateStringHandler.java",
        "class_name": "DateStringHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "DateStringHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/DateStringHandlerTest.java"
        },
        "task_id": 26,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.date;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport io.github.zouzhiy.excel.utils.ExcelDateFormatUtils;\nimport org.apache.poi.ss.usermodel.Cell;\n\nimport java.util.Date;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class DateStringHandler extends AbstractDateCellHandler {\n\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.STRING;\n    }\n\n    @Override\n    public String getDefaultJavaFormat() {\n        return \"yyyy-MM-dd HH:mm:ss\";\n    }\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, Date value) {\n        String javaFormat = this.getJavaFormat(excelFieldConfig);\n        String strValue = ExcelDateFormatUtils.format(value, javaFormat);\n        cell.setCellValue(strValue);\n    }\n}\n"
    },
    {
        "detailed_description": "The public class StringBooleanHandler is a specialized class that extends the AbstractStringCellHandler class. This class is designed to handle boolean values represented as strings in Excel cells. It overrides two methods from the parent class. The first method, setCellValue, takes four parameters: a RowContext object, an ExcelFieldConfig object, a Cell object, and a String value. This method is responsible for setting the value of the cell to the boolean representation of the provided string value. The second method, getExcelType, returns the ExcelType of the cell, which in this case is BOOLEAN. This class is useful for handling boolean data in Excel spreadsheets, particularly when the data is represented as strings.\"",
        "sketchy_description": "The public class StringBooleanHandler, which extends the AbstractStringCellHandler, is designed to handle the conversion of string values to boolean values specifically within the context of Excel cells. This functionality is particularly useful when dealing with Excel spreadsheets that require data to be converted from text to a boolean format for further processing or analysis.\n\nThe class provides a protected method setCellValue, which takes a RowContext, an ExcelFieldConfig, a Cell, and a String value as parameters. This method is responsible for interpreting the string value and setting the corresponding cell in the Excel spreadsheet to the boolean representation of that string. This conversion process is essential for maintaining data integrity when manipulating Excel files programmatically.\n\nAdditionally, the class offers a public method getExcelType, which returns an ExcelType enum value that signifies the type of data the handler deals with. In this case, the method indicates that the handler is associated with BOOLEAN types, which is consistent with its purpose of converting strings to boolean values within Excel cells. This method helps in identifying the nature of the data processing performed by the handler and can be used to ensure that the handler is used in the correct context within a larger data processing framework.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/string/StringBooleanHandler.java",
        "class_name": "StringBooleanHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "StringBooleanHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/StringBooleanHandlerTest.java"
        },
        "task_id": 27,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.string;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport org.apache.poi.ss.usermodel.Cell;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class StringBooleanHandler extends AbstractStringCellHandler {\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, String value) {\n        cell.setCellValue(Boolean.parseBoolean(value));\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.BOOLEAN;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class ListStringStringSplitHandler is a specialized class that extends the AbstractListSplitHandler class with a generic type of String. This class is designed to handle the splitting of lists of strings in a specific way. The class overrides the getExcelType method from the AbstractListSplitHandler class. This method is designed to return the type of Excel data that the class is designed to handle, which in this case is ExcelType.STRING. This indicates that the ListStringStringSplitHandler class is specifically designed to handle lists of strings that are represented in Excel as strings.\"",
        "sketchy_description": "The public class ListStringStringSplitHandler, which extends the AbstractListSplitHandler with a generic type of String, is specifically tailored for handling the splitting of lists that contain String elements. This functionality is particularly useful when processing data for Excel, where different types of data may need to be handled differently. The class overrides a method from its superclass, getExcelType, which is used to specify the type of Excel data that the String elements correspond to. In this case, the method returns ExcelType.STRING, indicating that the elements in the list should be treated as strings within the context of Excel processing. This method is crucial for ensuring that the data is correctly interpreted and managed when being imported into or exported from Excel spreadsheets.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/list/ListStringStringSplitHandler.java",
        "class_name": "ListStringStringSplitHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "ListStringStringSplitHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/ListStringStringSplitHandlerTest.java"
        },
        "task_id": 28,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.list;\n\nimport io.github.zouzhiy.excel.enums.ExcelType;\n\n/**\n * @author zouzhiy\n * @since 2022/7/4\n */\npublic class ListStringStringSplitHandler extends AbstractListSplitHandler<String> {\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.STRING;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class FileGifSource is a subclass of the AbstractGifSource class, with File as its generic type. This class is designed to handle GIF files as its source. The constructor for this class takes a File object as an argument and passes it to the superclass constructor. The class overrides the doLoad method from the AbstractGifSource class. This method is designed to load the GIF file into the decoder. It does this by creating a new FileInputStream from the source file and passing it to the read method of the decoder. The method returns an integer value, which is the result of the read operation. This method can throw an IOException, which must be handled by the calling code.\"",
        "sketchy_description": "The public class FileGifSource, which extends the AbstractGifSource class with a generic type of File, is designed to handle the loading of GIF data from a file-based source. The class is specialized for working with files and provides the necessary functionality to read and decode GIF data from the file system.\n\nThe constructor of the FileGifSource class takes a single argument of type File, which represents the file source from which the GIF data will be loaded. When a new instance of FileGifSource is created, it is initialized with this file source, setting up the object to perform its operations on the specified file.\n\nThe class includes a protected method named doLoad, which is responsible for the actual loading process. This method reads the GIF data from the file source and decodes it, returning an integer result that indicates the outcome of the decoding process. The doLoad method is marked as protected, meaning it is intended to be accessed within the class itself and by subclasses, and it throws an IOException to signal any issues that may occur during the file reading and decoding operations. This method is a key part of the class's functionality, enabling users to retrieve GIF data from a file for further use in their applications.",
        "file": "imglib/pipe/src/main/java/cn/pipe/in/gif/FileGifSource.java",
        "class_name": "FileGifSource",
        "repo_metadata": {
            "repo_name": "imglib"
        },
        "evaluation_metadata": {
            "test_class_name": "FileGifSourceTest",
            "test_file": "imglib/pipe/src/test/java/cn/pipe/in/gif/FileGifSourceTest.java"
        },
        "task_id": 29,
        "ground_truth_class_body": "package cn.pipe.in.gif;\n\nimport cn.pipe.in.AbstractGifSource;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\n/**\n * A gif source that from file.\n *\n * @author tracy\n * @since 0.2.1\n */\npublic class FileGifSource extends AbstractGifSource<File> {\n\n    public FileGifSource(File source) {\n        super(source);\n    }\n\n    @Override\n    protected int doLoad() throws IOException {\n        return decoder.read(new FileInputStream(source));\n    }\n}\n"
    },
    {
        "detailed_description": "The class RequestBuilder is designed to build HTTP requests. It has a private constructor, which means objects of this class cannot be instantiated. Instead, it provides static methods to build different types of HTTP requests. \n\nThe class has a private static final variable JSON_TYPE of type MediaType, which is set to \"application/json; charset=utf-8\". This variable is used to set the media type of the request body in POST and PUT requests.\n\nThe buildPublicRequest method is a public static method that takes a URL and an HTTP method (POST, GET, PUT, DELETE) as parameters. It builds a Request object based on the provided HTTP method. For POST and PUT methods, it sets the request body to an empty string with the media type as JSON. For GET and DELETE methods, it adds a header \"Content-Type\" with the value \"application/x-www-form-urlencoded\". If an invalid HTTP method is provided, it throws a BinanceConnectorException.\n\nThe buildApiKeyRequest method is similar to buildPublicRequest, but it also takes an API key as a parameter. This method adds an additional header \"X-MBX-APIKEY\" with the value of the provided API key to the request.\n\nThe buildWebsocketRequest method is a public static method that takes a URL as a parameter and builds a Request object with the provided URL.\n\nAll methods throw a BinanceConnectorException if an invalid URL is provided.\"",
        "sketchy_description": "The class RequestBuilder is a utility class specifically designed for the purpose of constructing various types of HTTP requests. It is not meant to be instantiated, as indicated by its private constructor, and thus serves as a static utility with methods that can be called without creating an instance of the class.\n\nThe class contains a static final variable named JSON_TYPE, which holds a MediaType object representing the MIME type for JSON with a UTF-8 character set. This variable is likely used internally to set the content type of requests that involve JSON data.\n\nThe class provides several static methods for building HTTP requests:\n\n1. The buildPublicRequest method takes a full URL and an HttpMethod as parameters and returns a Request object. This method is capable of creating requests for common HTTP methods such as GET, POST, PUT, and DELETE. It is termed 'public' to indicate that it does not require any form of authentication.\n\n2. The buildApiKeyRequest method is similar to buildPublicRequest but includes an additional parameter for an API key. This method constructs an HTTP request that includes the provided API key for authentication purposes, making it suitable for endpoints that require an API key for access.\n\n3. The buildWebsocketRequest method is designed to create a simple request that can be used to initiate a WebSocket connection. It only requires the full URL of the WebSocket server as a parameter.\n\nThese methods provide a convenient way to create HTTP requests without having to manually set up the request details, streamlining the process of interacting with web services and APIs.",
        "file": "binance-futures-connector-java/src/main/java/com/binance/connector/futures/client/utils/RequestBuilder.java",
        "class_name": "RequestBuilder",
        "repo_metadata": {
            "repo_name": "binance-futures-connector-java"
        },
        "evaluation_metadata": {
            "test_class_name": "TestRequestBuilder",
            "test_file": "binance-futures-connector-java/src/test/java/unit/TestRequestBuilder.java"
        },
        "task_id": 30,
        "ground_truth_class_body": "package com.binance.connector.futures.client.utils;\n\nimport com.binance.connector.futures.client.enums.HttpMethod;\nimport com.binance.connector.futures.client.exceptions.BinanceConnectorException;\nimport okhttp3.MediaType;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\n\npublic final class RequestBuilder {\n    private static final MediaType JSON_TYPE = MediaType.parse(\"application/json; charset=utf-8\");\n\n    private RequestBuilder() {\n    }\n    public static Request buildPublicRequest(String fullUrl, HttpMethod httpMethod) {\n        try {\n            final Request request;\n            switch (httpMethod) {\n                case POST:\n                    request = new Request.Builder().url(fullUrl)\n                            .post(RequestBody.create(\"\", JSON_TYPE))\n                            .build();\n                    break;\n                case GET:\n                    request = new Request.Builder().url(fullUrl)\n                            .get()\n                            .addHeader(\"Content-Type\", \"application/x-www-form-urlencoded\")\n                            .build();\n                    break;\n                case PUT:\n                    request = new Request.Builder().url(fullUrl)\n                            .put(RequestBody.create(\"\", JSON_TYPE))\n                            .addHeader(\"Content-Type\", \"application/x-www-form-urlencoded\")\n                            .build();\n                    break;\n                case DELETE:\n                    request = new Request.Builder().url(fullUrl)\n                            .delete()\n                            .addHeader(\"Content-Type\", \"application/x-www-form-urlencoded\")\n                            .build();\n                    break;\n                default:\n                    throw new BinanceConnectorException(\"Invalid HTTP method: \" + httpMethod);\n            }\n            return request;\n        } catch (IllegalArgumentException e) {\n            throw new BinanceConnectorException(\"Invalid URL: \" + e.getMessage());\n        }\n     }\n\n    public static Request buildApiKeyRequest(String fullUrl, HttpMethod httpMethod, String apiKey) {\n        try {\n            final Request request;\n            switch (httpMethod) {\n                case POST:\n                    request = new Request.Builder().url(fullUrl)\n                            .post(RequestBody.create(\"\", JSON_TYPE))\n                            .addHeader(\"X-MBX-APIKEY\", apiKey)\n                            .build();\n                    break;\n                case GET:\n                    request = new Request.Builder().url(fullUrl)\n                            .get()\n                            .addHeader(\"Content-Type\", \"application/x-www-form-urlencoded\")\n                            .addHeader(\"X-MBX-APIKEY\", apiKey)\n                            .build();\n                    break;\n                case PUT:\n                    request = new Request.Builder().url(fullUrl)\n                            .put(RequestBody.create(\"\", JSON_TYPE))\n                            .addHeader(\"Content-Type\", \"application/x-www-form-urlencoded\")\n                            .addHeader(\"X-MBX-APIKEY\", apiKey)\n                            .build();\n                    break;\n                case DELETE:\n                    request = new Request.Builder().url(fullUrl)\n                            .delete()\n                            .addHeader(\"Content-Type\", \"application/x-www-form-urlencoded\")\n                            .addHeader(\"X-MBX-APIKEY\", apiKey)\n                            .build();\n                    break;\n                default:\n                    throw new BinanceConnectorException(\"Invalid HTTP method: \" + httpMethod);\n            }\n            return request;\n        } catch (IllegalArgumentException e) {\n            throw new BinanceConnectorException(\"Invalid URL: \" + e.getMessage());\n        }\n    }\n\n    public static Request buildWebsocketRequest(String fullUrl) {\n        return new Request.Builder().url(fullUrl).build();\n    }\n}\n"
    },
    {
        "detailed_description": "The public class FloatBooleanHandler is a specialized class that extends the AbstractFloatCellHandler class. This class is designed to handle the conversion of float values to boolean values within the context of an Excel spreadsheet. It contains a private static final float field named TRUE_VALUE, which is set to 1f. This field represents the float value that corresponds to a boolean true value in the context of this class.\n\nThe class overrides two methods from the AbstractFloatCellHandler class. The first method, setCellValue, takes four parameters: a RowContext object, an ExcelFieldConfig object, a Cell object, and a Float value. This method is designed to set the value of a specific cell in the spreadsheet. It does this by comparing the provided float value to the TRUE_VALUE. If the float value is equal to TRUE_VALUE, the cell's value is set to true; otherwise, it is set to false.\n\nThe second overridden method, getExcelType, takes no parameters and returns an ExcelType enumeration value. Specifically, it returns ExcelType.BOOLEAN, indicating that this handler is used for boolean values in Excel spreadsheets. This method is useful for determining the type of data that the handler is designed to process.\"",
        "sketchy_description": "The public class FloatBooleanHandler, which extends AbstractFloatCellHandler, is specifically designed to handle the conversion of float values to boolean values within Excel cells. This functionality is particularly useful when dealing with Excel spreadsheets that require a boolean representation of certain float values. The class defines a constant TRUE_VALUE which is used as a reference to determine the boolean state.\n\nThe protected method setCellValue takes multiple parameters including a RowContext, an ExcelFieldConfig, a Cell, and a Float value. Its primary function is to set the cell's value within an Excel spreadsheet. If the float value passed to this method is equal to the predefined TRUE_VALUE, the cell's value is set to true; otherwise, it is set to false. This method is crucial for ensuring that float values are accurately represented as boolean values in the context of an Excel document.\n\nAdditionally, the public method getExcelType returns the enum ExcelType.BOOLEAN. This indicates that the handler's purpose is to manage boolean values within Excel, providing clarity to any implementation that relies on understanding the type of data the handler is dealing with. This method is a straightforward way to communicate the data type that this handler is associated with, which is essential for proper data processing and manipulation in Excel-related operations.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/floats/FloatBooleanHandler.java",
        "class_name": "FloatBooleanHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "FloatBooleanHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/FloatBooleanHandlerTest.java"
        },
        "task_id": 31,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.floats;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport org.apache.poi.ss.usermodel.Cell;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class FloatBooleanHandler extends AbstractFloatCellHandler {\n\n    private final static Float TRUE_VALUE = 1f;\n\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, Float value) {\n        cell.setCellValue(value.compareTo(TRUE_VALUE) == 0);\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.BOOLEAN;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class ExcelFieldConfig is designed to represent the configuration of a field in an Excel spreadsheet. It contains several private final fields, each with a default value, which are used to store the configuration details. These fields include the title of the field, its width, the name of the property it corresponds to, the type of Java object it represents, the type of Excel cell it corresponds to, an array of cell handlers, the number of columns it spans, the format of the header, the format of the Java object, the format of the Excel cell, the sort order, and the styles of the header and data cells.\n\nThe class also includes two static methods for creating instances of ExcelFieldConfig. The getDefaultExcelFieldConfig method creates a default configuration for a given property name and Java type. The buildByExcelField method creates a configuration based on an ExcelField object, a property name, and a Java type. This method uses the values from the ExcelField object to override the default values of the ExcelFieldConfig object.\n\nThe @Builder.Default annotation is used to indicate that the annotated field should be initialized with a default value when the builder is used to create an instance of the class. The @SuppressWarnings(\"unchecked\") annotation is used to suppress compiler warnings related to unchecked operations, which are operations that the compiler cannot guarantee to be type-safe.\"",
        "sketchy_description": "The public class ExcelFieldConfig is designed to encapsulate the configuration settings for a field within an Excel document. This class contains a variety of class variables with default values that define the title, width, property name, Java type, Excel type, cell handlers, column span, formatting options, sorting order, and styles for both the header and data cells within the Excel field.\n\nThe class provides two static methods for creating instances of ExcelFieldConfig. The first method, getDefaultExcelFieldConfig, takes a property name and a Java type as arguments and returns a default configuration for an Excel field. This method is useful when a simple configuration is sufficient and no customization is required.\n\nThe second method, buildByExcelField, is more advanced and allows for the creation of an ExcelFieldConfig based on an ExcelField annotation. This method also requires the property name and Java type to be specified. It is intended for scenarios where the Excel field configuration needs to be derived from an existing annotation, allowing for more detailed and specific configuration that aligns with the annotation's properties.\n\nBoth methods serve to simplify the process of configuring Excel fields, ensuring that the fields are properly set up to reflect the desired properties and behaviors when generating or manipulating Excel documents programmatically.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/metadata/config/ExcelFieldConfig.java",
        "class_name": "ExcelFieldConfig",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "ExcelFieldConfigTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/metadata/config/ExcelFieldConfigTest.java"
        },
        "task_id": 32,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.metadata.config;\n\nimport io.github.zouzhiy.excel.annotation.ExcelField;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.handler.CellHandler;\nimport lombok.Builder;\nimport lombok.EqualsAndHashCode;\nimport lombok.Getter;\nimport lombok.ToString;\n\n\n/**\n * \u5b57\u6bb5\u914d\u7f6e {@link io.github.zouzhiy.excel.annotation.ExcelField}\n *\n * @author zouzhiy\n * @since 2022/7/2\n */\n@Getter\n@ToString\n@EqualsAndHashCode\n@Builder\npublic class ExcelFieldConfig {\n\n    @Builder.Default\n    private final String title = \"\";\n\n    @Builder.Default\n    private final double width = -1D;\n\n    @Builder.Default\n    private final String propertyName = \"\";\n\n    @Builder.Default\n    private final Class<?> javaType = Object.class;\n\n    @Builder.Default\n    private final ExcelType excelType = ExcelType.BLANK;\n\n    @SuppressWarnings(\"unchecked\")\n    @Builder.Default\n    private final Class<? extends CellHandler<?>>[] cellHandler = (Class<? extends CellHandler<?>>[]) new Class<?>[0];\n\n    @Builder.Default\n    private final int colspan = 1;\n\n    @Builder.Default\n    private final String headFormat = \"@\";\n\n    @Builder.Default\n    private final String javaFormat = \"\";\n\n    @Builder.Default\n    private final String excelFormat = \"\";\n\n    @Builder.Default\n    private final long sort = 0L;\n\n    @Builder.Default\n    private final ExcelStyleConfig headStyle = ExcelStyleConfig.getDefaultExcelStyleConfigHead();\n\n    @Builder.Default\n    private final ExcelStyleConfig dataStyle = ExcelStyleConfig.getDefaultExcelStyleConfigData();\n\n\n    public static ExcelFieldConfig getDefaultExcelFieldConfig(String propertyName, Class<?> javaType) {\n        return ExcelFieldConfig.builder()\n                .title(propertyName)\n                .propertyName(propertyName)\n                .javaType(javaType)\n                .build();\n    }\n\n\n    public static ExcelFieldConfig buildByExcelField(ExcelField excelField, String propertyName, Class<?> javaType) {\n        return ExcelFieldConfig\n                .builder()\n                .title(excelField.title().length() == 0 ? propertyName : excelField.title())\n                .width(excelField.width())\n                .propertyName(propertyName)\n                .javaType(javaType)\n                .excelType(excelField.excelType())\n                .cellHandler(excelField.cellHandler())\n                .colspan(excelField.colspan())\n                .headFormat(excelField.headFormat())\n                .javaFormat(excelField.javaFormat())\n                .excelFormat(excelField.excelFormat())\n                .sort(excelField.sort())\n                .headStyle(ExcelStyleConfig.buildByExcelStyle(excelField.headStyle()))\n                .dataStyle(ExcelStyleConfig.buildByExcelStyle(excelField.dataStyle()))\n                .build();\n    }\n}\n"
    },
    {
        "detailed_description": "The public class AvgGrayingStrategy is a subclass of the AbstractGrayingStrategy class. This class is designed to implement a specific strategy for calculating the grayness value of a color, based on the average of its red, green, and blue components. The class overrides the getGraynessValue method from the AbstractGrayingStrategy class. This method takes three integer arguments, representing the red, green, and blue components of a color, respectively. It calculates the average of these three values and returns the result. This strategy is useful in image processing tasks where a color image needs to be converted to grayscale.\"",
        "sketchy_description": "The public class AvgGrayingStrategy, which extends the AbstractGrayingStrategy class, is designed to implement a specific strategy for converting a color image to grayscale. This strategy involves averaging the values of the red (r), green (g), and blue (b) components of a color to determine its grayness value. The method getGraynessValue takes three integer arguments corresponding to the RGB values and returns an integer that represents the calculated grayness value. This method is essential for the graying process, as it defines how the color information is reduced to a single grayscale value, which is then used to create the final grayscale image.",
        "file": "imglib/ext-t8s/src/main/java/cn/t8s/mode/graying/AvgGrayingStrategy.java",
        "class_name": "AvgGrayingStrategy",
        "repo_metadata": {
            "repo_name": "imglib"
        },
        "evaluation_metadata": {
            "test_class_name": "AvgGrayingStrategyTest",
            "test_file": "imglib/ext-t8s/src/test/java/cn/t8s/mode/graying/AvgGrayingStrategyTest.java"
        },
        "task_id": 33,
        "ground_truth_class_body": "package cn.t8s.mode.graying;\n\nimport cn.core.strategy.mode.AbstractGrayingStrategy;\n\n/**\n * An average graying strategy. The gray value of any pixel is equal to the average value\n * of the red component, green component and blue component.\n *\n * @author tracy\n * @since 0.2.1\n */\npublic class AvgGrayingStrategy extends AbstractGrayingStrategy {\n    @Override\n    public int getGraynessValue(int r, int g, int b) {\n        return (r + g + b) / 3;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class CustomSerDe is designed to handle the serialization and deserialization of application submission requests and Spark application specifications, with a focus on ensuring that sensitive information is removed or masked during the process. \n\nThe class contains two static methods: submitRequestToNonSensitiveJson and sparkSpecToNonSensitiveJson. Both methods take an object as an argument (SubmitApplicationRequest and SparkApplicationSpec respectively), serialize it to a JSON string, and return the serialized string. \n\nThe submitRequestToNonSensitiveJson method takes a SubmitApplicationRequest object, clones it, and then removes or masks any sensitive information. Specifically, it removes the driver and executor environment variables and masks the queue token. \n\nThe sparkSpecToNonSensitiveJson method operates similarly, but with a SparkApplicationSpec object. It also clones the object and removes the driver and executor environment variables. \n\nBoth methods use the ObjectMapper class from the Jackson library to handle the serialization and deserialization of the objects. They also both throw a JsonProcessingException if there is an issue with the processing of the JSON data.\"",
        "sketchy_description": "The public class CustomSerDe is designed to handle the serialization of application requests and Spark application specifications into JSON format while ensuring that sensitive information is either removed or masked to protect privacy and security. This class provides static methods that can be used without needing to instantiate an object of the class.\n\nThe `submitRequestToNonSensitiveJson` method takes an instance of `SubmitApplicationRequest` as an input and returns a JSON string representation of the request. During the serialization process, it carefully removes or masks any sensitive information to prevent potential data leaks. If the serialization process encounters any issues, it throws a `JsonProcessingException`, indicating that the conversion to a JSON string could not be completed successfully.\n\nSimilarly, the `sparkSpecToNonSensitiveJson` method accepts a `SparkApplicationSpec` object and performs serialization to a JSON string, also ensuring that sensitive details are not exposed. This method is particularly useful when dealing with Spark application specifications that may contain configuration settings or other data that should not be shared openly. Like the previous method, it throws a `JsonProcessingException` if it fails to serialize the object properly.\n\nBoth methods are crucial for maintaining data security and integrity when handling application requests and specifications within systems that utilize Spark or similar frameworks.",
        "file": "batch-processing-gateway/src/main/java/com/apple/spark/util/CustomSerDe.java",
        "class_name": "CustomSerDe",
        "repo_metadata": {
            "repo_name": "batch-processing-gateway"
        },
        "evaluation_metadata": {
            "test_class_name": "CustomSerDeTest",
            "test_file": "batch-processing-gateway/src/test/java/com/apple/spark/util/CustomSerDeTest.java"
        },
        "task_id": 34,
        "ground_truth_class_body": "/*\n *\n * This source file is part of the Batch Processing Gateway open source project\n *\n * Copyright 2022 Apple Inc. and the Batch Processing Gateway project authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.apple.spark.util;\n\nimport com.apple.spark.api.SubmitApplicationRequest;\nimport com.apple.spark.operator.SparkApplicationSpec;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class CustomSerDe {\n\n  /**\n   * Given an application submission request, serialize it to a JSON string with sensitive\n   * information removed/masked\n   *\n   * @param submitRequest\n   * @return a serialized JSON string\n   * @throws JsonProcessingException\n   */\n  public static String submitRequestToNonSensitiveJson(SubmitApplicationRequest submitRequest)\n      throws JsonProcessingException {\n    ObjectMapper mapper = new ObjectMapper();\n    SubmitApplicationRequest cloned =\n        new ObjectMapper()\n            .readValue(mapper.writeValueAsString(submitRequest), SubmitApplicationRequest.class);\n\n    // remove the driver env vars\n    if (cloned.getDriver() != null) {\n      cloned.getDriver().setEnv(null);\n    }\n\n    // remove the executor env vars\n    if (cloned.getExecutor() != null) {\n      cloned.getExecutor().setEnv(null);\n    }\n\n    // mask the queue token\n    if (cloned.getQueueToken() != null) {\n      cloned.setQueueToken(\"***\");\n    }\n\n    return mapper.writeValueAsString(cloned);\n  }\n\n  /**\n   * Given a Spark application spec, serialize it to a JSON string with sensitive information\n   * removed/masked\n   *\n   * @param sparkSpec\n   * @return a serialized JSON string\n   * @throws JsonProcessingException\n   */\n  public static String sparkSpecToNonSensitiveJson(SparkApplicationSpec sparkSpec)\n      throws JsonProcessingException {\n    ObjectMapper mapper = new ObjectMapper();\n    SparkApplicationSpec cloned =\n        new ObjectMapper()\n            .readValue(mapper.writeValueAsString(sparkSpec), SparkApplicationSpec.class);\n\n    // remove the driver env vars\n    if (cloned.getDriver() != null) {\n      cloned.getDriver().setEnv(null);\n    }\n\n    // remove the executor env vars\n    if (cloned.getExecutor() != null) {\n      cloned.getExecutor().setEnv(null);\n    }\n\n    return mapper.writeValueAsString(cloned);\n  }\n}\n"
    },
    {
        "detailed_description": "The public class StringDateHandler extends the AbstractCellHandler class and is specialized to handle cells that contain dates in a string format. This class overrides several methods from the AbstractCellHandler class to provide specific functionality for handling date strings.\n\nThe getCellValue method is overridden to convert the date value from the first cell result into a string format. It first retrieves the date value from the first cell result and then formats it into a string using the ExcelDateFormatUtils.format method.\n\nThe setCellValue method is overridden to parse a date string and set it as the value of a cell. It first parses the date string into a LocalDateTime object using the ExcelDateParseUtils.parseDateTime method, and then sets this date as the value of the cell.\n\nThe getExcelType method is overridden to return ExcelType.DATE, indicating that this handler is designed to handle date values.\n\nThe getDefaultJavaFormat and getDefaultExcelFormat methods are overridden to return the default date format string \"yyyy-MM-dd HH:mm:ss\". This is the format that will be used to parse and format date strings if no other format is specified.",
        "sketchy_description": "The public class StringDateHandler, which extends the AbstractCellHandler with a generic type of String, is specialized in handling the conversion between String representations of dates and the date formats used in Excel. This class provides a set of protected and public methods to facilitate the manipulation of date values within Excel sheets.\n\nThe `getCellValue` method is a protected method that takes a SheetContext, an ExcelFieldConfig, and a CellResult as parameters. It retrieves the cell value as a String, which is formatted as a date according to the rules defined in the ExcelFieldConfig and based on the value obtained from the firstCellResult. This method is essential for reading date values from Excel cells and converting them into a String representation that can be used in Java.\n\nThe `setCellValue` method is another protected method that takes a RowContext, an ExcelFieldConfig, a Cell, and a String value as parameters. It sets the cell value in an Excel sheet to a LocalDateTime object that is parsed from the provided String value. The LocalDateTime is formatted according to the ExcelFieldConfig, ensuring that the date is correctly represented in the Excel sheet.\n\nThe `getExcelType` method is a public method that returns the ExcelType associated with this handler. In this case, the ExcelType is ExcelType.DATE, indicating that this handler deals with date values within Excel.\n\nThe `getDefaultJavaFormat` method is a public method that returns the default Java date format string, which is specified as \"yyyy-MM-dd HH:mm:ss\". This format is commonly used for representing dates and times in Java applications.\n\nLastly, the `getDefaultExcelFormat` method is a public method that provides the default Excel date format string, which is also \"yyyy-MM-dd HH:mm:ss\". This format is used to ensure consistency in the representation of date values when working with Excel sheets.\n\nTogether, these methods provide a robust framework for handling date conversions between String representations and Excel formats, making it easier to work with date values in Excel-related Java applications.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/string/StringDateHandler.java",
        "class_name": "StringDateHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "StringDateHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/StringDateHandlerTest.java"
        },
        "task_id": 35,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.string;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.context.SheetContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.handler.AbstractCellHandler;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport io.github.zouzhiy.excel.metadata.result.CellResult;\nimport io.github.zouzhiy.excel.utils.ExcelDateFormatUtils;\nimport io.github.zouzhiy.excel.utils.ExcelDateParseUtils;\nimport org.apache.poi.ss.usermodel.Cell;\n\nimport java.time.LocalDateTime;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class StringDateHandler extends AbstractCellHandler<String> {\n\n    @Override\n    protected String getCellValue(SheetContext sheetContext, ExcelFieldConfig excelFieldConfig, CellResult firstCellResult) {\n        LocalDateTime localDateTime = firstCellResult.getDateValue(this.getJavaFormat(excelFieldConfig));\n        String javaFormat = this.getJavaFormat(excelFieldConfig);\n        return ExcelDateFormatUtils.format(localDateTime, javaFormat);\n    }\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, String value) {\n        String javaFormat = this.getJavaFormat(excelFieldConfig);\n        LocalDateTime localDateTime = ExcelDateParseUtils.parseDateTime(value, javaFormat);\n        cell.setCellValue(localDateTime);\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.DATE;\n    }\n\n    @Override\n    public String getDefaultJavaFormat() {\n        return \"yyyy-MM-dd HH:mm:ss\";\n    }\n\n    @Override\n    public String getDefaultExcelFormat() {\n        return \"yyyy-MM-dd HH:mm:ss\";\n    }\n}\n"
    },
    {
        "detailed_description": "The public class ZouzhiyExcelFactoryBuilder is designed to build an instance of ZouzhiyExcelFactory, which is presumably a class for handling Excel-related operations. The class has a private member, configuration, of type Configuration, which is used to configure the ZouzhiyExcelFactory instance.\n\nThe class has a private constructor that takes a Configuration object as an argument and assigns it to the configuration member. There are two static builder methods that return an instance of ZouzhiyExcelFactoryBuilder. The first one creates a new Configuration object and passes it to the second builder method, which then creates a new ZouzhiyExcelFactoryBuilder object with the given configuration.\n\nThe class also has several register methods that take different types of arguments, such as CellHandler, RowWrite, RowRead, and RowStyleRead. These methods register the given argument with the appropriate registry in the configuration object and return the ZouzhiyExcelFactoryBuilder instance for method chaining.\n\nThere are also several setter methods that set various properties in the configuration object, such as ReflectorFactory, ObjectFactory, ObjectWrapperFactory, and cache settings for classes and configurations. These methods also return the ZouzhiyExcelFactoryBuilder instance for method chaining.\n\nFinally, the build method creates a new DefaultZouzhiyExcelFactory object with the configuration and returns it. This method is typically called after all the necessary settings have been made to the ZouzhiyExcelFactoryBuilder instance.\n\nThere are also several private register methods that register different types of RowWrite and RowRead objects with the appropriate registries in the configuration object. These methods are presumably called by the public register methods when the argument is of a specific type.\"",
        "sketchy_description": "The public class ZouzhiyExcelFactoryBuilder is designed to facilitate the creation of a ZouzhiyExcelFactory, which is a factory class for generating Excel-related objects with custom configurations. The class contains a private final variable named 'configuration' that holds the configuration settings for the factory.\n\nThe class provides a set of static and public methods that allow users to create a new instance of ZouzhiyExcelFactoryBuilder with either default or specified configurations. The builder pattern is used here, allowing users to chain method calls to register various handlers and set different options for the factory configuration.\n\nThe `register` methods are used to add different types of handlers to the configuration, such as cell handlers, row writers, row readers, and row style readers. These handlers are responsible for processing cells, rows, and styles when reading from or writing to Excel files.\n\nThe `setReflectorFactory`, `setObjectFactory`, and `setObjectWrapperFactory` methods are used to set the factories responsible for creating reflectors, objects, and object wrappers, respectively. These factories are part of the internal mechanism that the ZouzhiyExcelFactory uses to manage object creation and metadata handling.\n\nThe `setClassCacheEnabled` and `setConfigCacheEnabled` methods allow users to enable or disable caching for class metadata and configuration settings, which can improve performance by avoiding redundant computations.\n\nFinally, the `build` method compiles all the settings and registrations made to the builder and returns a new instance of ZouzhiyExcelFactory with the current configuration.\n\nAdditionally, there are private methods to register row title, head, and foot writers and readers to the configuration. These methods are likely used internally by the builder to manage specific types of row processing that are not exposed publicly.\n\nOverall, the ZouzhiyExcelFactoryBuilder class provides a comprehensive and flexible way to construct a ZouzhiyExcelFactory with custom settings, making it easier to work with Excel files in a Java application.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/builder/ZouzhiyExcelFactoryBuilder.java",
        "class_name": "ZouzhiyExcelFactoryBuilder",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "ZouzhiyExcelFactoryBuilderTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/builder/ZouzhiyExcelFactoryBuilderTest.java"
        },
        "task_id": 36,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.builder;\n\nimport io.github.zouzhiy.excel.cellstyle.RowStyleRead;\nimport io.github.zouzhiy.excel.handler.CellHandler;\nimport io.github.zouzhiy.excel.ibatis.reflection.ReflectorFactory;\nimport io.github.zouzhiy.excel.ibatis.reflection.factory.ObjectFactory;\nimport io.github.zouzhiy.excel.ibatis.reflection.wrapper.ObjectWrapperFactory;\nimport io.github.zouzhiy.excel.metadata.Configuration;\nimport io.github.zouzhiy.excel.read.RowFootRead;\nimport io.github.zouzhiy.excel.read.RowHeadRead;\nimport io.github.zouzhiy.excel.read.RowRead;\nimport io.github.zouzhiy.excel.read.RowTitleRead;\nimport io.github.zouzhiy.excel.write.RowFootWrite;\nimport io.github.zouzhiy.excel.write.RowHeadWrite;\nimport io.github.zouzhiy.excel.write.RowTitleWrite;\nimport io.github.zouzhiy.excel.write.RowWrite;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class ZouzhiyExcelFactoryBuilder {\n\n    private final Configuration configuration;\n\n    private ZouzhiyExcelFactoryBuilder(Configuration configuration) {\n        this.configuration = configuration;\n    }\n\n    public static ZouzhiyExcelFactoryBuilder builder() {\n        return builder(new Configuration());\n    }\n\n    public static ZouzhiyExcelFactoryBuilder builder(Configuration configuration) {\n        return new ZouzhiyExcelFactoryBuilder(configuration);\n    }\n\n    public ZouzhiyExcelFactoryBuilder register(CellHandler<?> cellHandler) {\n        this.configuration.getCellHandlerRegistry().register(cellHandler);\n        return this;\n    }\n\n    public ZouzhiyExcelFactoryBuilder register(RowWrite rowWrite) {\n        if (rowWrite instanceof RowTitleWrite) {\n            this.register((RowTitleWrite) rowWrite);\n        }\n        if (rowWrite instanceof RowHeadWrite) {\n            this.register((RowHeadWrite) rowWrite);\n        }\n        if (rowWrite instanceof RowFootWrite) {\n            this.register((RowFootWrite) rowWrite);\n        }\n        return this;\n    }\n\n    public ZouzhiyExcelFactoryBuilder register(RowRead rowRead) {\n        if (rowRead instanceof RowTitleRead) {\n            this.register((RowTitleRead) rowRead);\n        }\n        if (rowRead instanceof RowHeadRead) {\n            this.register((RowHeadRead) rowRead);\n        }\n        if (rowRead instanceof RowFootRead) {\n            this.register((RowFootRead) rowRead);\n        }\n        return this;\n    }\n\n    public ZouzhiyExcelFactoryBuilder register(RowStyleRead rowStyleRead) {\n        this.configuration.getRowStyleReadRegistry().register(rowStyleRead);\n        return this;\n    }\n\n    public ZouzhiyExcelFactoryBuilder setReflectorFactory(ReflectorFactory reflectorFactory) {\n        this.configuration.setReflectorFactory(reflectorFactory);\n        return this;\n    }\n\n    public ZouzhiyExcelFactoryBuilder setObjectFactory(ObjectFactory objectFactory) {\n        this.configuration.setObjectFactory(objectFactory);\n        return this;\n    }\n\n    public ZouzhiyExcelFactoryBuilder setObjectWrapperFactory(ObjectWrapperFactory objectWrapperFactory) {\n        this.configuration.setObjectWrapperFactory(objectWrapperFactory);\n        return this;\n    }\n\n    public ZouzhiyExcelFactoryBuilder setClassCacheEnabled(boolean classCacheEnabled) {\n        this.configuration.getReflectorFactory().setClassCacheEnabled(classCacheEnabled);\n        return this;\n    }\n\n    public ZouzhiyExcelFactoryBuilder setConfigCacheEnabled(boolean configCacheEnabled) {\n        this.configuration.getExcelAnnotationParse().setConfigCacheEnabled(configCacheEnabled);\n        return this;\n    }\n\n    public ZouzhiyExcelFactory build() {\n        return new DefaultZouzhiyExcelFactory(configuration);\n    }\n\n\n    private ZouzhiyExcelFactoryBuilder register(RowTitleWrite rowTitleWrite) {\n        this.configuration.getRowTitleWriteRegistry().register(rowTitleWrite);\n        return this;\n    }\n\n    private ZouzhiyExcelFactoryBuilder register(RowHeadWrite rowHeadWrite) {\n        this.configuration.getRowHeadWriteRegistry().register(rowHeadWrite);\n        return this;\n    }\n\n    private ZouzhiyExcelFactoryBuilder register(RowFootWrite rowFootWrite) {\n        this.configuration.getRowFootWriteRegistry().register(rowFootWrite);\n        return this;\n    }\n\n    private ZouzhiyExcelFactoryBuilder register(RowTitleRead rowTitleRead) {\n        this.configuration.getRowTitleReadRegistry().register(rowTitleRead);\n        return this;\n    }\n\n    private ZouzhiyExcelFactoryBuilder register(RowHeadRead rowHeadRead) {\n        this.configuration.getRowHeadReadRegistry().register(rowHeadRead);\n        return this;\n    }\n\n    private ZouzhiyExcelFactoryBuilder register(RowFootRead rowFootRead) {\n        this.configuration.getRowFootReadRegistry().register(rowFootRead);\n        return this;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class RowStyleReadRegistry is designed to manage and provide access to different styles of reading rows in a spreadsheet. It contains a static final field DEFAULT_ROW_STYLE_READ_CLASS, which is a reference to the DefaultRowStyleRead class. This field is used as a default style for reading rows.\n\nThe class also contains a private final field configuration of type Configuration, which is used to store the configuration settings for the registry. This field is initialized through the constructor, which takes a Configuration object as an argument.\n\nAnother private field is rowStyleReadMap, which is a concurrent hash map that stores objects of type RowStyleRead, mapped by their class. This map is used to register and retrieve different styles of reading rows.\n\nThe class provides a public method getConfiguration, which returns the current configuration object. Another public method is register, which takes a RowStyleRead object as an argument and adds it to the rowStyleReadMap, using the object's class as the key.\n\nThe getMappingRowStyleRead method is used to retrieve a RowStyleRead object from the map using its class as the key. If the requested class is not found in the map, an ExcelException is thrown with a message indicating that the requested CellStyleRead does not exist.\"",
        "sketchy_description": "The public class RowStyleReadRegistry is designed to manage the registration of different row style readers, which are essential for processing Excel files. The class includes a static class variable DEFAULT_ROW_STYLE_READ_CLASS, which holds a reference to the DefaultRowStyleRead class, indicating the default reader to be used.\n\nThe constructor of the RowStyleReadRegistry class takes a Configuration object as an argument and uses it to initialize the registry. It also registers the default row style reader as part of the initialization process. This setup is crucial for ensuring that the registry is configured correctly and ready to manage the row style readers.\n\nThe getConfiguration method is a public method that allows retrieval of the Configuration object associated with the registry. This method is useful for accessing the configuration details outside of the registry class.\n\nThe register method is another public method that takes a RowStyleRead object as an argument and adds it to the registry. This method enables the dynamic addition of new row style readers, allowing for customization and extension of the Excel processing capabilities.\n\nLastly, the getMappingRowStyleRead method is a public method that takes a Class object as an argument, representing a subclass of RowStyleRead. It returns the corresponding RowStyleRead instance from the registry. If the specified instance does not exist in the registry, the method throws an ExcelException. This method is essential for retrieving the appropriate row style reader based on the class type, ensuring that the correct processing logic is applied to the Excel rows.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/cellstyle/registry/RowStyleReadRegistry.java",
        "class_name": "RowStyleReadRegistry",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "RowStyleReadRegistryTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/cellstyle/registry/RowStyleReadRegistryTest.java"
        },
        "task_id": 37,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.cellstyle.registry;\n\nimport io.github.zouzhiy.excel.cellstyle.RowStyleRead;\nimport io.github.zouzhiy.excel.cellstyle.defaults.DefaultRowStyleRead;\nimport io.github.zouzhiy.excel.exceptions.ExcelException;\nimport io.github.zouzhiy.excel.metadata.Configuration;\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class RowStyleReadRegistry {\n\n    public final static Class<DefaultRowStyleRead> DEFAULT_ROW_STYLE_READ_CLASS = DefaultRowStyleRead.class;\n\n    private final Configuration configuration;\n\n    private final Map<Class<? extends RowStyleRead>, RowStyleRead> rowStyleReadMap = new ConcurrentHashMap<>(16);\n\n    public RowStyleReadRegistry(Configuration configuration) {\n        this.configuration = configuration;\n        register(new DefaultRowStyleRead());\n    }\n\n    public Configuration getConfiguration() {\n        return configuration;\n    }\n\n    public void register(RowStyleRead rowStyleRead) {\n        rowStyleReadMap.put(rowStyleRead.getClass(), rowStyleRead);\n    }\n\n    public RowStyleRead getMappingRowStyleRead(Class<? extends RowStyleRead> rowStyleReadClazz) {\n        RowStyleRead rowStyleRead = rowStyleReadMap.get(rowStyleReadClazz);\n        if (rowStyleRead == null) {\n            throw new ExcelException(\"\u4e0d\u5b58\u5728\u7684\uff1aCellStyleRead\");\n        }\n        return rowStyleRead;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class StringStringHandler is a subclass of the AbstractStringCellHandler class. This class is designed to handle string cells in an Excel spreadsheet. It overrides two methods from its superclass. The first method, setCellValue, is responsible for setting the value of a cell in a row. It takes four parameters: a RowContext object that represents the context of the row in which the cell is located, an ExcelFieldConfig object that contains configuration information for the Excel field, a Cell object that represents the cell whose value is to be set, and a String value that represents the value to be set in the cell. The method then calls the setCellValue method on the Cell object, passing the String value as an argument. The second method, getExcelType, returns the type of the Excel cell. In this case, it returns ExcelType.STRING, indicating that the cell contains a string value.\"",
        "sketchy_description": "The public class StringStringHandler, which extends the AbstractStringCellHandler, is specifically designed to manage the setting of cell values for strings within the context of an Excel row. This class provides a method that allows the user to set the value of a cell with a string. The method takes a RowContext object, an ExcelFieldConfig object, a Cell object, and the string value to be set. It is a protected method, meaning it is intended to be accessed within the class itself or by subclasses, and it is responsible for correctly placing the string value into the specified cell within the row context.\n\nAdditionally, the class offers a public method named getExcelType, which returns the ExcelType corresponding to strings. This method signifies that the handler is associated with string values when dealing with Excel spreadsheets. It is a simple method that provides information about the type of data the handler is intended to manage, which in this case is string data. This can be particularly useful when working with Excel files programmatically, as it helps ensure that data is handled and formatted correctly according to its type.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/string/StringStringHandler.java",
        "class_name": "StringStringHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "StringStringHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/StringStringHandlerTest.java"
        },
        "task_id": 38,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.string;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport org.apache.poi.ss.usermodel.Cell;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class StringStringHandler extends AbstractStringCellHandler {\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, String value) {\n        cell.setCellValue(value);\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.STRING;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class ShortNumberHandler is a subclass of the AbstractShortCellHandler class. This class is designed to handle short number values in an Excel cell. It overrides two methods from its superclass. The first method, setCellValue, is responsible for setting the value of a cell in a row. It takes four parameters: a RowContext object that represents the context of the row in which the cell is located, an ExcelFieldConfig object that contains configuration information for the Excel field, a Cell object that represents the cell whose value is to be set, and a Short value that represents the value to be set in the cell. The method then calls the setCellValue method on the Cell object, passing the Short value as an argument. The second method, getExcelType, is used to return the type of the Excel cell. In this case, it returns ExcelType.NUMERIC, indicating that the cell contains a numeric value.\"",
        "sketchy_description": "The public class ShortNumberHandler, which extends AbstractShortCellHandler, is designed to handle the specific task of setting short number values within cells of an Excel spreadsheet. This functionality is crucial when dealing with Excel files programmatically, as it allows for precise control over the data being entered into the spreadsheet.\n\nThe class provides a protected method setCellValue, which takes a RowContext, an ExcelFieldConfig, a Cell, and a Short value as parameters. This method is responsible for setting the value of a given cell to the short number provided. This is particularly useful when populating spreadsheets with numerical data that falls within the range of the short data type.\n\nAdditionally, the class offers a public method getExcelType, which returns an ExcelType enumeration value. This value corresponds to numeric types, indicating the kind of data that the handler is associated with in the context of Excel. This method can be used to ensure that the data being processed is compatible with the expected numeric type in Excel, thus maintaining data integrity and consistency within the spreadsheet.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/shorts/ShortNumberHandler.java",
        "class_name": "ShortNumberHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "ShortNumberHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/ShortNumberHandlerTest.java"
        },
        "task_id": 39,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.shorts;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport org.apache.poi.ss.usermodel.Cell;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class ShortNumberHandler extends AbstractShortCellHandler {\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, Short value) {\n        cell.setCellValue(value);\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.NUMERIC;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class ByteArrayBoxStringHandler extends the AbstractCellHandler class and is designed to handle Excel cells that contain byte arrays. This class overrides several methods from the AbstractCellHandler class. \n\nThe getCellValue method takes three arguments: a SheetContext object, an ExcelFieldConfig object, and a CellResult object. It retrieves the string value from the first cell result, converts it into a byte array using the UTF-8 character set, and then boxes the byte array into an array of Byte objects using the box method. \n\nThe setCellValue method takes four arguments: a RowContext object, an ExcelFieldConfig object, a Cell object, and an array of Byte objects. It unboxes the Byte array into a byte array using the unbox method, converts the byte array into a string using the UTF-8 character set, and then sets the cell value to this string. \n\nThe unbox method takes an array of Byte objects as an argument and returns a byte array. It creates a new byte array of the same length as the Byte array, and then copies the values from the Byte array to the byte array. \n\nThe box method takes a byte array as an argument and returns an array of Byte objects. It creates a new Byte array of the same length as the byte array, and then copies the values from the byte array to the Byte array. \n\nThe getExcelType method returns the ExcelType.STRING constant, indicating that this handler is designed to handle cells that contain strings.\"",
        "sketchy_description": "The public class ByteArrayBoxStringHandler, which extends AbstractCellHandler, is specialized in handling the conversion between byte arrays and strings within the context of Excel cells. This class provides a set of methods that facilitate the reading and writing of byte array data to and from Excel cells, ensuring that the data is correctly interpreted as strings using UTF-8 encoding.\n\nThe getCellValue method is a protected method that takes a SheetContext, an ExcelFieldConfig, and a CellResult as parameters. It is responsible for retrieving the cell value as a Byte array from its string representation within an Excel sheet. This method is crucial for applications that need to process binary data stored in Excel cells.\n\nThe setCellValue method is another protected method that takes a RowContext, an ExcelFieldConfig, a Cell, and a Byte array as parameters. It sets the cell value to a string representation of the provided Byte array, again using UTF-8 encoding. This method is essential for writing binary data back to an Excel cell in a format that can be correctly interpreted as a string.\n\nThe unbox method is a private utility that converts a boxed Byte array (an array of Byte objects) into a primitive byte array (an array of the primitive byte type). This conversion is often necessary when working with APIs that require primitive types.\n\nConversely, the box method is a private utility that performs the opposite conversion, turning a primitive byte array into a boxed Byte array. This is useful when the API expects object types rather than primitives.\n\nLastly, the getExcelType method is a public method that returns the ExcelType associated with this handler, which is ExcelType.STRING. This indicates that the handler is intended to work with string representations of data in Excel cells, even though the actual data may be binary in nature.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/bytes/ByteArrayBoxStringHandler.java",
        "class_name": "ByteArrayBoxStringHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "ByteArrayBoxStringHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/ByteArrayBoxStringHandlerTest.java"
        },
        "task_id": 40,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.bytes;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.context.SheetContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.handler.AbstractCellHandler;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport io.github.zouzhiy.excel.metadata.result.CellResult;\nimport org.apache.poi.ss.usermodel.Cell;\n\nimport java.nio.charset.StandardCharsets;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class ByteArrayBoxStringHandler extends AbstractCellHandler<Byte[]> {\n\n    @Override\n    protected Byte[] getCellValue(SheetContext sheetContext, ExcelFieldConfig excelFieldConfig, CellResult firstCellResult) {\n        String value = firstCellResult.getStringValue();\n        byte[] bytes = value.getBytes(StandardCharsets.UTF_8);\n        return this.box(bytes);\n    }\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, Byte[] value) {\n        cell.setCellValue(new String(this.unbox(value), StandardCharsets.UTF_8));\n\n    }\n\n\n    private byte[] unbox(Byte[] bytes) {\n        byte[] newBytes = new byte[bytes.length];\n        for (int i = 0; i < bytes.length; i++) {\n            newBytes[i] = bytes[i];\n        }\n\n        return newBytes;\n    }\n\n    private Byte[] box(byte[] bytes) {\n        Byte[] newBytes = new Byte[bytes.length];\n        for (int i = 0; i < bytes.length; i++) {\n            newBytes[i] = bytes[i];\n        }\n\n        return newBytes;\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.STRING;\n    }\n}"
    },
    {
        "detailed_description": "The public class CustomDataPermissionChecker is a subclass of the AbstractDataPermissionChecker class. This class is designed to check if a user has the necessary permissions to access certain data. The class contains a private member, deptService, of type ISysDeptService, which is presumably a service for handling department-related operations.\n\nThe class overrides the check method from the AbstractDataPermissionChecker class. This method takes two parameters: a loginUser of type LoginUser and a condition of type DataCondition. The method first checks if either the condition or the loginUser is null, returning false if either is the case. It then checks if the role information of the loginUser is null, again returning false if it is.\n\nNext, it retrieves a set of department IDs associated with the loginUser's role and the target department ID from the condition. It then checks if the target department ID is not null and if it is contained within the set of department IDs associated with the loginUser's role. If both conditions are met, the method returns true, indicating that the user has permission to access the data. Otherwise, it returns false. This method is useful for enforcing data access permissions in a system.\"",
        "sketchy_description": "The public class CustomDataPermissionChecker, which extends the class AbstractDataPermissionChecker, is designed to implement a custom logic for checking data permissions. This class is particularly useful in scenarios where data access needs to be controlled based on specific conditions and user roles or attributes. It contains a private class variable `deptService` which is likely used to interact with departmental data or services within the application.\n\nThe class exposes a public method `check`, which takes two parameters: a `LoginUser` object representing the user whose permissions are being checked, and a `DataCondition` object that encapsulates the conditions under which the data access is being evaluated. The method returns a boolean value, with `true` indicating that the user has the necessary permissions to access the data under the given condition, and `false` indicating that the user does not have the required permissions. This method is essential for maintaining data security and ensuring that users can only access data for which they have been granted permission.",
        "file": "AgileBoot-Back-End/agileboot-infrastructure/src/main/java/com/agileboot/infrastructure/web/domain/permission/checker/CustomDataPermissionChecker.java",
        "class_name": "CustomDataPermissionChecker",
        "repo_metadata": {
            "repo_name": "AgileBoot-Back-End"
        },
        "evaluation_metadata": {
            "test_class_name": "CustomDataPermissionCheckerTest",
            "test_file": "AgileBoot-Back-End/agileboot-infrastructure/src/test/java/com/agileboot/infrastructure/web/domain/permission/checker/CustomDataPermissionCheckerTest.java"
        },
        "task_id": 41,
        "ground_truth_class_body": "package com.agileboot.infrastructure.web.domain.permission.checker;\n\nimport cn.hutool.core.collection.CollUtil;\nimport com.agileboot.infrastructure.web.domain.login.LoginUser;\nimport com.agileboot.infrastructure.web.domain.permission.AbstractDataPermissionChecker;\nimport com.agileboot.infrastructure.web.domain.permission.DataCondition;\nimport com.agileboot.orm.system.service.ISysDeptService;\nimport java.util.Set;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n/**\n * \u6570\u636e\u6743\u9650\u6d4b\u8bd5\u63a5\u53e3\n * @author valarchie\n */\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class CustomDataPermissionChecker extends AbstractDataPermissionChecker {\n\n    private ISysDeptService deptService;\n\n\n    @Override\n    public boolean check(LoginUser loginUser, DataCondition condition) {\n        if (condition == null || loginUser == null) {\n            return false;\n        }\n\n        if (loginUser.getRoleInfo() == null) {\n            return false;\n        }\n\n        Set<Long> deptIdSet = loginUser.getRoleInfo().getDeptIdSet();\n        Long targetDeptId = condition.getTargetDeptId();\n\n        return condition.getTargetDeptId() != null && CollUtil.safeContains(deptIdSet, targetDeptId);\n    }\n}\n"
    },
    {
        "detailed_description": "The public class PdfSourceBuilder<S> extends the AbstractSourceBuilder<PdfSourceBuilder<S>> class and is designed to build a PDF source. It contains a private static final Logger object for logging purposes. The class also contains a protected PdfSource<S> object, a boolean variable 'containsAll' to indicate whether to include all pages, a Set of Integer 'pages' to store the page indexes to be extracted, a float 'dpi' to represent the DPI (dots per inch) to render at, and a boolean 'disposable' to indicate whether the pdf source object is one-time.\n\nThe class has a constructor that takes a PdfSource<S> object as an argument and initializes the 'source' with it. It also has several methods that return a PdfSourceBuilder<S> object, including 'unDisposable()', 'registerAll()', 'register(int pageIndex)', 'register(int... pageIndexes)', 'register(Range<Integer> range)', and 'dpi(float dpi)'. These methods are used to set the 'disposable', 'containsAll', 'pages', and 'dpi' variables, respectively.\n\nThe 'release()' method is used to release some resources and reset the status of the source object. It throws an IOException if some I/O exceptions occurred when closing the resource. The 'obtainSourceImages()' method is used to obtain source images and throws an IOException if some I/O exceptions occurred when obtaining the images. The 'checkReadiness()' method is used to check the readiness of the pages. The 'checkPageIndex(int pageIndex)' method is a private static method used to check the page index.\n\nThe 'finalize()' method is used to release some resources when the developer forgets. It throws a Throwable if some I/O exceptions occurred when closing the resource. This method also logs a warning message if the source is not closed.\"",
        "sketchy_description": "The public class PdfSourceBuilder, which extends the abstract class AbstractSourceBuilder, is designed to facilitate the creation of a PdfSource object, which is used to handle PDF content with various configuration options. The class includes a Logger instance for logging purposes, a PdfSource object that is being built, flags to determine whether all pages should be included or if the PdfSource object is disposable, a set of page indexes to specify which pages to extract, and a DPI setting for rendering the PDF pages.\n\nThe constructor of the PdfSourceBuilder class takes a PdfSource object as an argument and initializes the builder with it. The class provides several methods to configure the PdfSource object:\n\n- The unDisposable method marks the PdfSource as non-disposable, which means that resources associated with it will not be released automatically.\n- The registerAll method includes all pages of the PDF in the source.\n- The register method with a single integer argument includes a specific page index in the source.\n- The register method with an integer array argument includes multiple page indexes in the source.\n- The register method with a Range argument includes a range of page indexes in the source.\n- The dpi method sets the rendering DPI for the PDF pages.\n\nAdditionally, the class includes methods to manage resources and validate the builder's state:\n\n- The release method is responsible for releasing resources and resetting the status of the source object.\n- The obtainSourceImages method retrieves the source images from the PDF based on the registered pages and DPI settings.\n- The checkReadiness method ensures that the builder is ready to obtain source images by checking if pages are registered when not including all.\n- The checkPageIndex method is a private static method that validates the provided page index is non-negative.\n- The finalize method is responsible for finalizing the object and releasing resources if the source has not been closed, ensuring proper resource management.",
        "file": "imglib/all/src/main/java/cn/usage/builder/PdfSourceBuilder.java",
        "class_name": "PdfSourceBuilder",
        "repo_metadata": {
            "repo_name": "imglib"
        },
        "evaluation_metadata": {
            "test_class_name": "PdfSourceBuilderTest",
            "test_file": "imglib/all/src/test/java/cn/usage/builder/PdfSourceBuilderTest.java"
        },
        "task_id": 42,
        "ground_truth_class_body": "package cn.usage.builder;\n\nimport cn.core.in.PdfSource;\nimport cn.core.utils.ObjectUtils;\nimport cn.usage.AbstractSourceBuilder;\nimport cn.core.ex.HandlingException;\nimport cn.core.ex.InvalidSettingException;\nimport cn.core.tool.Range;\nimport cn.core.utils.CollectionUtils;\nimport cn.core.utils.StringUtils;\nimport java.awt.image.BufferedImage;\nimport java.io.*;\nimport java.text.MessageFormat;\nimport java.util.*;\nimport java.util.logging.Logger;\nimport java.util.stream.Collectors;\n\n/**\n * A source builder which form PDF source.\n *\n * @author tracy\n * @since 0.2.1\n */\npublic class PdfSourceBuilder<S> extends AbstractSourceBuilder<PdfSourceBuilder<S>> {\n\n    private static final Logger LOGGER = Logger.getLogger(PdfSourceBuilder.class.getName());\n\n    /**\n     * The PDF source.\n     */\n    protected final PdfSource<S> source;\n\n    /**\n     * Whether to include all pages.\n     */\n    private boolean containsAll = false;\n\n    /**\n     * The page indexes to be extracted.\n     */\n    private final Set<Integer> pages = new HashSet<>();\n\n    /**\n     * The DPI (dots per inch) to render at.\n     */\n    private float dpi;\n\n    /**\n     * Indicates whether the pdf source object is one-time. May need to\n     * call the method {@link PdfSourceBuilder#release()} to release\n     * resources when it is set to {@code false}.\n     */\n    private boolean disposable = true;\n\n    public PdfSourceBuilder(PdfSource<S> pdfSource) {\n        this.source = pdfSource;\n    }\n\n    public PdfSourceBuilder<S> unDisposable() {\n        disposable = false;\n        return this;\n    }\n\n    public PdfSourceBuilder<S> registerAll() {\n        containsAll = true;\n        return this;\n    }\n\n    public PdfSourceBuilder<S> register(int pageIndex) {\n        checkPageIndex(pageIndex);\n        pages.add(pageIndex);\n        return this;\n    }\n\n    public PdfSourceBuilder<S> register(int... pageIndexes) {\n        for (int index : pageIndexes) {\n            checkPageIndex(index);\n            pages.add(index);\n        }\n        return this;\n    }\n\n    public PdfSourceBuilder<S> register(Range<Integer> range) {\n        ObjectUtils.excNull(range, \"Range is null.\");\n        checkPageIndex(range.getMin());\n        for (int i = range.getMin(); i <= range.getMax(); i++) {\n            pages.add(i);\n        }\n        return this;\n    }\n\n    public PdfSourceBuilder<S> dpi(float dpi) {\n        if (dpi <= 0) {\n            throw new InvalidSettingException(\"DPI must be greater than 0.\");\n        }\n        this.dpi = dpi;\n        return this;\n    }\n\n    /**\n     * Release some resources and reset the status of source object.\n     *\n     * @throws IOException If some I/O exceptions occurred when closing resource.\n     */\n    public void release() throws IOException {\n        if (! source.isClosed()) {\n            source.close();\n        }\n    }\n\n    @Override\n    protected List<BufferedImage> obtainSourceImages() throws IOException {\n        try {\n            checkReadiness();\n\n            // the max page index of the pdf\n            int maxPageIndex = source.maxPageNumber() - 1;\n\n            float val = dpi <= 0 ? 300 : dpi;\n\n            // export all pages\n            if (containsAll) {\n                for (int index = 0; index <= maxPageIndex; index++) {\n                    pages.add(index);\n                }\n            }\n\n            // check all page was in bound\n            Set<String> invalidPages = pages.stream()\n                    .filter(p -> maxPageIndex < p)\n                    .map(Objects::toString)\n                    .collect(Collectors.toSet());\n            if (!CollectionUtils.isNullOrEmpty(invalidPages)) {\n                throw new HandlingException(MessageFormat.format(\n                        \"The page indexes:[{0}] has exceeded the max page number of the pdf document.\",\n                        StringUtils.join(invalidPages, \",\")));\n            }\n\n            return source.read(pages.toArray(new Integer[0]), val);\n        } finally {\n            // Release resources when the pdf source is not-time.\n            if (disposable) {\n                release();\n            }\n        }\n    }\n\n\n    protected void checkReadiness() {\n        if (containsAll) {\n            return;\n        }\n        if (CollectionUtils.isNullOrEmpty(pages)) {\n            throw new HandlingException(\"No page indexes are registered.\");\n        }\n    }\n\n\n    private static void checkPageIndex(int pageIndex) {\n        if (pageIndex < 0) {\n            throw new InvalidSettingException(\"Page index must be greater than or equal to 0.\");\n        }\n    }\n\n    /**\n     * Release some resources when developer forget.\n     *\n     * @throws Throwable If some I/O exceptions occurred when closing resource.\n     */\n    @Override\n    protected void finalize() throws Throwable {\n        try {\n            if (source != null && !source.isClosed()) {\n                LOGGER.warning( \"Warning: You did not close a PDF Source.\" );\n                release();\n            }\n        } finally {\n            super.finalize();\n        }\n    }\n}\n"
    },
    {
        "detailed_description": "The public class InputStreamGifSource is a subclass of the abstract class AbstractGifSource, which is parameterized with the type InputStream. This class is designed to handle GIF sources that come from an InputStream. The constructor for this class takes an InputStream as an argument and passes it to the superclass constructor. The class overrides the doLoad method from the superclass, which is designed to load the GIF from the source. This method returns an integer, which is the result of reading the source with a decoder. This method can throw an IOException, which means that it must be used in a context where this exception is handled. This class is useful for working with GIFs that are loaded from an InputStream, such as a file or a network connection.\"",
        "sketchy_description": "The public class InputStreamGifSource, which extends the generic class AbstractGifSource with the type parameter of InputStream, is designed to facilitate the loading of GIF data from an InputStream. This functionality is particularly useful when dealing with GIF files that need to be read from a stream, such as when reading from a file, network, or any other source that can be represented as an InputStream.\n\nThe constructor of this class takes a single argument, an InputStream, which represents the source of the GIF data. Upon instantiation, the InputStreamGifSource object is initialized with this source, setting up the necessary state to begin the loading process.\n\nThe class includes a protected method, doLoad, which is responsible for actually loading the GIF data from the provided InputStream. This method is marked as protected, indicating that it is intended to be accessed within the class itself or by subclasses, rather than by external clients directly. The doLoad method throws an IOException, which is a signal to the caller that input/output operations may fail, and such failures must be properly handled. When called, doLoad performs the necessary operations to read the GIF data from the InputStream and returns an integer status code that indicates the result of the operation. This status code can be used to determine whether the loading was successful or if an error occurred during the process.",
        "file": "imglib/pipe/src/main/java/cn/pipe/in/gif/InputStreamGifSource.java",
        "class_name": "InputStreamGifSource",
        "repo_metadata": {
            "repo_name": "imglib"
        },
        "evaluation_metadata": {
            "test_class_name": "InputStreamGifSourceTest",
            "test_file": "imglib/pipe/src/test/java/cn/pipe/in/gif/InputStreamGifSourceTest.java"
        },
        "task_id": 43,
        "ground_truth_class_body": "package cn.pipe.in.gif;\n\nimport cn.pipe.in.AbstractGifSource;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * A gif source that from input stream.\n *\n * @author tracy\n * @since 0.2.1\n */\npublic class InputStreamGifSource extends AbstractGifSource<InputStream> {\n\n    public InputStreamGifSource(InputStream source) {\n        super(source);\n    }\n\n    @Override\n    protected int doLoad() throws IOException {\n        return decoder.read(source);\n    }\n}\n"
    },
    {
        "detailed_description": "The public class WriteParquetFiles implements the MapPartitionsFunction interface, which is designed to process data in a distributed computing environment. This class is specifically designed to write data to Parquet files, which are a type of columnar storage file format optimized for use with Apache Hadoop. \n\nThe class contains three private member variables: instancePropertiesStr, tablePropertiesStr, and serializableConf. The instancePropertiesStr and tablePropertiesStr are strings that hold the properties for the instance and table respectively. The serializableConf is a SerializableConfiguration object that holds the configuration for the process.\n\nThe constructor for this class takes three arguments: two strings for the instance and table properties, and a Configuration object for the process configuration. These values are used to initialize the member variables.\n\nThe class overrides the call method from the MapPartitionsFunction interface. This method takes an Iterator of Rows as an argument and returns an Iterator of Rows. Inside this method, it creates an InstanceProperties object and a TableProperties object, loads the properties from the strings, and then creates a new FileWritingIterator with these properties and the configuration. This method is designed to process the data in the Iterator of Rows and write it to a Parquet file.\"",
        "sketchy_description": "The public class WriteParquetFiles is designed to handle the conversion of Row data into Parquet file format within a distributed computing environment. It implements the MapPartitionsFunction interface, which allows it to process partitions of data in parallel. The class is equipped with a serialVersionUID for serialization purposes, ensuring that the class's definition is compatible with serialized objects.\n\nThe class contains instance variables that store configuration strings for instance and table properties, as well as a SerializableConfiguration object that wraps a Hadoop Configuration object. These variables are crucial for configuring the behavior of the Parquet file writing process.\n\nThe constructor of the WriteParquetFiles class takes three parameters: two strings representing instance and table properties, and a Hadoop Configuration object. The purpose of the constructor is to initialize the class with these parameters, setting up the necessary environment for writing Parquet files.\n\nThe call method is the core function of the class, which takes an Iterator of Rows as input. This method processes the input rows, writing them to Parquet files. It is designed to handle potential IOExceptions that may occur during the file writing process. After processing, the method returns an Iterator of Rows that have been successfully written to the Parquet files. This method is essential for integrating the class's functionality into a distributed data processing pipeline, where each partition of data can be handled independently and in parallel.",
        "file": "sleeper/java/bulk-import/bulk-import-runner/src/main/java/sleeper/bulkimport/job/runner/dataframe/WriteParquetFiles.java",
        "class_name": "WriteParquetFiles",
        "repo_metadata": {
            "repo_name": "sleeper"
        },
        "evaluation_metadata": {
            "test_class_name": "WriteParquetFilesTest",
            "test_file": "sleeper/java/bulk-import/bulk-import-runner/src/test/java/sleeper/bulkimport/job/runner/dataframe/WriteParquetFilesTest.java"
        },
        "task_id": 44,
        "ground_truth_class_body": "/*\n * Copyright 2022-2023 Crown Copyright\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage sleeper.bulkimport.job.runner.dataframe;\n\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.spark.api.java.function.MapPartitionsFunction;\nimport org.apache.spark.sql.Row;\nimport org.apache.spark.util.SerializableConfiguration;\n\nimport sleeper.configuration.properties.InstanceProperties;\nimport sleeper.configuration.properties.table.TableProperties;\n\nimport java.io.IOException;\nimport java.util.Iterator;\n\n/**\n * A {@link WriteParquetFiles} writes sorted Rows to a Parquet file. When it\n * comes across a {@link sleeper.core.record.Record} belonging to a different leaf partition\n * (denoted by the \"partitionId\" column), the Parquet file is flushed to the\n * file system along with its accompanying sketches file.\n */\npublic class WriteParquetFiles implements MapPartitionsFunction<Row, Row> {\n    private static final long serialVersionUID = 1873341639622053831L;\n\n    private final String instancePropertiesStr;\n    private final String tablePropertiesStr;\n    private final SerializableConfiguration serializableConf;\n\n    public WriteParquetFiles(String instancePropertiesStr, String tablePropertiesStr, Configuration conf) {\n        this.instancePropertiesStr = instancePropertiesStr;\n        this.tablePropertiesStr = tablePropertiesStr;\n        this.serializableConf = new SerializableConfiguration(conf);\n    }\n\n    @Override\n    public Iterator<Row> call(Iterator<Row> rowIter) throws IOException {\n        InstanceProperties instanceProperties = new InstanceProperties();\n        instanceProperties.loadFromString(instancePropertiesStr);\n\n        TableProperties tableProperties = new TableProperties(instanceProperties);\n        tableProperties.loadFromString(tablePropertiesStr);\n\n        return new FileWritingIterator(rowIter, instanceProperties, tableProperties, serializableConf.value());\n    }\n}\n"
    },
    {
        "detailed_description": "The public class CellResultSet is designed to handle and manipulate sets of cell results, typically from a spreadsheet or similar data structure. The class contains a private member, cellResultListList, which is a two-dimensional list of CellResult objects. This list represents a grid of cell results, where each row is a list of cell results and each cell result represents the value of a cell in a spreadsheet.\n\nThe class provides several static methods for creating instances of CellResultSet. The none() method creates an empty CellResultSet. The newInstance(List<List<CellResult>> cellResultListList) method creates a new CellResultSet with the provided two-dimensional list of cell results, after validating that all rows have the same number of columns. The firstCellResult(CellResult cellResult) method creates a new CellResultSet with a single cell result.\n\nThe class also provides several instance methods for interacting with the cell results. The getExcelType() method returns the type of the first cell result in the set. The isNone() method checks if the set is empty. The getFirstCellResult() method returns the first cell result in the set. The getFirstRowIndex() and getFirstColIndex() methods return the row and column indices of the first cell result in the set, respectively.\n\nThe class also contains a private static method, validated(List<List<CellResult>> cellResultListList), which checks that all rows in the provided two-dimensional list have the same number of columns and throws an exception if they do not. This method is used to ensure that the cell results can be correctly represented as a grid.\"",
        "sketchy_description": "The public class CellResultSet is designed to encapsulate the results of cell operations within a structured format, specifically for use in contexts where cell operations are performed, such as in spreadsheet applications. The class contains a field, `cellResultListList`, which is a two-dimensional list that represents the rows and columns of cell results, effectively modeling a grid of results.\n\nThe class provides several static methods for creating instances of CellResultSet in different states. The `none` method creates an empty CellResultSet, indicating that there are no cell results to encapsulate. The `newInstance` method allows for the creation of a CellResultSet with a pre-defined two-dimensional list of cell results, enabling the encapsulation of an existing grid of results. The `firstCellResult` method creates a CellResultSet that contains a single cell result, which can be useful for operations that focus on individual cells.\n\nAdditionally, the class includes a private static method, `validated`, which is used internally to ensure that the provided two-dimensional list of cell results is valid, meaning that all rows have the same number of columns. This is important for maintaining the integrity of the grid structure within the CellResultSet.\n\nThe `getExcelType` method returns the ExcelType of the first cell result, which can be useful for determining the type of data contained within the cell results without having to inspect each one individually. The `isNone` method checks if the CellResultSet is empty, which is a quick way to determine if any cell results are present.\n\nFurthermore, the class provides methods to retrieve specific information about the cell results. The `getFirstCellResult` method retrieves the first cell result from the result set, which can be useful when only the initial result is of interest. The `getFirstRowIndex` and `getFirstColIndex` methods provide the row and column indices of the first cell result, respectively, allowing for positional information to be obtained easily.\n\nOverall, the CellResultSet class and its methods offer a convenient way to manage and interact with a collection of cell results, providing both creation and retrieval functionalities that are essential for spreadsheet-related operations.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/metadata/result/CellResultSet.java",
        "class_name": "CellResultSet",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "CellResultSetTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/metadata/result/CellResultSetTest.java"
        },
        "task_id": 45,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.metadata.result;\n\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.exceptions.ExcelException;\nimport lombok.EqualsAndHashCode;\nimport lombok.Getter;\nimport lombok.ToString;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * \u591a\u4e2a\u5355\u5143\u683c\u503c\u8bfb\u53d6\u7ed3\u679c\n * \u4e3a\u8de8\u884c\u8de8\u5217\u6570\u636e\u8bfb\u53d6\u63d0\u4f9b\u652f\u6301\n * * @author zouzhiy\n *\n * @since 2022/7/2\n */\n@ToString\n@EqualsAndHashCode\npublic class CellResultSet {\n\n    /**\n     * List<\u6bcf\u4e00\u884c\u7684\u503cList<\u540c\u4e00\u884c\u4e0b\u4e0d\u540c\u5217\u7684\u503c>>\n     * row1col1, row2col2\n     * row2col1, row2cole2\n     * <p>\n     * \u6bcf\u4e00\u884c\u7684col\u6570\u91cf\u5fc5\u987b\u4e00\u81f4\n     */\n    @Getter\n    List<List<CellResult>> cellResultListList;\n\n    /**\n     * \u7a7a\u503c\n     *\n     * @return list\u957f\u5ea6\u4e3a0\n     */\n    public static CellResultSet none() {\n        CellResultSet cellResultSet = new CellResultSet();\n        cellResultSet.cellResultListList = Collections.emptyList();\n        return cellResultSet;\n    }\n\n    /**\n     * \u76f4\u63a5\u521b\u5efa\u65b0\u5bf9\u8c61\n     *\n     * @param cellResultListList \u5355\u5143\u683c\u7ed3\u679c\u4e8c\u7ef4\u5217\u8868\n     * @return \u591a\u4e2a\u5355\u5143\u683c\u503c\u8bfb\u53d6\u7ed3\u679c\n     */\n    public static CellResultSet newInstance(List<List<CellResult>> cellResultListList) {\n        CellResultSet.validated(cellResultListList);\n        CellResultSet cellResultSet = new CellResultSet();\n        cellResultSet.cellResultListList = cellResultListList;\n        return cellResultSet;\n    }\n\n    /**\n     * \u4e00\u822c\u60c5\u51b5\u4e0b\u7684\u7ed3\u679c\uff0c\u4e0d\u5b58\u5728\u5408\u5e76\u5355\u5143\u683c\u3002\u5219\u53ea\u6709\u4e00\u884c\u4e00\u5217\n     *\n     * @param cellResult \u5355\u4e2a\u5355\u5143\u683c\u503c\n     * @return \u5305\u88c5\u540e\u7684\u591a\u4e2a\u7ed3\u679c\u503c\n     */\n    public static CellResultSet firstCellResult(CellResult cellResult) {\n        CellResultSet cellResultSet = new CellResultSet();\n        List<List<CellResult>> cellResultListList = new ArrayList<>(1);\n        List<CellResult> cellResultList = new ArrayList<>(1);\n        cellResultList.add(cellResult);\n        cellResultListList.add(cellResultList);\n        cellResultSet.cellResultListList = cellResultListList;\n\n        return cellResultSet;\n    }\n\n\n    /**\n     * \u6821\u9a8c\u7ed3\u679c\u96c6\u662f\u5426\u5408\u6cd5\n     * \u6bcf\u4e00\u4e2arow\u7684col\u8981\u76f8\u7b49\n     */\n    private static void validated(List<List<CellResult>> cellResultListList) {\n        Integer preSize = null;\n        for (List<CellResult> cellResultList : cellResultListList) {\n            int size = cellResultList.size();\n            if (preSize == null) {\n                preSize = size;\n            } else if (preSize != size) {\n                throw new ExcelException(\"cellResultListList \u6570\u636e\u4e0d\u7b26\u5408\u9884\u671f\");\n            }\n        }\n    }\n\n    /**\n     * \u8fd4\u56de\u7ed3\u679c\u96c6\u7684\u5355\u5143\u683c\u7c7b\u578b\u3002\n     * \u4ee5\u7b2c\u4e00\u4e2a\u5355\u5143\u683c\u7c7b\u578b\u4e3a\u51c6\u3002\n     *\n     * @return \u5355\u5143\u683c\u7c7b\u578b\n     */\n    public ExcelType getExcelType() {\n        return this.getFirstCellResult().getExcelType();\n    }\n\n    /**\n     * \u7ed3\u679c\u4e3a\u7a7a \u5bf9\u5e94\u7684\u662f\u5355\u5143\u683c\u4e3anull\n     *\n     * @return \u662f\u5426\u4e3a\u7a7a\n     */\n    public boolean isNone() {\n        if (cellResultListList == null || cellResultListList.isEmpty()) {\n            return true;\n        }\n        for (List<CellResult> cellResultList : cellResultListList) {\n            if (cellResultList != null && !cellResultList.isEmpty()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * \u83b7\u53d6\u7ed3\u679c\u96c6\u7684\u7b2c\u4e00\u4e2a\u5355\u5143\u683c\u503c\u3002\n     * \u82e5\u6570\u636e\u4e0d\u8de8\u884c\u8de8\u5217\uff0c\u5219\u6b64\u7ed3\u679c\u5373\u4e3a\u5b9e\u9645\u7684\u8bfb\u53d6\u503c\n     *\n     * @return \u5355\u5143\u683c\u503c\n     */\n    public CellResult getFirstCellResult() {\n        if (cellResultListList == null || cellResultListList.isEmpty()) {\n            throw new ExcelException(\"cellResultListList \u7a7a\");\n        }\n        List<CellResult> cellResultList = cellResultListList.get(0);\n        if (cellResultList == null || cellResultList.isEmpty()) {\n            throw new ExcelException(\"cellResultListList \u7a7a\");\n        }\n\n        return cellResultList.get(0);\n    }\n\n    /**\n     * \u83b7\u53d6\u7ed3\u679c\u96c6\u4e2d\u7684\u7b2c\u4e00\u4e2a\u5355\u5143\u683c\u884c\u4e0b\u6807\n     *\n     * @return \u7b2c\u4e00\u4e2a\u5355\u5143\u683c\u884c\u4e0b\u6807\n     */\n    public int getFirstRowIndex() {\n        if (cellResultListList == null || cellResultListList.isEmpty()) {\n            return -1;\n        }\n        List<CellResult> cellResultList = cellResultListList.get(0);\n        if (cellResultList == null || cellResultList.isEmpty()) {\n            return -1;\n        }\n\n        return cellResultList.get(0).getRowIndex();\n    }\n\n    /**\n     * \u83b7\u53d6\u7ed3\u679c\u96c6\u4e2d\u7684\u7b2c\u4e00\u4e2a\u5355\u5143\u683c\u5217\u4e0b\u6807\n     *\n     * @return \u7b2c\u4e00\u4e2a\u5355\u5143\u683c\u5217\u4e0b\u6807\n     */\n    public int getFirstColIndex() {\n        if (cellResultListList == null || cellResultListList.isEmpty()) {\n            return -1;\n        }\n        List<CellResult> cellResultList = cellResultListList.get(0);\n        if (cellResultList == null || cellResultList.isEmpty()) {\n            return -1;\n        }\n\n        return cellResultList.get(0).getColumnIndex();\n    }\n\n}\n"
    },
    {
        "detailed_description": "The public class ByteBooleanHandler is a subclass of the AbstractByteCellHandler class. This class is designed to handle byte and boolean values in the context of Excel cells. It contains a private static final byte variable TRUE_VALUE, which is set to 1. This class overrides two methods from its superclass. \n\nThe first overridden method is setCellValue. This method takes four parameters: a RowContext object, an ExcelFieldConfig object, a Cell object, and a Byte value. The method sets the value of the cell to true if the Byte value is equal to TRUE_VALUE (1), and false otherwise. \n\nThe second overridden method is getExcelType. This method does not take any parameters and returns an ExcelType enumeration value. Specifically, it returns ExcelType.BOOLEAN, indicating that the type of Excel cell this handler is designed for is a boolean type.\"",
        "sketchy_description": "The public class ByteBooleanHandler, which extends the AbstractByteCellHandler, is specifically designed to manage the conversion between byte values and boolean cell values within Excel spreadsheets. This class includes a class variable, TRUE_VALUE, which is a byte representation of the boolean value true.\n\nThe class provides a protected method setCellValue, which takes a RowContext, an ExcelFieldConfig, a Cell, and a Byte value as parameters. This method is responsible for setting the cell's value in an Excel spreadsheet to true or false. The determination of the cell's boolean value is based on whether the provided byte value is equivalent to the predefined TRUE_VALUE. If the byte value matches TRUE_VALUE, the cell is set to true; otherwise, it is set to false.\n\nAdditionally, the class offers a public method getExcelType, which returns the ExcelType enumeration value corresponding to boolean types. This method is useful for identifying the data type that the handler is dealing with, particularly when working with Excel's data type system.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/bytes/ByteBooleanHandler.java",
        "class_name": "ByteBooleanHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "ByteBooleanHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/ByteBooleanHandlerTest.java"
        },
        "task_id": 46,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.bytes;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport org.apache.poi.ss.usermodel.Cell;\n\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class ByteBooleanHandler extends AbstractByteCellHandler {\n\n    private static final Byte TRUE_VALUE = (byte) 1;\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, Byte value) {\n        cell.setCellValue(value.compareTo(TRUE_VALUE) == 0);\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.BOOLEAN;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class ContainerComponent is a complex class that implements the Styled and Grid interfaces. This class is designed to handle the styling and grid layout of a container component in a web application. \n\nThe class has several private fields, including a ResourceResolver object, three Strings for different sizes of background images, a DefaultStyledComponent object, a DefaultGridComponent object, and an array of Strings for component classes. \n\nThe ResourceResolver object is used to resolve resources in a flexible and extensible way. The three Strings for background images are used to store the URLs of the background images for small, medium, and large screens. The DefaultStyledComponent and DefaultGridComponent objects are used to handle the styling and grid layout of the container component. The array of Strings for component classes is used to store the CSS classes of the container component.\n\nThe class provides three public methods to get the URLs of the background images for different screen sizes. These methods call a private method that checks if the image URL is empty and returns a default value if it is, or formats the URL and returns it if it's not.\n\nThe class also provides a method to get the CSS classes of the container component. This method is overridden from the Styled interface.\n\nThe class has a private method that is annotated with @PostConstruct, which means it is called after the class is instantiated and dependency injection has been performed. This method initializes the array of component classes by combining the CSS classes of the styled component and the grid component.\n\nThe class also has two fields that are annotated with @Self, which means they are injected with the current class instance. One of these fields is also annotated with @Delegate, which means it delegates method calls to the injected object.\"",
        "sketchy_description": "The public class ContainerComponent is designed to function as a container for UI components, with the added capabilities of styling and grid layout management, as it implements the Styled and Grid interfaces. The class defines constants for default background values, including a pattern for constructing background image URLs.\n\nThe class provides several public methods to retrieve background images of different sizes, specifically small, medium, and large. These methods process the provided image URLs and return them in a format suitable for use as a background image in a web page or application interface.\n\nAdditionally, there is a private method getBackgroundImage that takes a string representing an image and processes it to return a URL formatted string. If the input string is empty, it returns the value 'none', indicating no background image.\n\nThe getClasses method is a public method that returns an array of strings representing the CSS classes that have been applied to the container component. This allows for easy retrieval and manipulation of the component's styling classes.\n\nLastly, the private init method is responsible for initializing the component's classes by combining the styles and grid classes necessary for the component's layout and appearance. This method is typically called internally to set up the component's initial state.",
        "file": "howlite/core/src/main/java/pl/ds/howlite/components/models/ContainerComponent.java",
        "class_name": "ContainerComponent",
        "repo_metadata": {
            "repo_name": "howlite"
        },
        "evaluation_metadata": {
            "test_class_name": "ContainerComponentTest",
            "test_file": "howlite/core/src/test/java/pl/ds/howlite/components/models/ContainerComponentTest.java"
        },
        "task_id": 47,
        "ground_truth_class_body": "/*\n * Copyright (C) 2022 Dynamic Solutions\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage pl.ds.howlite.components.models;\n\nimport static org.apache.sling.models.annotations.DefaultInjectionStrategy.OPTIONAL;\n\nimport java.util.Arrays;\nimport java.util.LinkedHashSet;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport javax.annotation.PostConstruct;\nimport javax.inject.Inject;\nimport lombok.Getter;\nimport lombok.experimental.Delegate;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.sling.api.resource.Resource;\nimport org.apache.sling.api.resource.ResourceResolver;\nimport org.apache.sling.models.annotations.Default;\nimport org.apache.sling.models.annotations.Model;\nimport org.apache.sling.models.annotations.injectorspecific.Self;\nimport org.apache.sling.models.annotations.injectorspecific.SlingObject;\nimport pl.ds.howlite.components.Grid;\nimport pl.ds.howlite.components.Styled;\nimport pl.ds.howlite.components.utils.GridDisplayType;\nimport pl.ds.howlite.components.utils.GridStyle;\nimport pl.ds.howlite.components.utils.LinkUtil;\n\n@Slf4j\n@Model(adaptables = Resource.class, defaultInjectionStrategy = OPTIONAL)\npublic class ContainerComponent implements Styled, Grid {\n\n  private static final String BACKGROUND_NONE = \"none\";\n  private static final String BACKGROUND_URL_PATTERN = \"url(\\\"%s\\\")\";\n\n  @SlingObject\n  private ResourceResolver resourceResolver;\n\n  @Inject\n  private String backgroundImageSm;\n\n  @Inject\n  private String backgroundImageMd;\n\n  @Inject\n  private String backgroundImageLg;\n\n  public String getBackgroundImageSm() {\n    return getBackgroundImage(backgroundImageSm);\n  }\n\n  public String getBackgroundImageMd() {\n    return getBackgroundImage(backgroundImageMd);\n  }\n\n  public String getBackgroundImageLg() {\n    return getBackgroundImage(backgroundImageLg);\n  }\n\n  private String getBackgroundImage(String image) {\n    if (StringUtils.isEmpty(image)) {\n      return BACKGROUND_NONE;\n    }\n\n    return String.format(BACKGROUND_URL_PATTERN, LinkUtil.handleLink(image, resourceResolver));\n  }\n\n  @Self\n  private DefaultStyledComponent style;\n\n  @Self\n  @Delegate\n  private DefaultGridComponent grid;\n\n  private String[] componentClasses;\n\n  @Override\n  public String[] getClasses() {\n    return componentClasses;\n  }\n\n  @PostConstruct\n  private void init() {\n    componentClasses = Stream.concat(\n            Arrays.stream(style.getClasses()),\n            new GridStyle(this, GridDisplayType.GRID).getClasses().stream())\n        .collect(Collectors.toCollection(LinkedHashSet::new))\n        .toArray(new String[]{});\n  }\n\n}\n"
    },
    {
        "detailed_description": "The public class ShortBooleanHandler is a subclass of the AbstractShortCellHandler class. This class is designed to handle short boolean values in Excel cells. It contains a private static final Short variable named TRUE_VALUE, which is set to 1. This variable represents the boolean value of true in the context of this class.\n\nThe class overrides two methods from its superclass. The first method, setCellValue, takes four parameters: a RowContext object, an ExcelFieldConfig object, a Cell object, and a Short value. This method is responsible for setting the value of a specific cell in an Excel row. It does this by comparing the provided Short value to the TRUE_VALUE. If the Short value is equal to the TRUE_VALUE, the cell's value is set to true; otherwise, it is set to false.\n\nThe second method that is overridden is getExcelType. This method does not take any parameters and returns an ExcelType enumeration. Specifically, it returns ExcelType.BOOLEAN, indicating that this handler is used for boolean values in Excel.\"",
        "sketchy_description": "The public class ShortBooleanHandler, which extends AbstractShortCellHandler, is designed to handle the conversion of short numerical values to boolean values within Excel cells. This is particularly useful when dealing with Excel spreadsheets that represent boolean data as short integers, where a specific value (in this case, the constant TRUE_VALUE which is set to 1) is interpreted as true, and any other value is interpreted as false.\n\nThe class contains a protected method setCellValue, which takes a RowContext, an ExcelFieldConfig, a Cell, and a Short value as parameters. This method is responsible for setting the cell's value within an Excel spreadsheet. If the short value passed to the method is equal to the predefined TRUE_VALUE, the cell's value is set to true; otherwise, it is set to false. This method ensures that the boolean representation in the Excel cell accurately reflects the short value provided.\n\nAdditionally, the class provides a public method getExcelType, which returns the ExcelType enumeration value corresponding to a boolean. This method allows users or other parts of the system to understand the type of data that the handler deals with, which in this case is boolean values. This can be useful for ensuring that data is processed and interpreted correctly within the context of Excel spreadsheets.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/shorts/ShortBooleanHandler.java",
        "class_name": "ShortBooleanHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "ShortBooleanHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/ShortBooleanHandlerTest.java"
        },
        "task_id": 48,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.shorts;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport org.apache.poi.ss.usermodel.Cell;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class ShortBooleanHandler extends AbstractShortCellHandler {\n\n    private final static Short TRUE_VALUE = 1;\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, Short value) {\n        cell.setCellValue(value.compareTo(TRUE_VALUE) == 0);\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.BOOLEAN;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class ByteArrayGifSource is a subclass of the AbstractGifSource class, with a generic type of byte array. This class is designed to handle GIF sources that are represented as byte arrays. The constructor for this class takes a byte array as an argument, which represents the source of the GIF, and passes it to the superclass constructor. The class overrides the doLoad method from the superclass, which is designed to load the GIF source. In this implementation, the method creates a new ByteArrayInputStream from the source byte array and passes it to the read method of the decoder object. This method returns an integer, which is typically used to indicate the status of the operation. If an IOException occurs during the loading process, it is thrown to the caller of the method.\"",
        "sketchy_description": "The public class ByteArrayGifSource, which extends the AbstractGifSource class, is specifically designed to handle GIF data that is stored within a byte array. This class is tailored to work with GIF images by providing the necessary functionality to manage and process GIF data that is represented as a byte array. The constructor of this class accepts a single argument, which is the byte array containing the GIF data, and it initializes the ByteArrayGifSource object with this data as its source.\n\nOnce an instance of ByteArrayGifSource is created, it has a protected method named doLoad, which is responsible for loading the GIF data from the byte array. This method is crucial for the functionality of the class as it processes the byte array to extract and prepare the GIF data for use. The doLoad method may throw an IOException, which is a signal to the caller that an input or output operation has failed or been interrupted. The method returns an integer status code that indicates the result of the loading operation, allowing the caller to determine whether the operation was successful or if there were any issues that need to be addressed.",
        "file": "imglib/pipe/src/main/java/cn/pipe/in/gif/ByteArrayGifSource.java",
        "class_name": "ByteArrayGifSource",
        "repo_metadata": {
            "repo_name": "imglib"
        },
        "evaluation_metadata": {
            "test_class_name": "ByteArrayGifSourceTest",
            "test_file": "imglib/pipe/src/test/java/cn/pipe/in/gif/ByteArrayGifSourceTest.java"
        },
        "task_id": 49,
        "ground_truth_class_body": "package cn.pipe.in.gif;\n\nimport cn.pipe.in.AbstractGifSource;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\n\n/**\n * A gif source that from byte array.\n *\n * @author tracy\n * @since 0.2.1\n */\npublic class ByteArrayGifSource extends AbstractGifSource<byte[]> {\n\n    public ByteArrayGifSource(byte[] source) {\n        super(source);\n    }\n\n    @Override\n    protected int doLoad() throws IOException {\n        return decoder.read(new ByteArrayInputStream(source));\n    }\n}\n"
    },
    {
        "detailed_description": "The public class LongStringHandler is a specialized class that extends the AbstractLongCellHandler class. This class is designed to handle long strings in Excel cells. It overrides two methods from its superclass. \n\nThe first overridden method is setCellValue. This method is designed to set the value of a cell in an Excel row. It takes four parameters: a RowContext object, an ExcelFieldConfig object, a Cell object, and a Long value. Inside this method, it first retrieves the Java format for the Excel field configuration using the getJavaFormat method. Then, it formats the Long value into a string using the ExcelNumberUtils.format method, which takes the Long value and the Java format as parameters. Finally, it sets the cell's value to the formatted string using the setCellValue method of the Cell object.\n\nThe second overridden method is getExcelType. This method returns the ExcelType of the cell, which in this case is always ExcelType.STRING. This indicates that the cell is expected to contain a string value. This method does not take any parameters and is used to ensure that the cell's value is being correctly interpreted as a string.\"",
        "sketchy_description": "The public class LongStringHandler, which extends the AbstractLongCellHandler, is specifically designed to manage the conversion of long integer values into string representations for use in Excel cells. This functionality is particularly useful when dealing with large numbers that need to be formatted and displayed as text within an Excel spreadsheet.\n\nThe class provides a protected method setCellValue, which takes a RowContext, an ExcelFieldConfig, a Cell, and a Long value as parameters. This method is responsible for taking the long integer value and converting it into a string based on a specified Java format. The formatted string is then set as the value of the provided Excel cell. This method is crucial for ensuring that long values are represented correctly and legibly when exported to an Excel file.\n\nAdditionally, the class includes a public method getExcelType, which returns the enum ExcelType.STRING. This indicates that the LongStringHandler is associated with handling string values within Excel. This method is important for the system to understand the type of data the handler is dealing with, ensuring that the data is processed and formatted appropriately for string representation in Excel cells.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/longs/LongStringHandler.java",
        "class_name": "LongStringHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "LongStringHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/LongStringHandlerTest.java"
        },
        "task_id": 50,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.longs;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport io.github.zouzhiy.excel.utils.ExcelNumberUtils;\nimport org.apache.poi.ss.usermodel.Cell;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class LongStringHandler extends AbstractLongCellHandler {\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, Long value) {\n        String javaFormat = this.getJavaFormat(excelFieldConfig);\n        String strValue = ExcelNumberUtils.format(value, javaFormat);\n        cell.setCellValue(strValue);\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.STRING;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class ShortStringHandler is a specialized class that extends the AbstractShortCellHandler class. This class is designed to handle short strings in Excel cells. It overrides two methods from its superclass. \n\nThe first overridden method is setCellValue. This method is designed to set the value of a cell in an Excel row. It takes four parameters: a RowContext object that represents the current row, an ExcelFieldConfig object that contains configuration information for the Excel field, a Cell object that represents the cell to be modified, and a Short value that represents the value to be set in the cell. Inside this method, it first gets the Java format from the ExcelFieldConfig object. Then, it formats the Short value into a string using the ExcelNumberUtils.format method and the obtained Java format. Finally, it sets the cell's value to the formatted string.\n\nThe second overridden method is getExcelType. This method returns the ExcelType of the cell, which in this case is always ExcelType.STRING. This indicates that the cells handled by this class are always expected to contain string values.\"",
        "sketchy_description": "The public class ShortStringHandler, which extends the AbstractShortCellHandler, is designed to handle the conversion of short numerical values into string representations specifically for use within Excel cells. This class is particularly useful when dealing with Excel spreadsheets where short numerical values need to be displayed as text.\n\nThe class provides a protected method setCellValue, which takes a RowContext, an ExcelFieldConfig, a Cell, and a Short value as parameters. This method is responsible for setting the value of an Excel cell as a formatted string. The formatting is determined by the ExcelFieldConfig provided, which allows for customization of how the short value is converted to a string within the Excel cell.\n\nAdditionally, the class includes a public method getExcelType, which returns the ExcelType.STRING. This indicates that the handler is specifically dealing with string values within Excel. This method is useful for identifying the type of data that the handler is expected to process and can be used to ensure that the handler is used in the correct context within the Excel spreadsheet handling framework.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/shorts/ShortStringHandler.java",
        "class_name": "ShortStringHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "ShortStringHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/ShortStringHandlerTest.java"
        },
        "task_id": 51,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.shorts;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport io.github.zouzhiy.excel.utils.ExcelNumberUtils;\nimport org.apache.poi.ss.usermodel.Cell;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class ShortStringHandler extends AbstractShortCellHandler {\n\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, Short value) {\n        String javaFormat = this.getJavaFormat(excelFieldConfig);\n        String strValue = ExcelNumberUtils.format(value, javaFormat);\n        cell.setCellValue(strValue);\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.STRING;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class ImageFileCellHandler is a subclass of the AbstractImageCellHandler class, with the generic type parameter set to File. This class is designed to handle image files in an Excel spreadsheet. It overrides three methods from its superclass. \n\nThe first overridden method, getCellValue, takes three parameters: a SheetContext object, an ExcelFieldConfig object, and a CellResult object. This method is designed to return the value of a cell in the spreadsheet, which in this case is a File object. However, in this implementation, it always returns null.\n\nThe second overridden method, toImageUrlResource, takes three parameters: a RowContext object, an ExcelFieldConfig object, and a File object. This method is designed to convert the File object into a byte array that represents the image URL resource. It does this by creating a FileInputStream from the File object and then converting this stream into a byte array using the IOUtils.toByteArray method. If an IOException occurs during this process, it throws an ExcelException with a message indicating that the image could not be read.\n\nThe third overridden method, getExcelType, does not take any parameters and returns an ExcelType enumeration. In this implementation, it always returns ExcelType.NONE, indicating that no specific Excel type is associated with this handler.\"",
        "sketchy_description": "The public class ImageFileCellHandler, which extends AbstractImageCellHandler with a generic type of File, is designed to manage the representation and processing of image files within cells of an Excel spreadsheet. The class provides specialized methods to handle image files, ensuring that they are correctly processed when working with Excel documents.\n\nThe protected method getCellValue takes a SheetContext, an ExcelFieldConfig, and a CellResult as parameters and is responsible for retrieving the value of a cell that contains an image file within an Excel sheet. The current implementation of this method returns null, indicating that it serves as a placeholder and should be overridden with a specific implementation as required by the use case.\n\nAnother protected method, toImageUrlResource, accepts a RowContext, an ExcelFieldConfig, and a File object. This method is tasked with converting the provided File object into a byte array that represents the image URL resource. If the process of reading the image encounters any issues, the method is designed to throw an ExcelException, signaling that an error has occurred during the conversion.\n\nLastly, the public final method getExcelType returns the ExcelType associated with this handler. In this case, the method returns ExcelType.NONE, which indicates that this handler is not associated with a specific Excel type. This could imply that the handler is meant to be used in a more generic context or that the Excel type is determined dynamically at runtime.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/image/ImageFileCellHandler.java",
        "class_name": "ImageFileCellHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "ImageFileCellHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/old/handler/image/ImageFileCellHandlerTest.java"
        },
        "task_id": 52,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.image;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.context.SheetContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.exceptions.ExcelException;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport io.github.zouzhiy.excel.metadata.result.CellResult;\nimport org.apache.commons.io.IOUtils;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class ImageFileCellHandler extends AbstractImageCellHandler<File> {\n\n    @Override\n    protected File getCellValue(SheetContext sheetContext, ExcelFieldConfig excelFieldConfig, CellResult firstCellResult) {\n        return null;\n    }\n\n    @Override\n    protected byte[] toImageUrlResource(RowContext rowContext, ExcelFieldConfig excelFieldConfig, File value) {\n        try {\n            return IOUtils.toByteArray(new FileInputStream(value));\n        } catch (IOException e) {\n            throw new ExcelException(\"\u8bfb\u53d6\u56fe\u7247\u5931\u8d25\");\n        }\n    }\n\n    @Override\n    public final ExcelType getExcelType() {\n        return ExcelType.NONE;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class Java8MpscLinkedQueue is a generic class that extends the MpscLinkedQueue class. This class is designed to implement a multi-producer, single-consumer (MPSC) linked queue, which is a type of data structure that allows multiple threads to add elements to the queue, but only one thread to remove elements. \n\nThe class contains a private static final member, PRODUCER_NODE, which is an AtomicReferenceFieldUpdater. This is used to atomically update the producer node of the queue, ensuring thread safety in a multi-threaded environment. The AtomicReferenceFieldUpdater is initialized in a static block, where it is set to update the 'producerNode' field of the MpscLinkedQueue class.\n\nThe class overrides two methods from the MpscLinkedQueue class: newNode and getAndSetProducerNodeRelease. \n\nThe newNode method is used to create a new node in the queue. It takes a generic argument 'value' and returns a new instance of the Java8LinkedNode class, initialized with the given value.\n\nThe getAndSetProducerNodeRelease method is used to atomically set the producer node of the queue to a new node, and return the old node. It takes a LinkedNode argument 'nextNode', which is the new node to be set as the producer node. The method uses the PRODUCER_NODE AtomicReferenceFieldUpdater to perform the get-and-set operation atomically, ensuring thread safety.\"",
        "sketchy_description": "The public class Java8MpscLinkedQueue, which is a generic class extending MpscLinkedQueue, is tailored with enhancements that leverage features specific to Java 8. The class includes a static variable PRODUCER_NODE, which is initialized in a static block using an AtomicReferenceFieldUpdater to ensure thread-safe lazy initialization and updates to the producer node reference in a lock-free manner.\n\nThe class provides a protected method, newNode, which takes a generic value and creates a new LinkedNode instance that is specific to the Java 8 implementation of the queue. This method is essential for adding new elements to the queue in a manner that is optimized for Java 8's capabilities.\n\nAnother protected method, getAndSetProducerNodeRelease, is designed to atomically update the producer node reference to a new node passed as the nextNode argument. This method is crucial for maintaining the correct order of elements in the queue while ensuring that the updates to the producer node are visible to other threads in a concurrent environment. The method returns the updated node, allowing further operations to be performed based on the new state of the producer node.",
        "file": "dongting/client/src/main/java/com/github/dtprj/dongting/java8/Java8MpscLinkedQueue.java",
        "class_name": "MpscLinkedQueue",
        "repo_metadata": {
            "repo_name": "dongting"
        },
        "evaluation_metadata": {
            "test_class_name": "MpscLinkedQueueTest",
            "test_file": "dongting/client-java11/src/test/java/com/github/dtprj/dongting/java11/Java8MpscLinkedQueueTest.java"
        },
        "task_id": 53,
        "ground_truth_class_body": "/*\n * Copyright The Dongting Project\n *\n * The Dongting Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage com.github.dtprj.dongting.java8;\n\nimport com.github.dtprj.dongting.queue.LinkedNode;\nimport com.github.dtprj.dongting.queue.MpscLinkedQueue;\n\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n\n/**\n * @author huangli\n */\npublic class Java8MpscLinkedQueue<E> extends MpscLinkedQueue<E> {\n\n\n    @SuppressWarnings(\"rawtypes\")\n    private static final AtomicReferenceFieldUpdater<MpscLinkedQueue, LinkedNode> PRODUCER_NODE;\n\n    static {\n        PRODUCER_NODE = AtomicReferenceFieldUpdater.newUpdater(MpscLinkedQueue.class, LinkedNode.class, \"producerNode\");\n    }\n\n\n    @Override\n    protected LinkedNode<E> newNode(E value) {\n        return new Java8LinkedNode<>(value);\n    }\n\n    @Override\n    protected LinkedNode<E> getAndSetProducerNodeRelease(LinkedNode<E> nextNode) {\n        //noinspection unchecked\n        return (LinkedNode<E>) PRODUCER_NODE.getAndSet(this, nextNode);\n    }\n}\n"
    },
    {
        "detailed_description": "The public class LocalTimeStringHandler is a subclass of the AbstractLocalTimeCellHandler class. This class is designed to handle the conversion of LocalTime objects into string representations that can be stored in an Excel cell. \n\nThe class overrides three methods from its superclass. The first method, setCellValue, is responsible for setting the value of a cell in an Excel row. It takes four arguments: a RowContext object, an ExcelFieldConfig object, a Cell object, and a LocalTime object. The method first retrieves the Java format string from the ExcelFieldConfig object, then formats the LocalTime object into a string using this format. The formatted string is then set as the value of the Cell object.\n\nThe second method, getExcelType, is a simple getter method that returns the ExcelType of the handler, which in this case is ExcelType.STRING. This indicates that the handler is designed to handle string values.\n\nThe third method, getDefaultJavaFormat, is another getter method that returns the default Java format string for the handler. This format string is used to format LocalTime objects into strings. In this case, the default format is \"HH:mm:ss\", which represents hours, minutes, and seconds.\"",
        "sketchy_description": "The public class LocalTimeStringHandler, which extends AbstractLocalTimeCellHandler, is specialized in formatting LocalTime values for representation in Excel cells as strings. This class provides a method setCellValue, which is protected and takes a RowContext, an ExcelFieldConfig, a Cell, and a LocalTime value as parameters. The purpose of this method is to format the LocalTime value according to a specified Java format and set it as the value of the given cell. This is particularly useful when dealing with Excel spreadsheets that require time data to be displayed in a specific string format.\n\nAdditionally, the class offers a public method getExcelType, which returns the ExcelType.STRING, indicating that this handler deals with string representations of cell values in Excel. This method is important for ensuring that the cell values are treated correctly when being processed by Excel-related operations.\n\nLastly, the class provides a public method getDefaultJavaFormat, which returns the default Java format string for LocalTime values, specified as \"HH:mm:ss\". This default format is used to represent time values in a standard way, which can be particularly helpful when no custom format is specified and a consistent time representation is needed across different parts of the application or in different Excel documents.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/localtime/LocalTimeStringHandler.java",
        "class_name": "LocalTimeStringHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "LocalTimeStringHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/LocalTimeStringHandlerTest.java"
        },
        "task_id": 54,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.localtime;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport io.github.zouzhiy.excel.utils.ExcelDateFormatUtils;\nimport org.apache.poi.ss.usermodel.Cell;\n\nimport java.time.LocalTime;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class LocalTimeStringHandler extends AbstractLocalTimeCellHandler {\n\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, LocalTime value) {\n        String javaFormat = this.getJavaFormat(excelFieldConfig);\n        String strValue = ExcelDateFormatUtils.format(value, javaFormat);\n        cell.setCellValue(strValue);\n    }\n\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.STRING;\n    }\n\n    @Override\n    public String getDefaultJavaFormat() {\n        return \"HH:mm:ss\";\n    }\n\n}\n"
    },
    {
        "detailed_description": "The public class ImageSourceBuilder<S> extends the AbstractSourceBuilder class with a generic type parameter S. This class is designed to build an image source from a collection of buffered image sources. \n\nThe class has two protected fields. The first one, useOriginalFormat, is a boolean that indicates whether to use the original format of the image sources. The second one, sources, is an iterable collection of BufferedImageSource objects of type S. \n\nThe constructor of this class takes an iterable of BufferedImageSource objects as an argument and assigns it to the sources field. \n\nThe class overrides the obtainSourceImages method from the AbstractSourceBuilder class. This method is designed to read the images from the sources, store them in a list, and return this list. If the useOriginalFormat field is set to true, the method also checks the original format of the images and throws an exception if no format is available or if multiple formats are found. \n\nThe class also provides a public method useOriginalFormat, which sets the useOriginalFormat field to true and returns the current instance of the ImageSourceBuilder. This method is used to enable the use of the original format of the image sources.\"",
        "sketchy_description": "The public class ImageSourceBuilder, which is a generic class parameterized by `<S>` and extends the class AbstractSourceBuilder with a type of ImageSourceBuilder<S>, is designed to facilitate the construction of an image source. This class is part of a builder pattern, which is a design pattern that provides a flexible solution to various object creation problems in object-oriented programming. The class contains a constructor that takes an Iterable of BufferedImageSource<S> objects, which represents a collection of sources for buffered images.\n\nThe constructor of the ImageSourceBuilder class is responsible for initializing the builder with the provided iterable of buffered image sources. This allows the builder to have access to a sequence of images that can be used to build the final image source.\n\nThe class also includes an overridden method, `obtainSourceImages`, which is responsible for retrieving a list of source images from the buffered image sources. This method may throw an IOException, indicating that an error occurred during the reading process of the images. This is a common exception that is thrown when an input or output operation is failed or interpreted.\n\nAdditionally, the class provides a method `useOriginalFormat` that allows the user to specify whether the original format of the images should be used. When this method is called, it sets the corresponding class variable and returns the instance of the builder itself. This return of the builder instance enables method chaining, which is a common technique in the builder pattern that allows for a more fluent and readable way of setting properties.\n\nIn summary, the ImageSourceBuilder class is a builder class that provides methods for setting up an image source with specific configurations, such as whether to use the original image format, and for obtaining the source images that will be used in the final image source. The class is designed to be flexible and to provide a clear and fluent interface for building complex objects.",
        "file": "imglib/all/src/main/java/cn/usage/builder/ImageSourceBuilder.java",
        "class_name": "ImageSourceBuilder",
        "repo_metadata": {
            "repo_name": "imglib"
        },
        "evaluation_metadata": {
            "test_class_name": "ImageSourceBuilderTest",
            "test_file": "imglib/all/src/test/java/cn/usage/builder/ImageSourceBuilderTest.java"
        },
        "task_id": 55,
        "ground_truth_class_body": "package cn.usage.builder;\n\nimport cn.usage.AbstractSourceBuilder;\nimport cn.core.in.BufferedImageSource;\nimport cn.core.ex.HandlingException;\nimport cn.core.utils.StringUtils;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.text.MessageFormat;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * A source builder which form buffered image source.\n *\n * @author tracy\n * @since 0.2.1\n */\npublic class ImageSourceBuilder<S> extends AbstractSourceBuilder<ImageSourceBuilder<S>> {\n\n    /**\n     * Whether to use the original format.\n     */\n    protected boolean useOriginalFormat;\n\n    /**\n     * The iterable of the buffered image source.\n     */\n    protected final Iterable<BufferedImageSource<S>> sources;\n\n    public ImageSourceBuilder(Iterable<BufferedImageSource<S>> sources) {\n        this.sources = sources;\n    }\n\n\n    @Override\n    protected List<BufferedImage> obtainSourceImages() throws IOException {\n        // obtain the source images\n        List<BufferedImage> originalImages = new ArrayList<>();\n        List<String> formatNames = new ArrayList<>();\n        for (BufferedImageSource<S> o : sources) {\n            originalImages.add(o.read());\n            formatNames.add(o.getOriginalFormatName());\n        }\n        // setting the format name\n        if (useOriginalFormat) {\n            String[] formats = formatNames.stream().filter(StringUtils::isNotEmpty).distinct().toArray(String[]::new);\n            if (formats.length == 0) {\n                throw new HandlingException(\"No available original format.\");\n            } else if (formats.length > 1) {\n                throw new HandlingException(MessageFormat.format(\"Multiple available original formats found:[{0}].\",\n                        StringUtils.join(formats, \",\")));\n            } else {\n                formatName(formats[0]);\n            }\n        }\n\n        return originalImages;\n    }\n\n    public ImageSourceBuilder<S> useOriginalFormat() {\n        useOriginalFormat = true;\n        return this;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class ExcelStyleConfig is designed to represent the configuration of an Excel style. It contains several private final fields, each with a default value set using the @Builder.Default annotation. These fields include font, hidden, locked, quotePrefix, horizontalAlignment, wrapText, verticalAlignment, rotation, indent, border styles for left, right, top, and bottom, border colors for left, right, top, and bottom, fillPattern, fillBackgroundColor, fillForegroundColor, and shrinkToFit. \n\nThe font field is an instance of ExcelFontConfig, which represents the configuration of the font in Excel. The hidden, locked, quotePrefix, and shrinkToFit fields are boolean values representing whether the style is hidden, locked, has a quote prefix, and is set to shrink to fit, respectively. \n\nThe horizontalAlignment and verticalAlignment fields are instances of StyleHorizontalAlignment and StyleVerticalAlignment, respectively, representing the alignment of the style. The rotation field is a short value representing the rotation of the style. The indent field is a short value representing the indent of the style. \n\nThe border style fields are instances of BorderStyle, representing the border style of the left, right, top, and bottom. The border color fields are short values representing the color of the left, right, top, and bottom borders. The fillPattern field is an instance of FillPatternType, representing the fill pattern of the style. The fillBackgroundColor and fillForegroundColor fields are short values representing the background and foreground fill colors of the style.\n\nThe class also contains several static methods that return an instance of ExcelStyleConfig with specific configurations. These methods include getDefaultExcelStyleConfigTitle, getDefaultExcelStyleConfigHead, getDefaultExcelStyleConfigData, and buildByExcelStyle. The getDefaultExcelStyleConfigTitle, getDefaultExcelStyleConfigHead, and getDefaultExcelStyleConfigData methods return an instance of ExcelStyleConfig with the default configuration for a title, head, and data, respectively. The buildByExcelStyle method takes an instance of ExcelStyle as an argument and returns an instance of ExcelStyleConfig with the same configuration.\"",
        "sketchy_description": "The public class ExcelStyleConfig is designed to encapsulate the various style configurations applicable to Excel cells. This includes settings for fonts, cell visibility, alignment, text wrapping, rotation, indentation, borders, colors, and more. The class provides a set of default values for these configurations, which can be used to quickly apply a consistent style to Excel cells.\n\nThe class exposes several static methods that return default configurations for different types of cell content, such as titles, headers, and data cells. The getDefaultExcelStyleConfigTitle method returns an ExcelStyleConfig object with a centered horizontal alignment and a default title font, which is suitable for title cells in an Excel sheet. Similarly, the getDefaultExcelStyleConfigHead method returns a configuration that is tailored for header cells, with centered alignment and a default header font. For data cells, the getDefaultExcelStyleConfigData method provides a configuration with a general horizontal alignment and a centered vertical alignment, which is a common style for cell data.\n\nAdditionally, the class offers a method called buildByExcelStyle, which allows for the creation of an ExcelStyleConfig object based on an existing ExcelStyle object. This method ensures that all the style properties are set in accordance with the provided ExcelStyle, allowing for a customized and consistent appearance across different cells in an Excel document. These methods are essential for users who need to manage and apply styles to Excel cells programmatically, ensuring that the cells not only contain the correct data but also present it in a visually appealing and organized manner.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/metadata/config/ExcelStyleConfig.java",
        "class_name": "ExcelStyleConfig",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "ExcelStyleConfigTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/metadata/config/ExcelStyleConfigTest.java"
        },
        "task_id": 56,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.metadata.config;\n\nimport io.github.zouzhiy.excel.annotation.ExcelStyle;\nimport io.github.zouzhiy.excel.enums.StyleHorizontalAlignment;\nimport io.github.zouzhiy.excel.enums.StyleVerticalAlignment;\nimport lombok.Builder;\nimport lombok.EqualsAndHashCode;\nimport lombok.Getter;\nimport lombok.ToString;\nimport org.apache.poi.ss.usermodel.BorderStyle;\nimport org.apache.poi.ss.usermodel.FillPatternType;\n\n/**\n * \u6837\u5f0f\u914d\u7f6e {@link io.github.zouzhiy.excel.annotation.ExcelFont}\n *\n * @author zouzhiy\n * @since 2022/7/2\n */\n@Getter\n@ToString\n@EqualsAndHashCode\n@Builder\npublic class ExcelStyleConfig {\n\n    @Builder.Default\n    private final ExcelFontConfig font = ExcelFontConfig.getDefaultExcelFontConfigData();\n\n    @Builder.Default\n    private final boolean hidden = false;\n\n    @Builder.Default\n    private final boolean locked = false;\n\n    @Builder.Default\n    private final boolean quotePrefix = false;\n\n    @Builder.Default\n    private final StyleHorizontalAlignment horizontalAlignment = StyleHorizontalAlignment.GENERAL;\n\n    @Builder.Default\n    private final boolean wrapText = true;\n\n    @Builder.Default\n    private final StyleVerticalAlignment verticalAlignment = StyleVerticalAlignment.CENTER;\n\n    @Builder.Default\n    private final short rotation = 0;\n\n    @Builder.Default\n    private final short indent = -1;\n\n    @Builder.Default\n    private final BorderStyle borderLeft = BorderStyle.NONE;\n    @Builder.Default\n    private final BorderStyle borderRight = BorderStyle.NONE;\n    @Builder.Default\n    private final BorderStyle borderTop = BorderStyle.NONE;\n    @Builder.Default\n    private final BorderStyle borderBottom = BorderStyle.NONE;\n\n    @Builder.Default\n    private final short leftBorderColor = -1;\n    @Builder.Default\n    private final short rightBorderColor = -1;\n    @Builder.Default\n    private final short topBorderColor = -1;\n    @Builder.Default\n    private final short bottomBorderColor = -1;\n\n    @Builder.Default\n    private final FillPatternType fillPattern = FillPatternType.NO_FILL;\n\n    @Builder.Default\n    private final short fillBackgroundColor = -1;\n\n    @Builder.Default\n    private final short fillForegroundColor = -1;\n\n    @Builder.Default\n    private final boolean shrinkToFit = false;\n\n\n    public static ExcelStyleConfig getDefaultExcelStyleConfigTitle() {\n\n        return ExcelStyleConfig.builder()\n                .font(ExcelFontConfig.getDefaultExcelFontConfigTitle())\n                .horizontalAlignment(StyleHorizontalAlignment.CENTER)\n                .verticalAlignment(StyleVerticalAlignment.CENTER)\n                .build();\n    }\n\n    public static ExcelStyleConfig getDefaultExcelStyleConfigHead() {\n        return ExcelStyleConfig.builder()\n                .font(ExcelFontConfig.getDefaultExcelFontConfigHead())\n                .horizontalAlignment(StyleHorizontalAlignment.CENTER)\n                .verticalAlignment(StyleVerticalAlignment.CENTER)\n                .build();\n    }\n\n    public static ExcelStyleConfig getDefaultExcelStyleConfigData() {\n        return ExcelStyleConfig.builder()\n                .font(ExcelFontConfig.getDefaultExcelFontConfigData())\n                .horizontalAlignment(StyleHorizontalAlignment.GENERAL)\n                .verticalAlignment(StyleVerticalAlignment.CENTER)\n                .build();\n    }\n\n    public static ExcelStyleConfig buildByExcelStyle(ExcelStyle excelStyle) {\n        return ExcelStyleConfig.builder()\n                .font(ExcelFontConfig.buildByExcelFont(excelStyle.font()))\n                .hidden(excelStyle.hidden())\n                .locked(excelStyle.locked())\n                .quotePrefix(excelStyle.quotePrefix())\n                .horizontalAlignment(excelStyle.horizontalAlignment())\n                .wrapText(excelStyle.wrapText())\n                .verticalAlignment(excelStyle.verticalAlignment())\n                .rotation(excelStyle.rotation())\n                .indent(excelStyle.indent())\n                .borderLeft(excelStyle.borderLeft())\n                .borderRight(excelStyle.borderRight())\n                .borderTop(excelStyle.borderTop())\n                .borderBottom(excelStyle.borderBottom())\n                .leftBorderColor(excelStyle.leftBorderColor())\n                .rightBorderColor(excelStyle.rightBorderColor())\n                .topBorderColor(excelStyle.topBorderColor())\n                .bottomBorderColor(excelStyle.bottomBorderColor())\n                .fillPattern(excelStyle.fillPattern())\n                .fillBackgroundColor(excelStyle.fillBackgroundColor())\n                .fillForegroundColor(excelStyle.fillForegroundColor())\n                .shrinkToFit(excelStyle.shrinkToFit())\n                .build();\n    }\n\n}\n"
    },
    {
        "detailed_description": "The public class DateNumberHandler is a subclass of the AbstractDateCellHandler class. This class is designed to handle date cells in an Excel spreadsheet. It overrides two methods from its superclass. The first method, setCellValue, is responsible for setting the value of a cell in a row. It takes four parameters: a RowContext object, an ExcelFieldConfig object, a Cell object, and a Date object. The method first converts the Date object into an Excel date using the DateUtil.getExcelDate method, and then sets the value of the cell to this Excel date. The second method, getExcelType, returns the ExcelType of the cell, which in this case is NUMERIC. This indicates that the cell contains a numeric value, specifically a date represented as a number in Excel's date system.\"",
        "sketchy_description": "The public class DateNumberHandler, which extends the AbstractDateCellHandler, is designed to handle the conversion of Date objects into numeric date values that are compatible with Excel's date system. This class provides a method that takes a Date object and converts it into the numeric equivalent that Excel understands, allowing for proper representation of dates within an Excel spreadsheet.\n\nThe setCellValue method is a protected method that is responsible for taking a Date object and setting the corresponding cell in an Excel spreadsheet to the numeric date value that represents that date in Excel. It requires a RowContext, an ExcelFieldConfig, a Cell, and the Date value to perform this operation. This method ensures that dates are stored correctly in Excel, which is crucial for any operations or calculations that involve dates within the spreadsheet.\n\nAdditionally, the class provides a public method getExcelType which returns the ExcelType enumeration value that corresponds to numeric data. This method is useful for identifying the type of data that the handler is dealing with, ensuring that the data is treated appropriately when being processed for use in Excel. This method is particularly important for systems that need to dynamically handle different types of data and ensure that each is represented in the most suitable format within an Excel document.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/date/DateNumberHandler.java",
        "class_name": "DateNumberHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "DateNumberHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/DateNumberHandlerTest.java"
        },
        "task_id": 57,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.date;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport org.apache.poi.ss.usermodel.Cell;\nimport org.apache.poi.ss.usermodel.DateUtil;\n\nimport java.util.Date;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class DateNumberHandler extends AbstractDateCellHandler {\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, Date value) {\n        double excelDate = DateUtil.getExcelDate(value);\n        cell.setCellValue(excelDate);\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.NUMERIC;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class ConcatenatingIterator is designed to implement the CloseableIterator interface for a Record object. This class is used to iterate over a list of suppliers that provide CloseableIterators for Record objects. The class contains two private fields: iteratorSuppliers, which is an Iterator of Supplier objects that provide CloseableIterators for Record objects, and currentIterator, which is the current CloseableIterator for a Record object.\n\nThe constructor for this class takes a List of Supplier objects that provide CloseableIterators for Record objects. If the list is not null, the constructor initializes the iteratorSuppliers field with the iterator of the list and updates the currentIterator. If the list is null, the iteratorSuppliers field is set to null.\n\nThe private method updateCurrentIterator is used to update the currentIterator. If there are more suppliers in the iteratorSuppliers, it gets the next supplier and sets the currentIterator to the CloseableIterator provided by the supplier. If there are no more suppliers, it sets the currentIterator to null.\n\nThe class overrides the close method from the CloseableIterator interface. If the currentIterator is not null, it closes the currentIterator.\n\nThe class also overrides the hasNext method from the CloseableIterator interface. This method checks if there are more elements to iterate over. If the currentIterator is null, it checks if there are more suppliers in the iteratorSuppliers. If there are, it updates the currentIterator and checks again. If there are no more elements to iterate over, it returns false. If the currentIterator has no more elements, it closes the currentIterator, updates it, and checks again. If there are more elements, it returns true.\n\nFinally, the class overrides the next method from the CloseableIterator interface. This method returns the next Record object from the currentIterator.\"",
        "sketchy_description": "The public class ConcatenatingIterator is designed to provide a seamless iteration over multiple CloseableIterators, effectively merging their sequences into a single, continuous iteration. This is particularly useful when dealing with a series of data streams that need to be processed as one. The class implements the CloseableIterator interface, which requires methods for checking the existence of a next element, retrieving the next element, and closing the iterator to free resources.\n\nThe constructor of ConcatenatingIterator takes a list of suppliers, each supplying a CloseableIterator of Records. These suppliers are stored internally and are used to sequentially provide iterators for concatenation. The updateCurrentIterator method is a private utility that manages the transition from one iterator to the next, ensuring that the iteration continues smoothly as one iterator exhausts its elements.\n\nThe close method is an important part of the CloseableIterator interface, which the ConcatenatingIterator class must implement. It ensures that the current iterator is properly closed, which is crucial for avoiding resource leaks, especially when dealing with I/O operations.\n\nThe hasNext method is overridden to provide a way to check if the concatenated sequence still has more elements to offer. It is a key method that allows users of the iterator to avoid NoSuchElementExceptions and to loop through the elements properly.\n\nFinally, the next method is also overridden to return the next Record in the sequence. It is the core method that users call to retrieve each successive element from the concatenated iterators.\n\nIn summary, the ConcatenatingIterator class is a utility that simplifies the process of iterating over multiple streams of data by presenting them as a single, unified sequence, while also ensuring proper resource management through its close method.",
        "file": "sleeper/java/core/src/main/java/sleeper/core/iterator/ConcatenatingIterator.java",
        "class_name": "ConcatenatingIterator",
        "repo_metadata": {
            "repo_name": "sleeper"
        },
        "evaluation_metadata": {
            "test_class_name": "ConcatenatingIteratorTest",
            "test_file": "sleeper/java/core/src/test/java/sleeper/core/iterator/ConcatenatingIteratorTest.java"
        },
        "task_id": 58,
        "ground_truth_class_body": "/*\n * Copyright 2022-2023 Crown Copyright\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage sleeper.core.iterator;\n\nimport sleeper.core.record.Record;\n\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.function.Supplier;\n\n/**\n * A {@link ConcatenatingIterator} iterator iterates through a list of iterator suppliers and for each one, reads it fully.\n */\npublic class ConcatenatingIterator implements CloseableIterator<Record> {\n    private final Iterator<Supplier<CloseableIterator<Record>>> iteratorSuppliers;\n    private CloseableIterator<Record> currentIterator;\n\n    public ConcatenatingIterator(List<Supplier<CloseableIterator<Record>>> suppliers) {\n        if (suppliers != null) {\n            this.iteratorSuppliers = suppliers.iterator();\n            updateCurrentIterator();\n        } else {\n            this.iteratorSuppliers = null;\n        }\n    }\n\n    private void updateCurrentIterator() {\n        if (iteratorSuppliers.hasNext()) {\n            Supplier<CloseableIterator<Record>> supplier = iteratorSuppliers.next();\n            if (supplier != null) {\n                currentIterator = supplier.get();\n                return;\n            }\n        }\n        currentIterator = null;\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (currentIterator != null) {\n            currentIterator.close();\n        }\n    }\n\n    @Override\n    public boolean hasNext() {\n        if (currentIterator == null) {\n            // If there are more iterators in the suppliers they still need to be checked\n            if (iteratorSuppliers != null && iteratorSuppliers.hasNext()) {\n                updateCurrentIterator();\n                return hasNext();\n            }\n            return false;\n        }\n        if (!currentIterator.hasNext()) {\n            try {\n                currentIterator.close();\n            } catch (IOException e) {\n                throw new RuntimeException(\"Failed to close iterator\", e);\n            }\n            updateCurrentIterator();\n            return hasNext();\n        }\n        return true;\n    }\n\n    @Override\n    public Record next() {\n        return currentIterator.next();\n    }\n}\n"
    },
    {
        "detailed_description": "The public class RefCountByteBuffer extends the RefCount class, which is a class that manages the reference count of an object. This class is designed to manage a ByteBuffer object, which is a container for data of a specific primitive type. \n\nThe class contains two private final fields: a ByteBuffer named 'buffer' and a ByteBufferPool named 'pool'. The ByteBufferPool is a pool of ByteBuffer objects that can be borrowed and returned to manage memory usage efficiently.\n\nThe protected constructor of this class takes four parameters: a boolean 'plain', a ByteBufferPool 'pool', an integer 'requestSize', and an integer 'threshold'. If the 'requestSize' is less than the 'threshold', a new ByteBuffer of size 'requestSize' is allocated and the 'pool' is set to null. Otherwise, a ByteBuffer of size 'requestSize' is borrowed from the 'pool'.\n\nThe class provides two static factory methods: 'create' and 'createPlain'. Both methods take the same parameters as the constructor and return a new instance of RefCountByteBuffer. The 'create' method creates a thread-safe instance, while the 'createPlain' method creates an instance that is not thread-safe.\n\nThe class overrides the 'retain' and 'release' methods from the RefCount class. The 'retain' method increments the reference count by a specified amount, and the 'release' method decrements the reference count by a specified amount. If the 'pool' is not null and the reference count reaches zero after decrementing, the ByteBuffer is returned to the pool.\n\nFinally, the class provides a public method 'getBuffer' that returns the ByteBuffer object managed by this instance.\"",
        "sketchy_description": "The public class RefCountByteBuffer, which extends the class RefCount, is designed to manage a ByteBuffer with reference counting, ensuring that resources are released appropriately when they are no longer needed. This class is particularly useful in environments where memory management is critical, such as in high-performance applications that handle large amounts of data.\n\nThe class contains two private final variables: a ByteBuffer, which is the actual buffer managed by the instance, and a ByteBufferPool, which may be used to borrow ByteBuffers if applicable. This design allows for efficient memory usage by reusing ByteBuffers from a pool instead of constantly allocating new ones.\n\nThe protected constructor of RefCountByteBuffer takes a boolean indicating whether the buffer should be plain (non-thread-safe), a ByteBufferPool from which the buffer may be borrowed, a request size that specifies the size of the ByteBuffer to be allocated or borrowed, and a threshold that may be used for internal logic. This constructor is responsible for setting up the RefCountByteBuffer instance with the appropriate buffer based on the provided parameters.\n\nThe class provides two static factory methods for creating instances of RefCountByteBuffer. The `create` method returns a thread-safe instance, while the `createPlain` method returns a non-thread-safe instance. These methods make it easy to obtain a RefCountByteBuffer with the desired thread-safety characteristics.\n\nThe `retain` method, which overrides a method from the superclass, is used to increase the reference count by a specified increment. This is particularly important when the buffer is shared among multiple owners, ensuring that it is not released prematurely.\n\nThe `release` method, also an override, decreases the reference count by a specified decrement. If the reference count reaches zero, the buffer is released back to the pool, allowing it to be reused by other parts of the application. This method is crucial for preventing memory leaks by ensuring that buffers are properly released when they are no longer in use.\n\nLastly, the `getBuffer` method provides access to the underlying ByteBuffer instance. This allows users of the RefCountByteBuffer to perform operations directly on the ByteBuffer, such as reading or writing data.\n\nOverall, the RefCountByteBuffer class provides a robust mechanism for managing ByteBuffers with reference counting, which is essential for efficient memory management in complex applications.",
        "file": "dongting/client/src/main/java/com/github/dtprj/dongting/buf/RefCountByteBuffer.java",
        "class_name": "RefCountByteBuffer",
        "repo_metadata": {
            "repo_name": "dongting"
        },
        "evaluation_metadata": {
            "test_class_name": "RefCountByteBufferTest",
            "test_file": "dongting/client/src/test/java/com/github/dtprj/dongting/buf/RefCountByteBufferTest.java"
        },
        "task_id": 59,
        "ground_truth_class_body": "/*\n * Copyright The Dongting Project\n *\n * The Dongting Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage com.github.dtprj.dongting.buf;\n\nimport com.github.dtprj.dongting.common.RefCount;\n\nimport java.nio.ByteBuffer;\n\n/**\n * @author huangli\n */\npublic class RefCountByteBuffer extends RefCount {\n\n    private final ByteBuffer buffer;\n    private final ByteBufferPool pool;\n\n    protected RefCountByteBuffer(boolean plain, ByteBufferPool pool, int requestSize, int threshold) {\n        super(plain);\n        if (requestSize < threshold) {\n            this.buffer = ByteBuffer.allocate(requestSize);\n            this.pool = null;\n        } else {\n            this.buffer = pool.borrow(requestSize);\n            this.pool = pool;\n        }\n    }\n\n    /**\n     * create thread safe instance.\n     */\n    public static RefCountByteBuffer create(ByteBufferPool pool, int requestSize, int threshold) {\n        return new RefCountByteBuffer(false, pool, requestSize, threshold);\n    }\n\n    /**\n     * create instance which is not thread safe.\n     */\n    public static RefCountByteBuffer createPlain(ByteBufferPool pool, int requestSize, int threshold) {\n        return new RefCountByteBuffer(true, pool, requestSize, threshold);\n    }\n\n    @Override\n    public void retain(int increment) {\n        if (pool == null) {\n            return;\n        }\n        super.retain(increment);\n    }\n\n    @Override\n    public boolean release(int decrement) {\n        if (pool == null) {\n            return false;\n        }\n        boolean result = super.release(decrement);\n        if (result) {\n            pool.release(buffer);\n        }\n        return result;\n    }\n\n    public ByteBuffer getBuffer() {\n        return buffer;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class SingleDeptDataPermissionChecker is a subclass of the AbstractDataPermissionChecker class. This class is designed to check if a user has permission to access data from a specific department. It contains a private member, deptService, of type ISysDeptService, which is presumably a service interface for interacting with department data.\n\nThe class overrides the check method from the AbstractDataPermissionChecker class. This method takes two parameters: a loginUser object and a DataCondition object. The loginUser object presumably represents the user who is trying to access the data, while the DataCondition object represents the conditions under which the data is being accessed.\n\nThe check method first checks if either the loginUser or the DataCondition object is null. If either is null, the method returns false, indicating that the user does not have permission to access the data.\n\nNext, the method checks if either the department ID of the loginUser or the target department ID in the DataCondition object is null. If either is null, the method again returns false.\n\nFinally, the method checks if the department ID of the loginUser is equal to the target department ID in the DataCondition object. If they are equal, the method returns true, indicating that the user has permission to access the data. If they are not equal, the method returns false. This check is performed using the equals method of the Objects class, which compares the two objects for equality.\"",
        "sketchy_description": "The public class SingleDeptDataPermissionChecker, which extends the AbstractDataPermissionChecker, is designed to enforce data access permissions based on departmental affiliation. It utilizes a private instance of ISysDeptService to perform its checks.\n\nThe check method is a crucial part of this class, as it determines whether a logged-in user has the appropriate permissions to access certain data. This method takes two parameters: a loginUser object that represents the user attempting to access the data, and a DataCondition object that encapsulates the conditions under which data access is allowed. The method compares the department ID associated with the loginUser to the target department ID specified in the DataCondition. If these IDs match, the method returns true, indicating that the user has permission to access the data. If they do not match, the method returns false, denying access. This mechanism ensures that users can only access data from their own department, thereby maintaining data security and integrity within the organization.",
        "file": "AgileBoot-Back-End/agileboot-infrastructure/src/main/java/com/agileboot/infrastructure/web/domain/permission/checker/SingleDeptDataPermissionChecker.java",
        "class_name": "SingleDeptDataPermissionChecker",
        "repo_metadata": {
            "repo_name": "AgileBoot-Back-End"
        },
        "evaluation_metadata": {
            "test_class_name": "SingleDeptDataPermissionCheckerTest",
            "test_file": "AgileBoot-Back-End/agileboot-infrastructure/src/test/java/com/agileboot/infrastructure/web/domain/permission/checker/SingleDeptDataPermissionCheckerTest.java"
        },
        "task_id": 60,
        "ground_truth_class_body": "package com.agileboot.infrastructure.web.domain.permission.checker;\n\nimport com.agileboot.infrastructure.web.domain.login.LoginUser;\nimport com.agileboot.infrastructure.web.domain.permission.AbstractDataPermissionChecker;\nimport com.agileboot.infrastructure.web.domain.permission.DataCondition;\nimport com.agileboot.orm.system.service.ISysDeptService;\nimport java.util.Objects;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n/**\n * \u6570\u636e\u6743\u9650\u6d4b\u8bd5\u63a5\u53e3\n * @author valarchie\n */\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class SingleDeptDataPermissionChecker extends AbstractDataPermissionChecker {\n\n    private ISysDeptService deptService;\n\n    @Override\n    public boolean check(LoginUser loginUser, DataCondition condition) {\n        if (condition == null || loginUser == null) {\n            return false;\n        }\n\n        if (loginUser.getDeptId() == null || condition.getTargetDeptId() == null) {\n            return false;\n        }\n\n        Long currentDeptId = loginUser.getDeptId();\n        Long targetDeptId = condition.getTargetDeptId();\n\n        return Objects.equals(currentDeptId, targetDeptId);\n    }\n\n\n}\n"
    },
    {
        "detailed_description": "The public class RowFootReadRegistry is designed to manage and provide access to different types of RowFootRead objects. The class contains a static final field DEFAULT_ROW_FOOT_READ_CLASS which holds the class type of DefaultRowFootRead. It also contains a private final field configuration of type Configuration, which is used to store the configuration settings for the registry. \n\nThe class also maintains a private map, rowFootReadMap, which is a concurrent hash map that maps classes that extend RowFootRead to instances of those classes. This map is used to store and retrieve RowFootRead objects based on their class type.\n\nThe constructor of the class takes a Configuration object as an argument and initializes the configuration field with it. It also registers a new instance of DefaultRowFootRead in the rowFootReadMap.\n\nThe class provides a public method getConfiguration that returns the configuration object. It also provides a public method register that takes a RowFootRead object as an argument and adds it to the rowFootReadMap using the object's class as the key.\n\nThe class also provides a public method getMappingRowRead that takes a Class object as an argument, which should represent a class that extends RowFootRead. This method retrieves the corresponding RowFootRead object from the rowFootReadMap. If no such object exists, it throws an ExcelException with a message indicating that the requested RowFootRead does not exist.\"",
        "sketchy_description": "The public class RowFootReadRegistry is designed to manage the registry of RowFootRead instances, which are presumably related to reading or processing data in a specific format or from a specific source. The class contains a static class variable `DEFAULT_ROW_FOOT_READ_CLASS` which holds a reference to the `DefaultRowFootRead` class, indicating that this is the default implementation of a RowFootRead that will be used if no other is specified.\n\nThe constructor of the class takes a `Configuration` object as an argument and uses it to initialize the registry. It also registers the default RowFootRead instance, ensuring that there is at least one RowFootRead available for use immediately after the registry is created.\n\nThe `getConfiguration` method allows users to retrieve the `Configuration` object associated with the registry, which might contain settings or parameters that affect how the RowFootRead instances operate.\n\nThe `register` method is used to add a new RowFootRead instance to the registry. This allows for the possibility of having multiple RowFootRead implementations available for use, which can be selected based on the specific requirements of the task at hand.\n\nFinally, the `getMappingRowRead` method is used to retrieve a RowFootRead instance that is associated with a given class. This method requires the class of the RowFootRead that is desired, and it will return the corresponding instance. If no such instance exists, it throws an `ExcelException`, indicating that the operation cannot be completed because the requested RowFootRead is not registered in the system. This method is essential for accessing the correct RowFootRead instance when multiple implementations are available.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/read/registry/RowFootReadRegistry.java",
        "class_name": "RowFootReadRegistry",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "RowFootReadRegistryTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/read/registry/RowFootReadRegistryTest.java"
        },
        "task_id": 61,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.read.registry;\n\nimport io.github.zouzhiy.excel.exceptions.ExcelException;\nimport io.github.zouzhiy.excel.metadata.Configuration;\nimport io.github.zouzhiy.excel.read.RowFootRead;\nimport io.github.zouzhiy.excel.read.defaults.DefaultRowFootRead;\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class RowFootReadRegistry {\n\n    public final static Class<DefaultRowFootRead> DEFAULT_ROW_FOOT_READ_CLASS = DefaultRowFootRead.class;\n\n    private final Configuration configuration;\n\n    private final Map<Class<? extends RowFootRead>, RowFootRead> rowFootReadMap = new ConcurrentHashMap<>(16);\n\n    public RowFootReadRegistry(Configuration configuration) {\n        this.configuration = configuration;\n        register(new DefaultRowFootRead());\n    }\n\n    public Configuration getConfiguration() {\n        return configuration;\n    }\n\n    public void register(RowFootRead rowFootRead) {\n        rowFootReadMap.put(rowFootRead.getClass(), rowFootRead);\n    }\n\n    public RowFootRead getMappingRowRead(Class<? extends RowFootRead> rowFootReadClazz) {\n        RowFootRead rowFootRead = rowFootReadMap.get(rowFootReadClazz);\n        if (rowFootRead == null) {\n            throw new ExcelException(\"\u4e0d\u5b58\u5728\u7684\uff1aRowFootRead\");\n        }\n        return rowFootRead;\n    }\n\n}\n"
    },
    {
        "detailed_description": "The public class BooleanNumberHandler is a subclass of the AbstractBooleanCellHandler class. This class is designed to handle boolean values in the context of Excel cells. It contains two private static final BigDecimal fields, FALSE_VALUE and TRUE_VALUE, which are set to 0 and 1 respectively. These fields represent the numeric values that correspond to the boolean values false and true in Excel. \n\nThe class overrides two methods from its superclass. The first overridden method, setCellValue, takes four parameters: a RowContext object, an ExcelFieldConfig object, a Cell object, and a Boolean value. This method sets the value of the given cell to the numeric equivalent of the provided Boolean value. If the Boolean value is true, the cell's value is set to the double value of TRUE_VALUE (1.0). If the Boolean value is false, the cell's value is set to the double value of FALSE_VALUE (0.0).\n\nThe second overridden method, getExcelType, returns an ExcelType enumeration value. This method does not take any parameters and always returns ExcelType.NUMERIC, indicating that the Excel cells handled by this class are of the numeric type.\"",
        "sketchy_description": "The public class BooleanNumberHandler, which extends AbstractBooleanCellHandler, is designed to handle the conversion of Boolean values into their numeric representations within Excel cells. This is particularly useful when dealing with Excel operations that require a numeric value instead of a Boolean, allowing for a seamless translation between the two data types. The class defines two static BigDecimal variables, FALSE_VALUE and TRUE_VALUE, which correspond to the numeric values 0 and 1, respectively. These constants are used to represent the false and true Boolean values within an Excel cell.\n\nThe class provides a protected method setCellValue, which takes a RowContext, an ExcelFieldConfig, a Cell, and a Boolean value as parameters. This method is responsible for setting the cell's value to the numeric equivalent of the provided Boolean value, using the predefined constants for false and true. This functionality is essential for maintaining data integrity when Boolean values need to be represented numerically in Excel documents.\n\nAdditionally, the class offers a public method getExcelType, which returns the ExcelType enumeration value that corresponds to a numeric type. This method is useful for determining the type of data that the handler is dealing with, ensuring that the correct numeric representation is used for Boolean values in Excel cells.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/booleans/BooleanNumberHandler.java",
        "class_name": "BooleanNumberHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "BooleanNumberHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/BooleanNumberHandlerTest.java"
        },
        "task_id": 62,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.booleans;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport org.apache.poi.ss.usermodel.Cell;\n\nimport java.math.BigDecimal;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class BooleanNumberHandler extends AbstractBooleanCellHandler {\n\n    private final static BigDecimal FALSE_VALUE = BigDecimal.ZERO;\n    private final static BigDecimal TRUE_VALUE = BigDecimal.ONE;\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, Boolean value) {\n        cell.setCellValue(value ? TRUE_VALUE.doubleValue() : FALSE_VALUE.doubleValue());\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.NUMERIC;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class LocalDateTimeStringHandler is a specialized class that extends the AbstractLocalDateTimeCellHandler class. This class is designed to handle the conversion of LocalDateTime objects into string format for use in Excel cells. \n\nThe class overrides three methods from its parent class. The first method, setCellValue, is responsible for setting the value of a cell in an Excel row. It takes four parameters: a RowContext object, an ExcelFieldConfig object, a Cell object, and a LocalDateTime value. The method first retrieves the Java format for the date and time from the ExcelFieldConfig object. It then formats the LocalDateTime value into a string using this format, and sets this string as the value of the cell.\n\nThe second method, getExcelType, is a simple getter method that returns the ExcelType of the handler, which in this case is ExcelType.STRING. This indicates that this handler is used for cells that contain string values.\n\nThe third method, getDefaultJavaFormat, is another getter method that returns the default Java format for date and time, which is \"yyyy-MM-dd HH:mm:ss\". This format is used when no other format is specified in the ExcelFieldConfig object. This method ensures that the LocalDateTime values are always formatted in a consistent manner, even if no specific format is provided.\"",
        "sketchy_description": "The public class LocalDateTimeStringHandler, which extends the AbstractLocalDateTimeCellHandler, is specialized in managing the conversion process between LocalDateTime objects and their String representations within Excel cells. This is particularly useful when dealing with Excel spreadsheets that require date and time information to be stored as text.\n\nThe class provides a protected method setCellValue, which takes a RowContext, an ExcelFieldConfig, a Cell, and a LocalDateTime value as parameters. This method is responsible for setting the cell's value in the spreadsheet as a formatted string that represents the LocalDateTime object. The formatting is determined by the ExcelFieldConfig provided, allowing for customization based on the needs of the spreadsheet.\n\nAdditionally, the class includes a public method getExcelType that returns the ExcelType.STRING. This indicates that the handler is associated with string values in Excel, which is consistent with the conversion of LocalDateTime to a text format.\n\nLastly, the class offers a public method getDefaultJavaFormat that returns a string representing the default Java format for LocalDateTime objects, which is \"yyyy-MM-dd HH:mm:ss\". This default format is commonly used for representing date and time and can be used as a standard when no specific formatting instructions are provided.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/localdatetime/LocalDateTimeStringHandler.java",
        "class_name": "LocalDateTimeStringHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "LocalDateTimeStringHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/LocalDateTimeStringHandlerTest.java"
        },
        "task_id": 63,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.localdatetime;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport io.github.zouzhiy.excel.utils.ExcelDateFormatUtils;\nimport org.apache.poi.ss.usermodel.Cell;\n\nimport java.time.LocalDateTime;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class LocalDateTimeStringHandler extends AbstractLocalDateTimeCellHandler {\n\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, LocalDateTime value) {\n        String javaFormat = this.getJavaFormat(excelFieldConfig);\n        String strValue = ExcelDateFormatUtils.format(value, javaFormat);\n        cell.setCellValue(strValue);\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.STRING;\n    }\n\n    @Override\n    public String getDefaultJavaFormat() {\n        return \"yyyy-MM-dd HH:mm:ss\";\n    }\n\n}\n"
    },
    {
        "detailed_description": "The public class RowHeadWriteRegistry is designed to manage and register instances of RowHeadWrite, which is likely a class that handles writing row headers in an Excel-like data structure. The class has a static final field DEFAULT_ROW_HEAD_WRITE_CLASS, which holds the class object of DefaultRowHeadWrite, presumably a default implementation of the RowHeadWrite interface.\n\nThe class also has a private final field configuration of type Configuration, which is likely used to store configuration settings for the registry. Another private field, rowHeadWriteMap, is a concurrent hash map that maps classes extending RowHeadWrite to instances of those classes.\n\nThe constructor of the class takes a Configuration object as an argument and initializes the configuration field with it. It also registers an instance of DefaultRowHeadWrite in the rowHeadWriteMap.\n\nThe class exposes a public method getConfiguration that returns the Configuration object. Another public method, register, takes an instance of RowHeadWrite and registers it in the rowHeadWriteMap using its class as the key.\n\nThe class also provides a method getMappingRowWrite, which takes a class extending RowHeadWrite as an argument and returns the registered instance of that class from the rowHeadWriteMap. If no instance is found, it throws an ExcelException with a message indicating that the requested RowHeadWrite does not exist.\"",
        "sketchy_description": "The public class RowHeadWriteRegistry is designed to manage the registration of various RowHeadWrite instances, which are likely used for writing row headers in an Excel-like context. The class contains a static class variable DEFAULT_ROW_HEAD_WRITE_CLASS, which holds a reference to the DefaultRowHeadWrite class, indicating the default implementation of a RowHeadWrite that should be used if no other is specified.\n\nThe constructor of the RowHeadWriteRegistry class takes a Configuration object as an argument. This configuration is presumably used to set up the registry with specific settings or parameters. Upon initialization, the constructor also registers the default RowHeadWrite instance, ensuring that there is at least one RowHeadWrite available for use.\n\nThe getConfiguration method is a public method that returns the Configuration object associated with this registry. This allows for external access to the configuration settings of the registry, which might be necessary for querying or modifying how the registry operates.\n\nThe register method is a public void method that takes a RowHeadWrite object as a parameter. This method is responsible for adding a new RowHeadWrite instance to the registry, expanding the set of available RowHeadWrite implementations that can be used for writing row headers.\n\nLastly, the getMappingRowWrite method is a public method that takes a Class object as a parameter, which extends the RowHeadWrite class. This method is used to retrieve a specific RowHeadWrite instance from the registry based on its class. If the requested RowHeadWrite instance is not found in the registry, the method is designed to throw an ExcelException, indicating that the requested operation cannot be completed due to the absence of the required RowHeadWrite instance. This method is crucial for obtaining the correct RowHeadWrite instance for a given task, ensuring that the appropriate row header writing behavior is applied.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/write/registry/RowHeadWriteRegistry.java",
        "class_name": "RowHeadWriteRegistry",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "RowHeadWriteRegistryTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/write/registry/RowHeadWriteRegistryTest.java"
        },
        "task_id": 64,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.write.registry;\n\nimport io.github.zouzhiy.excel.exceptions.ExcelException;\nimport io.github.zouzhiy.excel.metadata.Configuration;\nimport io.github.zouzhiy.excel.write.RowHeadWrite;\nimport io.github.zouzhiy.excel.write.defaults.DefaultRowHeadWrite;\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * RowHeadWrite \u6ce8\u518c\u7ba1\u7406\n *\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class RowHeadWriteRegistry {\n\n    public final static Class<DefaultRowHeadWrite> DEFAULT_ROW_HEAD_WRITE_CLASS = DefaultRowHeadWrite.class;\n\n    private final Configuration configuration;\n\n    private final Map<Class<? extends RowHeadWrite>, RowHeadWrite> rowHeadWriteMap = new ConcurrentHashMap<>(16);\n\n    public RowHeadWriteRegistry(Configuration configuration) {\n        this.configuration = configuration;\n        register(new DefaultRowHeadWrite());\n    }\n\n    /**\n     * \u5168\u5bb6\u914d\u7f6e\u4fe1\u606f\n     *\n     * @return Configuration\n     */\n    public Configuration getConfiguration() {\n        return configuration;\n    }\n\n    /**\n     * \u6ce8\u518c\n     *\n     * @param rowHeadWrite \u5b9e\u4f8b\n     */\n    public void register(RowHeadWrite rowHeadWrite) {\n        rowHeadWriteMap.put(rowHeadWrite.getClass(), rowHeadWrite);\n    }\n\n    /**\n     * \u6839\u636e class \u67e5\u627e\u5df2\u6ce8\u518c\u7684\u5b9e\u4f8b\u5bf9\u8c61\n     *\n     * @param rowHeadWriteClazz class\n     * @return \u8fd4\u56de\u5df2\u6ce8\u518c\u7684\u5b9e\u4f8b\u5bf9\u8c61\n     */\n    public RowHeadWrite getMappingRowWrite(Class<? extends RowHeadWrite> rowHeadWriteClazz) {\n        RowHeadWrite rowHeadWrite = rowHeadWriteMap.get(rowHeadWriteClazz);\n        if (rowHeadWrite == null) {\n            throw new ExcelException(\"\u4e0d\u5b58\u5728\u7684\uff1aRowHeadWrite\");\n        }\n        return rowHeadWrite;\n    }\n\n}\n"
    },
    {
        "detailed_description": "The public class WebSocketQueryStatusReportDestination is a subclass of WebSocketOutput and implements the QueryStatusReportListener interface. This class is designed to handle the status reports of queries in a WebSocket context. \n\nThe class has three constructors, each with different parameters. The first constructor takes three string parameters: region, endpoint, and connectionId. The second constructor takes the same parameters as the first one, but also includes an AWSCredentials object. The third constructor takes a Map of String key-value pairs as its configuration. All constructors call the superclass constructor to initialize the object.\n\nThe class overrides five methods from the QueryStatusReportListener interface: queryQueued, queryInProgress, subQueriesCreated, queryCompleted, and queryFailed. The first two methods are empty and do not perform any actions. The subQueriesCreated method takes a Query object and a List of LeafPartitionQuery objects, and sends a status report with the subquery IDs. The queryCompleted method takes a Query object and a ResultsOutputInfo object, and sends a status report with the query completion status and other related information. The queryFailed method takes a Query object and an Exception, and sends a status report with the error information.\n\nThe class also has a private method, sendStatusReport, which takes a String message, a Query object, and a Map of data. This method creates a record with the provided data and additional information, and attempts to send this record as JSON. If an IOException occurs during this process, an error message is logged.\"",
        "sketchy_description": "The public class WebSocketQueryStatusReportDestination extends WebSocketOutput and implements the QueryStatusReportListener interface, which is designed to handle the status reporting of queries over a WebSocket connection. This class is equipped with a static final Logger to facilitate logging activities. There are multiple constructors available for this class, each designed to initialize the WebSocketQueryStatusReportDestination with different parameters. The first constructor takes a region, endpoint, and connection ID to set up the destination. The second constructor extends this by also including AWS credentials for authentication purposes. The third constructor allows for initialization using a configuration map, providing a flexible way to configure the destination.\n\nOnce the WebSocketQueryStatusReportDestination is initialized, it provides several callback methods that correspond to different stages of query execution. These methods include queryQueued, queryInProgress, subQueriesCreated, queryCompleted, and queryFailed. Each method is invoked at the appropriate time during the lifecycle of a query and performs actions such as sending status reports or handling errors. The queryQueued and queryInProgress methods are currently placeholders that do not perform any action. The subQueriesCreated method sends a status report including the IDs of the sub-queries, while the queryCompleted method sends a status report with the results and any errors if present. The queryFailed method sends a status report with error information.\n\nAdditionally, there is a private method sendStatusReport which is responsible for sending a JSON-formatted status report message over the WebSocket connection. This method includes the message, query ID, and any additional data provided, ensuring that the status of the query is communicated effectively to the connected WebSocket client.",
        "file": "sleeper/java/query/src/main/java/sleeper/query/tracker/WebSocketQueryStatusReportDestination.java",
        "class_name": "WebSocketQueryStatusReportDestination",
        "repo_metadata": {
            "repo_name": "sleeper"
        },
        "evaluation_metadata": {
            "test_class_name": "WebSocketQueryStatusReportDestinationTest",
            "test_file": "sleeper/java/query/src/test/java/sleeper/query/tracker/WebSocketQueryStatusReportDestinationTest.java"
        },
        "task_id": 65,
        "ground_truth_class_body": "/*\n * Copyright 2022-2023 Crown Copyright\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage sleeper.query.tracker;\n\nimport com.amazonaws.auth.AWSCredentials;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport sleeper.query.model.LeafPartitionQuery;\nimport sleeper.query.model.Query;\nimport sleeper.query.model.output.ResultsOutputInfo;\nimport sleeper.query.model.output.WebSocketOutput;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\npublic class WebSocketQueryStatusReportDestination extends WebSocketOutput implements QueryStatusReportListener {\n    private static final Logger LOGGER = LoggerFactory.getLogger(WebSocketQueryStatusReportDestination.class);\n\n    public WebSocketQueryStatusReportDestination(String region, String endpoint, String connectionId) {\n        super(region, endpoint, connectionId);\n    }\n\n    public WebSocketQueryStatusReportDestination(String awsRegion, String endpoint, String connectionId, AWSCredentials awsCredentials) {\n        super(awsRegion, endpoint, connectionId, awsCredentials);\n    }\n\n    public WebSocketQueryStatusReportDestination(Map<String, String> config) {\n        super(config);\n    }\n\n    @Override\n    public void queryQueued(Query query) {\n        // Ignore\n    }\n\n    @Override\n    public void queryInProgress(Query query) {\n        // Ignore\n    }\n\n    @Override\n    public void subQueriesCreated(Query query, List<LeafPartitionQuery> subQueries) {\n        List<String> subQueryIds = subQueries.stream().map(subQuery -> subQuery.getSubQueryId()).collect(Collectors.toList());\n        Map<String, Object> data = new HashMap<>();\n        data.put(\"queryIds\", subQueryIds);\n        this.sendStatusReport(\"subqueries\", query, data);\n    }\n\n    @Override\n    public void queryCompleted(Query query, ResultsOutputInfo outputInfo) {\n        String message = outputInfo.getError() == null ? \"completed\" : \"error\";\n\n        Map<String, Object> data = new HashMap<>();\n        data.put(\"recordCount\", outputInfo.getRecordCount());\n        data.put(\"locations\", outputInfo.getLocations());\n        if (outputInfo.getError() != null) {\n            data.put(\"error\", outputInfo.getError().getClass().getSimpleName() + \": \" + outputInfo.getError().getMessage());\n        }\n\n        sendStatusReport(message, query, data);\n    }\n\n    @Override\n    public void queryFailed(Query query, Exception e) {\n        Map<String, Object> data = new HashMap<>();\n        data.put(\"error\", e.getClass().getSimpleName() + \": \" + e.getMessage());\n        sendStatusReport(\"error\", query, data);\n    }\n\n    private void sendStatusReport(String message, Query query, Map<String, Object> data) {\n        HashMap<String, Object> record = new HashMap<>(data);\n        record.put(\"message\", message);\n\n        String queryId = this.getQueryId(query);\n        record.put(\"queryId\", queryId);\n\n        try {\n            sendJson(record);\n        } catch (IOException e) {\n            LOGGER.error(\"Unable to send query status report to websocket\", e);\n        }\n    }\n}\n"
    },
    {
        "detailed_description": "The public class DoubleBooleanHandler is a subclass of the AbstractDoubleCellHandler class. This class is designed to handle boolean values represented as doubles in an Excel spreadsheet. It contains a private static final Double member, TRUE_VALUE, which is set to 1d, representing the boolean value of true. \n\nThe class overrides two methods from its superclass. The first method, setCellValue, takes four parameters: a RowContext object, an ExcelFieldConfig object, a Cell object, and a Double value. This method sets the value of the cell to true if the Double value is equal to TRUE_VALUE (1d), and false otherwise. \n\nThe second overridden method, getExcelType, returns the ExcelType of the handler, which in this case is BOOLEAN. This method is used to identify the type of data the handler is dealing with.\"",
        "sketchy_description": "The public class DoubleBooleanHandler, which extends AbstractDoubleCellHandler, is designed to handle the conversion of double values to boolean values specifically within the context of Excel cells. This class is particularly useful when dealing with Excel spreadsheets where a numeric value is intended to represent a boolean, with a specific double value (in this case, 1d) being interpreted as true.\n\nThe class contains a single class variable, TRUE_VALUE, which is a private final static Double set to 1d. This value is used as the benchmark for determining whether a given double value should be considered true or false.\n\nThe method setCellValue takes four parameters: a RowContext object, an ExcelFieldConfig object, a Cell object, and a Double value. This protected method is responsible for setting the value of an Excel cell to true if the provided double value is equal to the TRUE_VALUE. If the double value does not match the TRUE_VALUE, the cell is set to false. This method is crucial for ensuring that double values are correctly interpreted as boolean values when populating Excel cells.\n\nAdditionally, the class provides a public method getExcelType which returns the ExcelType enumeration value for boolean. This method allows users to understand the type of Excel cell that the handler is dealing with, which in this case is a boolean type. This information can be useful for developers who are working with different types of data in Excel and need to ensure that each cell's data type is correctly identified and processed.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/doubles/DoubleBooleanHandler.java",
        "class_name": "DoubleBooleanHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "DoubleBooleanHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/DoubleBooleanHandlerTest.java"
        },
        "task_id": 66,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.doubles;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport org.apache.poi.ss.usermodel.Cell;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class DoubleBooleanHandler extends AbstractDoubleCellHandler {\n\n    private final static Double TRUE_VALUE = 1d;\n\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, Double value) {\n        cell.setCellValue(value.compareTo(TRUE_VALUE) == 0);\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.BOOLEAN;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class TimestampDateHandler is a specialized class that extends the AbstractTimestampCellHandler class. This class is designed to handle timestamp data in Excel cells. It overrides three methods from its superclass.\n\nThe first overridden method is setCellValue. This method takes four parameters: a RowContext object, an ExcelFieldConfig object, a Cell object, and a Timestamp value. The purpose of this method is to set the value of a specific cell in an Excel row to a given timestamp. It does this by converting the timestamp to a LocalDateTime object and then setting this as the cell's value.\n\nThe second overridden method is getExcelType. This method does not take any parameters and returns an ExcelType enumeration. Specifically, it returns ExcelType.DATE, indicating that this handler is used for date-type data in Excel.\n\nThe third overridden method is getDefaultExcelFormat. This method also does not take any parameters and returns a String. The string it returns is a date format: \"yyyy-MM-dd HH:mm:ss\". This indicates the default format that this handler uses when dealing with date-type data in Excel.\"",
        "sketchy_description": "The public class TimestampDateHandler, which extends AbstractTimestampCellHandler, is designed to facilitate the conversion of Timestamp values into cells formatted with Excel's date format. This class provides a protected method setCellValue, which takes a RowContext, an ExcelFieldConfig, a Cell, and a Timestamp value as parameters. The method's purpose is to set the cell's value to the local date and time representation of the provided Timestamp, ensuring that the data is correctly formatted for use within an Excel spreadsheet.\n\nAdditionally, the class offers a public method getExcelType, which returns the ExcelType enumeration corresponding to the date format. This method is useful for identifying the type of Excel cell format that should be applied when dealing with date values.\n\nFurthermore, there is another public method getDefaultExcelFormat, which provides the default Excel format string for date and time. The format returned by this method is \"yyyy-MM-dd HH:mm:ss\", which is a commonly used format for representing date and time values in Excel. This string can be used to set the cell format to ensure consistency and readability when handling date and time values in Excel spreadsheets.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/timestamp/TimestampDateHandler.java",
        "class_name": "TimestampDateHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "TimestampDateHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/TimestampDateHandlerTest.java"
        },
        "task_id": 67,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.timestamp;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport org.apache.poi.ss.usermodel.Cell;\n\nimport java.sql.Timestamp;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class TimestampDateHandler extends AbstractTimestampCellHandler {\n\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, Timestamp value) {\n        cell.setCellValue(value.toLocalDateTime());\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.DATE;\n    }\n\n    @Override\n    public String getDefaultExcelFormat() {\n        return \"yyyy-MM-dd HH:mm:ss\";\n    }\n}\n"
    },
    {
        "detailed_description": "The public class Base64RecordListSerialiser implements the ResultsBatchSerialiser interface, which means it must provide implementations for the methods defined in that interface. This class is designed to serialize and deserialize a list of records into a Base64 string, which is a common format for data transmission in network communications.\n\nThe class has two private fields: recordSerialiser and schema. The recordSerialiser is an instance of the RecordSerialiser class, which is used to serialize individual records. The schema is an instance of the Schema class, which defines the structure of the records.\n\nThe constructor for this class takes a Schema object as an argument and initializes the recordSerialiser with this schema.\n\nThe class provides two methods: serialise and deserialise. The serialise method takes a ResultsBatch object as an argument, which contains a list of records. It serializes the records into a byte array, then encodes this byte array into a Base64 string. The deserialise method takes a Base64 string as an argument, decodes it into a byte array, then deserializes the byte array into a list of records. It returns a new ResultsBatch object containing the deserialized records.\n\nThese methods throw an IOException, which means they must be used in a context where this exception is either caught or declared to be thrown. This is because they perform I/O operations, which can potentially fail for various reasons (e.g., if the disk is full or a network connection is lost).",
        "sketchy_description": "The public class Base64RecordListSerialiser, which implements the ResultsBatchSerialiser interface, is tasked with the serialization and deserialization of batches of records into and from Base64 encoded strings. This is particularly useful in scenarios where data needs to be encoded in a way that is safe for transmission or storage in text-based formats. The class is initialized with a specific schema, which defines the structure of the records to be serialized or deserialized, and it uses a RecordSerialiser that is created based on this schema.\n\nThe constructor of the Base64RecordListSerialiser takes a Schema object as an argument and sets up the necessary components for the serialization process. The RecordSerialiser is instantiated within the constructor, ensuring that it is ready to handle the serialization according to the provided schema.\n\nThe serialise method is responsible for converting a ResultsBatch object, which contains a collection of records, into a Base64 encoded string. This method throws an IOException to handle any input/output errors that may occur during the serialization process.\n\nConversely, the deserialise method takes a Base64 encoded string as its input and converts it back into a ResultsBatch object. This allows for the retrieval of the original batch of records from the encoded string. Similar to the serialise method, deserialise also throws an IOException to manage any errors that might arise during the deserialization process.",
        "file": "sleeper/java/core/src/main/java/sleeper/core/record/serialiser/Base64RecordListSerialiser.java",
        "class_name": "Base64RecordListSerialiser",
        "repo_metadata": {
            "repo_name": "sleeper"
        },
        "evaluation_metadata": {
            "test_class_name": "Base64RecordListSerialiserTest",
            "test_file": "sleeper/java/core/src/test/java/sleeper/core/record/serialiser/Base64RecordListSerialiserTest.java"
        },
        "task_id": 68,
        "ground_truth_class_body": "/*\n * Copyright 2022-2023 Crown Copyright\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage sleeper.core.record.serialiser;\n\nimport org.apache.commons.codec.binary.Base64;\n\nimport sleeper.core.record.Record;\nimport sleeper.core.record.ResultsBatch;\nimport sleeper.core.schema.Schema;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Serialises and deserialises a {@link List} of {@link Record}s to and from\n * a {@link String}.\n */\npublic class Base64RecordListSerialiser implements ResultsBatchSerialiser {\n    private final RecordSerialiser recordSerialiser;\n    private final Schema schema;\n\n    public Base64RecordListSerialiser(Schema schema) {\n        this.schema = schema;\n        this.recordSerialiser = new RecordSerialiser(schema);\n    }\n\n    @Override\n    public String serialise(ResultsBatch resultsBatch) throws IOException {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        DataOutputStream dos = new DataOutputStream(baos);\n        dos.writeUTF(resultsBatch.getQueryId());\n        int numRecords = resultsBatch.getRecords().size();\n        dos.writeInt(numRecords);\n        for (Record record : resultsBatch.getRecords()) {\n            byte[] serialisedValue = recordSerialiser.serialise(record);\n            dos.writeInt(serialisedValue.length);\n            dos.write(serialisedValue);\n        }\n        dos.close();\n        byte[] bytes = baos.toByteArray();\n        return Base64.encodeBase64String(bytes);\n    }\n\n    @Override\n    public ResultsBatch deserialise(String serialisedRecords) throws IOException {\n        byte[] bytes = Base64.decodeBase64(serialisedRecords);\n        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n        DataInputStream dis = new DataInputStream(bais);\n        String queryId = dis.readUTF();\n        int numRecords = dis.readInt();\n        List<Record> records = new ArrayList<>(numRecords);\n        for (int i = 0; i < numRecords; i++) {\n            int length = dis.readInt();\n            byte[] serialisedRecord = new byte[length];\n            dis.readFully(serialisedRecord);\n            records.add(recordSerialiser.deserialise(serialisedRecord));\n        }\n        dis.close();\n        return new ResultsBatch(queryId, schema, records);\n    }\n}\n"
    },
    {
        "detailed_description": "The public class CalendarStringHandler is a subclass of the AbstractCalendarCellHandler class. This class is designed to handle calendar data in a string format for Excel cells. It overrides three methods from its superclass.\n\nThe first overridden method is setCellValue. This method takes four parameters: a RowContext object, an ExcelFieldConfig object, a Cell object, and a Calendar object. The method first retrieves the Java format for the Excel field configuration using the getJavaFormat method. It then formats the Calendar value into a string using the ExcelDateFormatUtils.format method, with the retrieved Java format as one of the parameters. The formatted string value is then set as the value of the cell.\n\nThe second overridden method is getExcelType. This method returns an enumeration value of ExcelType.STRING, indicating that the Excel cell type this handler deals with is a string.\n\nThe third overridden method is getDefaultJavaFormat. This method returns a string representing the default Java format for date and time, which is \"yyyy-MM-dd HH:mm:ss\". This format can be used to parse and format dates in a consistent manner.\"",
        "sketchy_description": "The public class CalendarStringHandler, which extends AbstractCalendarCellHandler, is designed to handle the conversion of Calendar values into String representations specifically for use in Excel cells. This is particularly useful when dealing with date and time values that need to be formatted and displayed in a spreadsheet.\n\nThe class provides a protected method setCellValue, which takes a RowContext, an ExcelFieldConfig, a Cell, and a Calendar value as parameters. This method is responsible for setting the value of an Excel cell as a formatted string. The formatting is determined by the Calendar value and the configuration provided by the ExcelFieldConfig, ensuring that the date and time are represented in a way that is consistent with the desired Excel format.\n\nAdditionally, the class includes a public method getExcelType, which returns the ExcelType associated with this handler. In this case, the handler deals with strings, so it returns ExcelType.STRING. This method is useful for identifying the type of data that the handler is expected to process and return.\n\nLastly, the class offers a public method getDefaultJavaFormat, which returns a default Java format string for date-time representation. The default format provided is \"yyyy-MM-dd HH:mm:ss\", which is a commonly used pattern for representing date and time in a year-month-day hour-minute-second format. This default format can be used as a starting point for formatting date-time values in Java before they are converted to strings for Excel cells.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/calendar/CalendarStringHandler.java",
        "class_name": "CalendarStringHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "CalendarStringHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/CalendarStringHandlerTest.java"
        },
        "task_id": 69,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.calendar;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport io.github.zouzhiy.excel.utils.ExcelDateFormatUtils;\nimport org.apache.poi.ss.usermodel.Cell;\n\nimport java.util.Calendar;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class CalendarStringHandler extends AbstractCalendarCellHandler {\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, Calendar value) {\n        String javaFormat = this.getJavaFormat(excelFieldConfig);\n        String strValue = ExcelDateFormatUtils.format(value, javaFormat);\n        cell.setCellValue(strValue);\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.STRING;\n    }\n\n    @Override\n    public String getDefaultJavaFormat() {\n        return \"yyyy-MM-dd HH:mm:ss\";\n    }\n\n}\n"
    },
    {
        "detailed_description": "The public class DefaultZouzhiyExcelFactory implements the ZouzhiyExcelFactory interface, which is designed to handle operations related to Excel files. The class has a private member, configuration, of type Configuration. The constructor of this class takes a Configuration object as an argument and assigns it to the configuration member.\n\nThe class provides several methods for reading and writing Excel files. The getConfiguration method returns the configuration object. The getWorkbookRead methods return a WorkbookRead object, which is used to read data from an Excel file. There are two versions of this method, one that takes a WorkbookParameter and a Class object, and another that takes a WorkbookParameter and an ExcelClassConfig object.\n\nSimilarly, the getWorkbookWrite methods return a WorkbookWrite object, which is used to write data to an Excel file. There are also two versions of this method, one that takes a WorkbookParameter and a Class object, and another that takes a WorkbookParameter and an ExcelClassConfig object.\n\nThe read and write methods return WorkbookReadBuilder and WorkbookWriteBuilder objects, respectively, which are used to build the WorkbookRead and WorkbookWrite objects. There are multiple versions of these methods, some of which take a File or an InputStream for reading, and others that take a File or an OutputStream for writing.\"",
        "sketchy_description": "The public class DefaultZouzhiyExcelFactory, which implements the ZouzhiyExcelFactory interface, is designed to provide factory methods for creating objects that facilitate reading from and writing to Excel workbooks. The class is initialized with a Configuration object, which is used to configure the behavior of the factory methods.\n\nThe constructor for this class takes a Configuration object as an argument and initializes the factory with the provided configuration. This allows the factory to be customized according to the needs of the application.\n\nThe getConfiguration method returns the Configuration object that was used to initialize the factory. This allows users to retrieve the configuration for inspection or modification.\n\nThe class provides several methods for creating instances of WorkbookRead and WorkbookWrite, which are used for reading from and writing to Excel workbooks, respectively. These methods take a WorkbookParameter object and optionally a Class<?> or ExcelClassConfig object to specify the type of data to be read or written and the configuration for the Excel class.\n\nAdditionally, the class offers builder methods for creating WorkbookRead and WorkbookWrite instances with default settings or with specified input and output sources such as files or streams. The read and write methods without parameters return builders with default settings, while the overloaded versions of these methods accept a File or InputStream for reading and a File or OutputStream for writing, allowing for greater flexibility in specifying the source or destination of the Excel data.\n\nIn summary, the DefaultZouzhiyExcelFactory class provides a comprehensive set of methods for creating objects that handle the reading and writing of Excel data, with the ability to customize the behavior through configuration and to specify the data source or destination.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/builder/DefaultZouzhiyExcelFactory.java",
        "class_name": "DefaultZouzhiyExcelFactory",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "DefaultZouzhiyExcelFactoryTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/builder/DefaultZouzhiyExcelFactoryTest.java"
        },
        "task_id": 70,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.builder;\n\nimport io.github.zouzhiy.excel.metadata.Configuration;\nimport io.github.zouzhiy.excel.metadata.config.ExcelClassConfig;\nimport io.github.zouzhiy.excel.metadata.parameter.WorkbookParameter;\nimport io.github.zouzhiy.excel.read.WorkbookRead;\nimport io.github.zouzhiy.excel.read.defaults.DefaultWorkbookRead;\nimport io.github.zouzhiy.excel.write.WorkbookWrite;\nimport io.github.zouzhiy.excel.write.defaults.DefaultWorkbookWrite;\n\nimport java.io.File;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class DefaultZouzhiyExcelFactory implements ZouzhiyExcelFactory {\n\n    private final Configuration configuration;\n\n    public DefaultZouzhiyExcelFactory(Configuration configuration) {\n        this.configuration = configuration;\n    }\n\n    @Override\n    public Configuration getConfiguration() {\n        return configuration;\n    }\n\n    @Override\n    public WorkbookRead getWorkbookRead(WorkbookParameter workbookParameter, Class<?> clazz) {\n        return new DefaultWorkbookRead(configuration, workbookParameter, configuration.getExcelAnnotationParse().findForClass(clazz));\n    }\n\n    @Override\n    public WorkbookRead getWorkbookRead(WorkbookParameter workbookParameter, ExcelClassConfig excelClassConfig) {\n        return new DefaultWorkbookRead(configuration, workbookParameter, excelClassConfig);\n    }\n\n    @Override\n    public WorkbookWrite getWorkbookWrite(WorkbookParameter workbookParameter, Class<?> clazz) {\n        return new DefaultWorkbookWrite(configuration, workbookParameter, configuration.getExcelAnnotationParse().findForClass(clazz));\n    }\n\n    @Override\n    public WorkbookWrite getWorkbookWrite(WorkbookParameter workbookParameter, ExcelClassConfig excelClassConfig) {\n        return new DefaultWorkbookWrite(configuration, workbookParameter, excelClassConfig);\n    }\n\n    @Override\n    public WorkbookReadBuilder read() {\n        return new WorkbookReadBuilder(this);\n    }\n\n    @Override\n    public WorkbookReadBuilder read(File inputFile) {\n        return new WorkbookReadBuilder(this).input(inputFile);\n    }\n\n    @Override\n    public WorkbookReadBuilder read(InputStream inputStream) {\n        return new WorkbookReadBuilder(this).input(inputStream);\n    }\n\n    @Override\n    public WorkbookWriteBuilder write() {\n        return new WorkbookWriteBuilder(this);\n    }\n\n    @Override\n    public WorkbookWriteBuilder write(File outputFile) {\n        return new WorkbookWriteBuilder(this).output(outputFile);\n    }\n\n    @Override\n    public WorkbookWriteBuilder write(OutputStream outputStream) {\n        return new WorkbookWriteBuilder(this).output(outputStream);\n    }\n}\n"
    },
    {
        "detailed_description": "The public class ExcelFontConfig is designed to represent the configuration of a font in an Excel document. This class contains several private final fields, each with a default value, that represent different aspects of the font configuration. These fields include the font name, font height, font height in points, whether the font is italic, whether the font has a strikeout, the color of the font, the type offset of the font, whether the font has an underline, the charset of the font, and whether the font is bold. \n\nThe class also includes several static methods that return default configurations for different parts of an Excel document, such as the title, header, and data. These methods use the Builder pattern to create and return an instance of ExcelFontConfig with the appropriate settings. \n\nFinally, there is a static method that takes an ExcelFont object as an argument and returns an ExcelFontConfig object with the same settings. This method is useful for converting between the two types of objects.\"",
        "sketchy_description": "The public class ExcelFontConfig is designed to encapsulate the various font configuration options that can be applied to text within an Excel document. This includes settings such as the font name, font size, italicization, strikeout, color, type offset for superscript or subscript, underline style, character set, and bold style. The class provides a set of default values for these properties, which can be used to create a standardized look for different types of text within an Excel file, such as titles, headers, and data.\n\nThe class exposes several static methods that return default configurations tailored for specific purposes. The getDefaultExcelFontConfigTitle method returns a font configuration that is suitable for use with titles in an Excel document. Similarly, the getDefaultExcelFontConfigHead method provides a default configuration for header text, and the getDefaultExcelFontConfigData method returns a configuration that is appropriate for the main body of data within the spreadsheet.\n\nAdditionally, the class offers a method called buildByExcelFont, which allows for the creation of an ExcelFontConfig instance based on an existing ExcelFont object. This method enables users to easily replicate or modify the font settings of an existing piece of text within an Excel document, facilitating consistency and ease of formatting across different parts of the spreadsheet.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/metadata/config/ExcelFontConfig.java",
        "class_name": "ExcelFontConfig",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "ExcelFontConfigTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/metadata/config/ExcelFontConfigTest.java"
        },
        "task_id": 71,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.metadata.config;\n\nimport io.github.zouzhiy.excel.annotation.ExcelFont;\nimport io.github.zouzhiy.excel.enums.FontTypeOffset;\nimport lombok.Builder;\nimport lombok.EqualsAndHashCode;\nimport lombok.Getter;\nimport lombok.ToString;\nimport org.apache.poi.common.usermodel.fonts.FontCharset;\nimport org.apache.poi.ss.usermodel.Font;\nimport org.apache.poi.ss.usermodel.FontUnderline;\n\n/**\n * \u5b57\u4f53\u914d\u7f6e {@link io.github.zouzhiy.excel.annotation.ExcelFont}\n *\n * @author zouzhiy\n * @since 2022/7/2\n */\n@Getter\n@ToString\n@EqualsAndHashCode\n@Builder\npublic class ExcelFontConfig {\n\n    /**\n     * \u5b57\u4f53\u540d\u79f0\n     */\n    @Builder.Default\n    private final String fontName = \"\u5b8b\u4f53\";\n\n    /**\n     * \u5b57\u4f53\u5927\u5c0f\u3002\u7279\u6b8a\u5355\u4f4d\n     */\n    @Builder.Default\n    private final short fontHeight = -1;\n\n    /**\n     * \u5b57\u4f53\u5927\u5c0f\u3002\u901a\u5e38\u770b\u5230\u7684\u5b57\u4f53\u5927\u5c0f\n     */\n    @Builder.Default\n    private final short fontHeightInPoints = -1;\n\n    /**\n     * \u659c\u4f53\n     */\n    @Builder.Default\n    private final boolean italic = false;\n\n    /**\n     * \u5220\u9664\u7ebf\n     */\n    @Builder.Default\n    private final boolean strikeout = false;\n\n    /**\n     * \u5b57\u4f53\u989c\u8272\n     */\n    @Builder.Default\n    private final short color = Font.COLOR_NORMAL;\n\n    /**\n     *\n     */\n    @Builder.Default\n    private final FontTypeOffset typeOffset = FontTypeOffset.NONE;\n\n    /**\n     * \u4e0b\u5212\u7ebf\n     */\n    @Builder.Default\n    private final FontUnderline underline = FontUnderline.NONE;\n\n    /**\n     * \u5b57\u7b26\n     */\n    @Builder.Default\n    private final FontCharset charset = FontCharset.DEFAULT;\n\n    /**\n     * \u52a0\u7c97\n     */\n    @Builder.Default\n    private final boolean bold = false;\n\n    public static ExcelFontConfig getDefaultExcelFontConfigTitle() {\n        return ExcelFontConfig.builder()\n                .fontHeightInPoints((short) 16)\n                .bold(true)\n                .build();\n\n    }\n\n    public static ExcelFontConfig getDefaultExcelFontConfigHead() {\n        return ExcelFontConfig.builder()\n                .fontHeightInPoints((short) 13)\n                .bold(true)\n                .build();\n    }\n\n    public static ExcelFontConfig getDefaultExcelFontConfigData() {\n        return ExcelFontConfig.builder()\n                .fontHeightInPoints((short) 10)\n                .build();\n    }\n\n    public static ExcelFontConfig buildByExcelFont(ExcelFont excelFont) {\n        return ExcelFontConfig.builder()\n                .fontName(excelFont.fontName())\n                .fontHeight(excelFont.fontHeight())\n                .fontHeightInPoints(excelFont.fontHeightInPoints())\n                .italic(excelFont.italic())\n                .strikeout(excelFont.strikeout())\n                .color(excelFont.color())\n                .typeOffset(excelFont.typeOffset())\n                .underline(excelFont.underline())\n                .charset(excelFont.charset())\n                .bold(excelFont.bold())\n                .build();\n    }\n}\n"
    },
    {
        "detailed_description": "The public class LocalDateDateHandler is a subclass of the AbstractLocalDateCellHandler class. This class is designed to handle date values in Excel cells. It overrides three methods from its superclass.\n\nThe first overridden method is setCellValue. This method takes four parameters: a RowContext object, an ExcelFieldConfig object, a Cell object, and a LocalDate object. The method is designed to set the value of the specified cell to the provided LocalDate value.\n\nThe second overridden method is getExcelType. This method does not take any parameters and returns an ExcelType enumeration value. Specifically, it returns ExcelType.DATE, indicating that this handler is used for date values in Excel.\n\nThe third overridden method is getDefaultExcelFormat. This method does not take any parameters and returns a String. The returned string is \"yyyy-MM-dd\", which is a common format for representing dates. This suggests that the handler uses this format as the default when writing dates to Excel cells.\"",
        "sketchy_description": "The public class LocalDateDateHandler, which extends the AbstractLocalDateCellHandler, is specifically designed to manage the process of setting cell values for LocalDate objects within an Excel spreadsheet. This functionality is crucial when dealing with date representations in Excel, ensuring that dates are formatted and stored correctly.\n\nThe class provides a protected method setCellValue, which takes a RowContext, an ExcelFieldConfig, a Cell, and a LocalDate value as parameters. This method is responsible for correctly setting the value of a cell in an Excel sheet to the provided LocalDate value, ensuring that the date is represented accurately within the spreadsheet.\n\nAdditionally, the class offers a public method getExcelType, which returns the ExcelType enumeration value that corresponds to date. This method is useful for identifying the type of data that is being handled, particularly when working with various data types in Excel.\n\nLastly, the class includes a public method getDefaultExcelFormat, which returns the default Excel format string for date cells. The format returned is \"yyyy-MM-dd\", which is a commonly used date format in Excel spreadsheets. This method provides a standard format that can be applied to date cells to maintain consistency and readability within the document.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/localdate/LocalDateDateHandler.java",
        "class_name": "LocalDateDateHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "LocalDateDateHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/LocalDateDateHandlerTest.java"
        },
        "task_id": 72,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.localdate;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport org.apache.poi.ss.usermodel.Cell;\n\nimport java.time.LocalDate;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class LocalDateDateHandler extends AbstractLocalDateCellHandler {\n\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, LocalDate value) {\n        cell.setCellValue(value);\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.DATE;\n    }\n\n    @Override\n    public String getDefaultExcelFormat() {\n        return \"yyyy-MM-dd\";\n    }\n}\n"
    },
    {
        "detailed_description": "The public class PaymentService is designed to handle payment processing and rollback operations. It has a private member, globalConfigs, which is an instance of the GlobalConfigs class. This instance is initialized through the constructor of the PaymentService class, which takes a GlobalConfigs object as an argument.\n\nThe class has two public methods: newPayment and rollbackPayment. Both methods take an Order object as an argument.\n\nThe newPayment method is responsible for processing payments. It prints a message indicating that a mock payment has been processed and the order price. It also logs the same information for debugging purposes. The method then checks the status of the payment using the statusPayment method of the globalConfigs object. If the status is SUCCESS, the method returns true, indicating that the payment was processed successfully. Otherwise, it returns false.\n\nThe rollbackPayment method is responsible for processing payment rollbacks. It prints a message indicating that a mock payment has been refunded and the order price. It also logs the same information for debugging purposes. This method always returns true, indicating that the rollback was processed successfully. This class is useful for simulating payment processing and rollback operations in a system.\"",
        "sketchy_description": "The public class PaymentService is designed to handle the intricacies of payment processing, utilizing a set of global configurations to ensure consistency and reliability across transactions. The class is initialized through a constructor that requires an instance of GlobalConfigs, which encapsulates the necessary settings and rules for payment processing.\n\nOnce an instance of PaymentService is created, it offers two key public methods to manage payments. The newPayment method takes an Order object as an argument and processes the payment for that order. The success of the payment process is contingent upon the statusPayment method within the GlobalConfigs instance, and the newPayment method returns a boolean value indicating whether the payment was successful.\n\nIn addition to processing new payments, the PaymentService class also provides a rollbackPayment method. This method is intended to reverse a payment for a given order, simulating a refund scenario. The rollbackPayment method is designed to always return true, signifying that the mock payment was refunded without any issues. This functionality is crucial for maintaining the integrity of the payment system, especially in cases where transactions need to be reversed due to various reasons such as order cancellation or payment disputes.",
        "file": "kafka-microservices-with-saga/payment/src/main/java/com/sylleryum/payment/service/PaymentService.java",
        "class_name": "PaymentService",
        "repo_metadata": {
            "repo_name": "kafka-microservices-with-saga"
        },
        "evaluation_metadata": {
            "test_class_name": "PaymentServiceTest",
            "test_file": "kafka-microservices-with-saga/payment/src/test/java/com/sylleryum/payment/service/PaymentServiceTest.java"
        },
        "task_id": 73,
        "ground_truth_class_body": "package com.sylleryum.payment.service;\n\nimport com.sylleryum.common.config.GlobalConfigs;\nimport com.sylleryum.common.entity.Order;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Service;\n\n@Service\n@Slf4j\npublic class PaymentService {\n\n    private final GlobalConfigs globalConfigs;\n\n    public PaymentService(GlobalConfigs globalConfigs) {\n        this.globalConfigs = globalConfigs;\n    }\n\n    /**\n     * process payment, result will be based on {@link GlobalConfigs}\n     * statusPayment (if success is set to partial, result will be random)\n     * @param order\n     * @return if payment was processed successfully, true, else false\n     */\n    public boolean newPayment(Order order){\n        boolean result;\n        System.out.println(\"******Mock payment processed \"+order.getOrderPrice());\n        log.debug(\"Mock payment processed {}\",order.getOrderPrice());\n        result = globalConfigs.statusPayment() == globalConfigs.SUCCESS;\n\n        return result;\n    }\n\n    /**\n     * process rollback\n     * @param order\n     * @return if payment was processed successfully, true, else false\n     */\n    public boolean rollbackPayment(Order order){\n        System.out.println(\"******Mock payment refunded \"+order.getOrderPrice());\n        log.debug(\"Mock payment refund {}\",order.getOrderPrice());\n        return true;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class BigIntegerBooleanHandler is a subclass of the AbstractBigIntegerCellHandler class. This class is designed to handle BigInteger values in the context of Excel cells, specifically for boolean values. It contains a private static final BigInteger field named TRUE_VALUE, which is set to BigInteger.ONE, representing the boolean value of true in the context of BigInteger. \n\nThe class overrides two methods from its superclass. The first method, setCellValue, takes four parameters: a RowContext object, an ExcelFieldConfig object, a Cell object, and a BigInteger value. This method is responsible for setting the value of the provided cell. It does this by comparing the provided BigInteger value to TRUE_VALUE. If they are equal, it sets the cell's value to true; otherwise, it sets the cell's value to false.\n\nThe second overridden method, getExcelType, takes no parameters and returns an ExcelType enumeration. Specifically, it returns ExcelType.BOOLEAN, indicating that this handler is used for boolean values in Excel. This method is useful for determining the type of data that this handler is responsible for when interacting with Excel files.\"",
        "sketchy_description": "The public class BigIntegerBooleanHandler, which extends AbstractBigIntegerCellHandler, is designed to handle the conversion of BigInteger values to boolean values specifically for Excel cells. This functionality is particularly useful when dealing with large integer values that need to be represented as boolean values within an Excel spreadsheet. The class defines a constant TRUE_VALUE which is set to BigInteger.ONE, indicating the value that will be considered as 'true' in the context of this handler.\n\nThe class provides a protected method setCellValue, which takes a RowContext, an ExcelFieldConfig, a Cell, and a BigInteger value as parameters. This method is responsible for setting the cell's value within an Excel sheet. If the BigInteger value passed to the method is equal to the predefined TRUE_VALUE, the cell's value is set to true; otherwise, it is set to false. This method ensures that BigInteger values are appropriately translated into boolean values that can be understood and used within Excel.\n\nAdditionally, the class offers a public method getExcelType, which returns the ExcelType enumeration value for boolean. This method is useful for identifying the type of data that the handler is dealing with, which in this case is a boolean type. This information can be used to ensure that the data is being processed and formatted correctly within the Excel environment.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/biginteger/BigIntegerBooleanHandler.java",
        "class_name": "IntegerBooleanHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "IntegerBooleanHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/BigIntegerBooleanHandlerTest.java"
        },
        "task_id": 74,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.biginteger;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport org.apache.poi.ss.usermodel.Cell;\n\nimport java.math.BigInteger;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class BigIntegerBooleanHandler extends AbstractBigIntegerCellHandler {\n\n    private final static BigInteger TRUE_VALUE = BigInteger.ONE;\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, BigInteger value) {\n        cell.setCellValue(value.compareTo(TRUE_VALUE) == 0);\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.BOOLEAN;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class EstimateSplitPoints is designed to estimate split points in a dataset. This class has four private fields: rowKey1, records, numPartitions, and sketchSize. The rowKey1 is a Field object that represents the first row key field in a schema. The records is an Iterable collection of Record objects. The numPartitions is an integer that represents the number of partitions. The sketchSize is an integer that represents the size of the sketch.\n\nThe class has two constructors. The first constructor takes four parameters: a Schema object, an Iterable collection of Record objects, an integer for the number of partitions, and an integer for the sketch size. If the number of partitions is less than 2, it throws an IllegalArgumentException. The second constructor takes three parameters: a Schema object, an Iterable collection of Record objects, and an integer for the number of partitions. It calls the first constructor with a default sketch size of 32768.\n\nThe class has a public method named estimate. This method estimates the split points in the dataset. If the number of partitions is 1, it returns an empty list. Otherwise, it creates an ItemsSketch object and updates it with the values from the records. It then gets the quantiles from the sketch and copies them into a new array, excluding the first and last entries. If the length of the new array is not equal to the number of partitions minus 1, it throws a RuntimeException. It then removes any duplicate values from the array and sorts the remaining values. If the type of the row key is a ByteArrayType, it converts the sorted values into a list of byte arrays. Otherwise, it converts the sorted values into a list of Objects. The method finally returns the list of split points.\"",
        "sketchy_description": "The public class EstimateSplitPoints is designed to estimate split points for the purpose of partitioning a dataset. This is particularly useful in distributed computing environments where data needs to be divided across multiple nodes for parallel processing. The class is initialized with a schema that defines the structure of the data, an iterable collection of records which represents the dataset, the desired number of partitions to split the dataset into, and an optional sketch size that can be used to control the granularity of the estimation process.\n\nThe constructor of the class takes four parameters: a schema, an iterable of records, the number of partitions, and the sketch size. If the number of partitions is less than 2, an IllegalArgumentException is thrown, as it is not logical to partition data into less than two parts. The sketch size is an advanced parameter that users can specify to influence the accuracy and performance of the split point estimation.\n\nThere is an overloaded constructor that accepts only three parameters: a schema, an iterable of records, and the number of partitions. This constructor uses a default sketch size, making it simpler for users who do not need to control this aspect of the estimation process.\n\nThe estimate method is a key function of the class that performs the actual estimation of split points. It processes the provided records according to the schema and the number of partitions, and returns a list of objects that represent the estimated split points. If the number of partitions provided is incorrect, a RuntimeException is thrown, indicating that the estimation process cannot proceed.\n\nIn summary, the EstimateSplitPoints class provides a structured way to estimate how a dataset can be divided into a specified number of partitions, with constructors that allow for both simple and advanced configurations, and a method that carries out the estimation and returns the results for further processing.",
        "file": "sleeper/java/configuration/src/main/java/sleeper/configuration/EstimateSplitPoints.java",
        "class_name": "EstimateSplitPoints",
        "repo_metadata": {
            "repo_name": "sleeper"
        },
        "evaluation_metadata": {
            "test_class_name": "EstimateSplitPointsTest",
            "test_file": "sleeper/java/configuration/src/test/java/sleeper/configuration/EstimateSplitPointsTest.java"
        },
        "task_id": 75,
        "ground_truth_class_body": "/*\n * Copyright 2022-2023 Crown Copyright\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage sleeper.configuration;\n\nimport com.facebook.collections.ByteArray;\nimport org.apache.datasketches.quantiles.ItemsSketch;\n\nimport sleeper.core.record.Record;\nimport sleeper.core.schema.Field;\nimport sleeper.core.schema.Schema;\nimport sleeper.core.schema.type.ByteArrayType;\n\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport java.util.stream.Collectors;\n\npublic class EstimateSplitPoints {\n    private final Field rowKey1;\n    private final Iterable<Record> records;\n    private final int numPartitions;\n    private final int sketchSize;\n\n    public EstimateSplitPoints(Schema schema, Iterable<Record> records, int numPartitions, int sketchSize) {\n        if (numPartitions < 2) {\n            throw new IllegalArgumentException(\"Number of partitions must be >= 2\");\n        }\n        this.rowKey1 = schema.getRowKeyFields().get(0);\n        this.records = records;\n        this.numPartitions = numPartitions;\n        this.sketchSize = sketchSize;\n    }\n\n    public EstimateSplitPoints(Schema schema, Iterable<Record> records, int numPartitions) {\n        this(schema, records, numPartitions, 32768);\n    }\n\n    public List<Object> estimate() {\n        if (1 == numPartitions) {\n            return Collections.emptyList();\n        }\n\n        // Add all the values to the sketch\n        ItemsSketch sketch = ItemsSketch.getInstance(sketchSize, Comparator.naturalOrder());\n        for (Record record : records) {\n            Object firstRowKey = record.get(rowKey1.getName());\n            if (rowKey1.getType() instanceof ByteArrayType) {\n                sketch.update(ByteArray.wrap((byte[]) firstRowKey));\n            } else {\n                sketch.update(firstRowKey);\n            }\n        }\n\n        // The getQuantiles method returns the min and median and max given a value of 3; hence need to add one to get\n        // the correct number of split points, and need to remove the first and last entries.\n        Object[] splitPointsWithMinAndMax = sketch.getQuantiles(numPartitions + 1);\n        Object[] splitPoints = Arrays.copyOfRange(splitPointsWithMinAndMax, 1, splitPointsWithMinAndMax.length - 1);\n        if (splitPoints.length != numPartitions - 1) {\n            throw new RuntimeException(\"There should have been \" + (numPartitions - 1) + \"partitions; got \" + splitPoints.length);\n        }\n\n        // Remove any duplicate values (which means the number of split points returned may be less than that requested.\n        List<Object> deduplicatedSplitPoints = Arrays.asList(splitPoints);\n        deduplicatedSplitPoints = deduplicatedSplitPoints.stream().filter(Objects::nonNull).collect(Collectors.toList());\n        SortedSet<Object> sortedSet = new TreeSet<>(deduplicatedSplitPoints);\n\n        if (rowKey1.getType() instanceof ByteArrayType) {\n            return sortedSet.stream().map(b -> (ByteArray) b).map(ByteArray::getArray).collect(Collectors.toList());\n        }\n        return Arrays.asList(sortedSet.toArray());\n    }\n}\n"
    },
    {
        "detailed_description": "The public class ExtractKeyFunction is designed to implement the PairFunction interface, which is a part of Apache Spark's programming model for big data processing. This class is used to extract keys from rows of data. The class contains a private final integer variable numRowKeys, which represents the number of keys in each row. The class also contains a constructor that takes an integer argument for the number of row keys and initializes the object with this value. \n\nThe class overrides the call method from the PairFunction interface. This method takes a Row object as an argument and returns a Tuple2 object, which is a pair consisting of a Key and a Row. Inside the call method, a new ArrayList of Objects is created to store the keys. A for loop is used to iterate over the row keys and add them to the keys list. Then, a Key object is created from the keys list using the Key.create method. Finally, a new Tuple2 object is returned, which contains the created Key and the original Row.\n\nThe class also contains a private static final long variable serialVersionUID, which is a version control in serialization and deserialization. It is used to ensure that the same class (that was used during serialization) is loaded during deserialization.\"",
        "sketchy_description": "The public class ExtractKeyFunction is an implementation of the PairFunction interface, specifically designed to process instances of Row and extract certain key elements from them to form a pair consisting of a Key and the original Row. This functionality is particularly useful in distributed computing frameworks where data needs to be organized into key-value pairs for efficient processing.\n\nThe class contains a static final long serialVersionUID, which serves as a version control in a Serializable class. This unique identifier ensures that the serialization and deserialization processes are compatible even if the class definition changes over time.\n\nAdditionally, the class has a private final integer called numRowKeys, which specifies the number of keys that should be extracted from each Row object passed to the function.\n\nThe constructor of the ExtractKeyFunction class takes an integer argument, numRowKeys, and initializes the function with this value, setting up the necessary state to later extract the specified number of keys from each Row.\n\nThe call method is the core of the ExtractKeyFunction class. It takes a Row object as an argument and processes it to extract the keys as defined by the numRowKeys parameter. It then returns a Tuple2 object, which is a simple pair containing the extracted Key and the original Row. This method may throw an Exception, indicating that callers must handle potential errors that could occur during the key extraction process.",
        "file": "sleeper/java/bulk-import/bulk-import-runner/src/main/java/sleeper/bulkimport/job/runner/rdd/ExtractKeyFunction.java",
        "class_name": "ExtractKeyFunction",
        "repo_metadata": {
            "repo_name": "sleeper"
        },
        "evaluation_metadata": {
            "test_class_name": "ExtractKeyFunctionTest",
            "test_file": "sleeper/java/bulk-import/bulk-import-runner/src/test/java/sleeper/bulkimport/job/runner/rdd/ExtractKeyFunctionTest.java"
        },
        "task_id": 76,
        "ground_truth_class_body": "/*\n * Copyright 2022-2023 Crown Copyright\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage sleeper.bulkimport.job.runner.rdd;\n\nimport org.apache.spark.api.java.function.PairFunction;\nimport org.apache.spark.sql.Row;\nimport scala.Tuple2;\n\nimport sleeper.core.key.Key;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * An {@link ExtractKeyFunction} is a function which extracts the first n\n * columns to create a Sleeper {@link Key}.\n */\npublic class ExtractKeyFunction implements PairFunction<Row, Key, Row> {\n    private static final long serialVersionUID = 4328608066452390263L;\n\n    private final int numRowKeys;\n\n    public ExtractKeyFunction(int numRowKeys) {\n        this.numRowKeys = numRowKeys;\n    }\n\n    @Override\n    public Tuple2<Key, Row> call(Row row) throws Exception {\n        List<Object> keys = new ArrayList<>(numRowKeys);\n        for (int i = 0; i < numRowKeys; i++) {\n            keys.add(row.get(i));\n        }\n        Key key = Key.create(keys);\n        return new Tuple2<>(key, row);\n    }\n}\n"
    },
    {
        "detailed_description": "The public final class ColorUtils is a utility class that provides methods for creating and manipulating colors. This class is final, meaning it cannot be subclassed. The class has a private constructor, which means it cannot be instantiated. All of its methods are static, so they can be called directly on the class itself without creating an instance of it.\n\nThe class provides several methods for creating colors. The 'of' method takes three integer arguments representing the red, green, and blue components of a color, and returns a new Color object with those components. The 'ofRGB' method takes a single integer argument representing the RGB value of a color, and returns a new Color object with that value.\n\nThe class also provides two methods for creating random colors. The 'random' method returns a new Color object with random red, green, and blue components. The other 'random' method takes three Range objects as arguments, each representing the range of possible values for the red, green, and blue components, and returns a new Color object with random components within those ranges.\n\nThe 'anyOf' method takes an array of Color objects as an argument and returns a randomly selected one from the array.\n\nThe 'obtainRectCenterRGB' method takes a BufferedImage object and four integer arguments representing the x and y coordinates of the upper left corner of a rectangle, and the width and height of the rectangle. It returns the RGB value of the color at the center of the rectangle in the image. This method throws an InvalidSettingException if the specified rectangle is not valid for the given image.\"",
        "sketchy_description": "The public final class ColorUtils is a utility class that provides a collection of static methods for color manipulation and generation. It is designed to be a helper class and therefore cannot be instantiated, as indicated by the private constructor. The class offers a variety of methods for creating and manipulating colors.\n\nThe method `of(int r, int g, int b)` allows the creation of a color object based on individual red, green, and blue components, each expected to be within the range of 0 to 255. This method is useful when you have separate RGB values and want to create a color object from them.\n\nThe method `ofRGB(int rgb)` provides a way to create a color object from a combined RGB value, which is often represented as an integer where the red, green, and blue components are packed into a single value.\n\nThe `random()` method generates a completely random color with each of the RGB components ranging from 0 to 255. This can be used when a random color is needed for a graphical application or for generating diverse sets of colors.\n\nFor more controlled randomness, the method `random(Range<Integer> rRange, Range<Integer> gRange, Range<Integer> bRange)` generates a random color with each component within the specified ranges. This allows for the creation of colors within a certain palette or color scheme.\n\nThe `anyOf(Color... options)` method selects a random color from an array of given color options. This is particularly useful when you have a fixed set of colors and you want to choose one at random.\n\nLastly, the `obtainRectCenterRGB(BufferedImage img, int x, int y, int w, int h)` method calculates the RGB value of the color at the center of a specified rectangular region in a given image. This can be used in image processing applications where the color information of a certain area of the image is required.",
        "file": "imglib/core/src/main/java/cn/core/utils/ColorUtils.java",
        "class_name": "ColorUtils",
        "repo_metadata": {
            "repo_name": "imglib"
        },
        "evaluation_metadata": {
            "test_class_name": "ColorUtilsTest",
            "test_file": "imglib/core/src/test/java/cn/core/utils/ColorUtilsTest.java"
        },
        "task_id": 77,
        "ground_truth_class_body": "package cn.core.utils;\n\nimport cn.core.ex.InvalidSettingException;\nimport cn.core.tool.Range;\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\n\n/**\n * An util class for color.\n *\n * @author tracy\n * @since 0.2.1\n */\npublic final class ColorUtils {\n    private ColorUtils(){}\n\n    /**\n     * Get a color.\n     *\n     * @param r The red component.\n     * @param g The green component.\n     * @param b The blue component.\n     * @return The final color.\n     */\n    public static Color of(int r, int g, int b) {\n        return new Color(r, g, b);\n    }\n\n    /**\n     * Get a color.\n     *\n     * @param rgb The RGB value.\n     * @return The final color.\n     */\n    public static Color ofRGB(int rgb) {\n        return new Color(rgb);\n    }\n\n    /**\n     * Get a random color.\n     *\n     * @return The final color.\n     */\n    public static Color random() {\n        Range<Integer> range = Range.ofInt(0, 255);\n        return random(range, range, range);\n    }\n\n    /**\n     * Get a random color.\n     *\n     * @param rRange The range of red component.\n     * @param gRange The range of green component.\n     * @param bRange The range of blue component.\n     * @return The final color.\n     */\n    public static Color random(Range<Integer> rRange, Range<Integer> gRange, Range<Integer> bRange) {\n        if (rRange.getMin() < 0 || rRange.getMax() > 255) {\n            throw new InvalidSettingException(\"Color's R-value out of bounds, must limited to [0, 255].\");\n        }\n        if (gRange.getMin() < 0 || gRange.getMax() > 255) {\n            throw new InvalidSettingException(\"Color's G-value out of bounds, must limited to [0, 255].\");\n        }\n        if (bRange.getMin() < 0 || bRange.getMax() > 255) {\n            throw new InvalidSettingException(\"Color's B-value out of bounds, must limited to [0, 255].\");\n        }\n\n        int r = RandomUtils.randomInt(rRange.getMin(), rRange.getMax());\n        int g = RandomUtils.randomInt(gRange.getMin(), gRange.getMax());\n        int b = RandomUtils.randomInt(bRange.getMin(), bRange.getMax());\n        return new Color(r, g, b);\n    }\n\n    /**\n     * Select a color from multiple options.\n     *\n     * @param options All options.\n     * @return The selected color.\n     */\n    public static Color anyOf(Color... options) {\n        if (CollectionUtils.isNullOrEmpty(options)) {\n            throw new InvalidSettingException(\"No options.\");\n        }\n        int index = RandomUtils.randomInt(0, options.length - 1);\n        return options[index];\n    }\n\n    /**\n     * Gets the color's RGB of the center of the region.\n     *\n     * @param img The original image.\n     * @param x The x coordinate of the upper left corner of the rectangle.\n     * @param y The y coordinate of the upper left corner of the rectangle.\n     * @param w The width of the rectangle.\n     * @param h The height of the rectangle.\n     * @return The color's RGB value.\n     */\n    public static int obtainRectCenterRGB(BufferedImage img, int x, int y, int w, int h) {\n        ObjectUtils.excNull(img, \"BufferedImage is null.\");\n        if(w <= 0) {\n            throw new InvalidSettingException(\"The width of region cannot be less than or equal to 0.\");\n        }\n        if(h <= 0) {\n            throw new InvalidSettingException(\"The height of region cannot be less than or equal to 0.\");\n        }\n        if(x < 0) {\n            throw new InvalidSettingException(\"The x coordinate of the upper left corner cannot be less than or equal to 0.\");\n        }\n        if(y < 0) {\n            throw new InvalidSettingException(\"The y coordinate of the upper left corner cannot be less than or equal to 0.\");\n        }\n\n        if((x + w) > img.getWidth()) {\n            throw new InvalidSettingException(\"The specified region crosses the width of the image.\");\n        }\n        if((y + h) > img.getHeight()) {\n            throw new InvalidSettingException(\"The specified region crosses the height of the image.\");\n        }\n\n        int centerX = x + w / 2;\n        int centerY = y + h / 2;\n        return img.getRGB(centerX, centerY);\n    }\n\n}\n"
    },
    {
        "detailed_description": "The public class TimestampStringHandler is a subclass of the AbstractTimestampCellHandler class. This class is designed to handle timestamp data in string format. It contains a private member, dateTimeFormatterMap, which is a concurrent hash map that maps strings to DateTimeFormatter objects. This map is initialized with an initial capacity of 16.\n\nThe class overrides three methods from its superclass. The getExcelType method returns an enumeration value of ExcelType.STRING, indicating that this handler is used for string type data in Excel. The getDefaultJavaFormat method returns a string that represents the default format for date and time in Java, which is \"yyyy-MM-dd HH:mm:ss\".\n\nThe setCellValue method is a protected method that sets the value of a cell in an Excel row. It takes four parameters: a RowContext object that represents the current row, an ExcelFieldConfig object that contains configuration information for the Excel field, a Cell object that represents the cell to be set, and a Timestamp object that represents the value to be set. The method first retrieves the Java format for the Excel field configuration, then formats the timestamp value according to this format, and finally sets the cell's value to the formatted string.\"",
        "sketchy_description": "The public class TimestampStringHandler, which extends the AbstractTimestampCellHandler, is specialized in converting Timestamp values into formatted strings suitable for display in Excel cells. This class maintains a map of DateTimeFormatter objects to efficiently format date-time values according to different patterns. The map is initialized as a concurrent hash map with an initial capacity of 16, allowing thread-safe operations.\n\nThe class overrides several methods from its superclass to provide specific functionality for handling Timestamp values as strings in Excel. The getExcelType method indicates that this handler is associated with string values in Excel by returning the ExcelType.STRING enum value. This is important for the Excel exporting mechanism to understand how to process the data.\n\nAnother overridden method is getDefaultJavaFormat, which provides the default Java format string for date-time values. This method returns the string \"yyyy-MM-dd HH:mm:ss\", which is a commonly used pattern for representing date and time.\n\nThe setCellValue method is a crucial part of this class, as it takes a RowContext, an ExcelFieldConfig, a Cell, and a Timestamp value as parameters. It then formats the Timestamp value into a string using the appropriate DateTimeFormatter from the map, based on the Java format specified in the ExcelFieldConfig. The resulting string is then set as the value of the provided Cell, effectively converting the Timestamp into a human-readable format for Excel users. This method is protected, meaning it is intended to be accessed within the class itself and by subclasses, but not by external classes directly.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/timestamp/TimestampStringHandler.java",
        "class_name": "TimestampStringHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "TimestampStringHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/TimestampStringHandlerTest.java"
        },
        "task_id": 78,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.timestamp;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport io.github.zouzhiy.excel.utils.ExcelDateFormatUtils;\nimport org.apache.poi.ss.usermodel.Cell;\n\nimport java.sql.Timestamp;\nimport java.time.format.DateTimeFormatter;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class TimestampStringHandler extends AbstractTimestampCellHandler {\n\n    private final Map<String, DateTimeFormatter> dateTimeFormatterMap = new ConcurrentHashMap<>(16);\n\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.STRING;\n    }\n\n    @Override\n    public String getDefaultJavaFormat() {\n        return \"yyyy-MM-dd HH:mm:ss\";\n    }\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, Timestamp value) {\n        String javaFormat = this.getJavaFormat(excelFieldConfig);\n        String strValue = ExcelDateFormatUtils.format(value, javaFormat);\n        cell.setCellValue(strValue);\n    }\n}\n"
    },
    {
        "detailed_description": "The public class ByteArrayPdfSource is a subclass of the AbstractPdfBoxSource class, with a generic type of byte array. This class is designed to handle PDF sources that are represented as byte arrays. The constructor for this class takes a byte array as an argument, which represents the source of the PDF, and passes it to the superclass constructor. The class overrides the doLoad method from the superclass, which is designed to load the PDF document from the source. In this case, the source is a byte array, so the method uses the PDDocument.load method to load the PDF document from the byte array. This method can throw an IOException, which must be handled by the caller.\"",
        "sketchy_description": "The public class ByteArrayPdfSource, which extends the AbstractPdfBoxSource class with a generic type of byte array, is designed to handle PDF data that is provided as a byte array. This is particularly useful when dealing with PDF content that is stored in memory rather than on disk. The constructor for this class accepts a single argument, a byte array, which represents the source of the PDF data. This constructor is responsible for initializing the ByteArrayPdfSource object with the provided byte array.\n\nOnce the object has been initialized, it exposes a protected method named doLoad, which is responsible for loading the PDF document from the byte array source. This method is declared as protected, meaning it is intended to be accessed within the class itself and by subclasses, and it throws an IOException, indicating that callers must handle potential input/output exceptions that may occur during the loading process. The doLoad method utilizes the PDDocument class from the PDFBox library to parse the byte array and create a PDDocument object, which represents the PDF document in a format that can be manipulated and accessed programmatically.",
        "file": "imglib/pipe/src/main/java/cn/pipe/in/pdf/ByteArrayPdfSource.java",
        "class_name": "ByteArrayPdfSource",
        "repo_metadata": {
            "repo_name": "imglib"
        },
        "evaluation_metadata": {
            "test_class_name": "ByteArrayPdfSourceTest",
            "test_file": "imglib/pipe/src/test/java/cn/pipe/in/pdf/ByteArrayPdfSourceTest.java"
        },
        "task_id": 79,
        "ground_truth_class_body": "package cn.pipe.in.pdf;\n\nimport cn.pipe.in.AbstractPdfBoxSource;\nimport org.apache.pdfbox.pdmodel.PDDocument;\n\nimport java.io.IOException;\n\n/**\n * A pdf source that from byte array.\n *\n * @author tracy\n * @since 0.2.1\n */\npublic class ByteArrayPdfSource extends AbstractPdfBoxSource<byte[]> {\n\n    public ByteArrayPdfSource(byte[] source) {\n        super(source);\n    }\n\n    @Override\n    protected PDDocument doLoad() throws IOException {\n        return PDDocument.load(source);\n    }\n}\n"
    },
    {
        "detailed_description": "The public class DefaultSheetCellStyleRead implements the SheetCellStyleRead interface, which is designed to read and manage the style of cells in a sheet. The class has a private final member, sheetContext, which is an instance of the SheetContext class. This member is initialized through the constructor of the DefaultSheetCellStyleRead class, which takes a SheetContext object as an argument.\n\nThe class overrides two methods from the SheetCellStyleRead interface: getSheetContext and read. The getSheetContext method returns the current SheetContext object. The read method is responsible for reading the style of the title, header, and data cells from the sheet and storing them in the SheetContext object. It first gets the title row index and returns if it is -1. Then, it reads the styles of the title, header, and data cells using the RowStyleRead object and stores them in the SheetContext object.\n\nThe class also has a private method, getRowStyleRead, which returns an instance of the RowStyleRead class. This method first gets the RowStyleRead class from the ExcelClassConfig object in the SheetContext. If it is null, it sets it to the default RowStyleRead class. Then, it gets the RowStyleRead object from the RowStyleReadRegistry in the Configuration object of the SheetContext.\"",
        "sketchy_description": "The public class DefaultSheetCellStyleRead implements the SheetCellStyleRead interface and is responsible for handling the reading and application of cell styles within a sheet, as defined by a given SheetContext. The class contains a private final field named sheetContext, which holds the context of the sheet including all necessary information and parameters required for the style reading process.\n\nThe constructor of the class, public DefaultSheetCellStyleRead(SheetContext sheetContext), is tasked with initializing an instance of DefaultSheetCellStyleRead with a specific SheetContext passed as a parameter. This setup ensures that the instance is ready to operate within the context of the provided sheet.\n\nOnce an instance is created, the public method getSheetContext() can be called to retrieve the SheetContext associated with this instance. This method is essential for accessing the context outside of the class when needed.\n\nThe public method read() is a key functionality of the class, where it reads the cell styles from the sheet context and applies them accordingly to the title, header, and data cells of the sheet. This method encapsulates the logic required to ensure that the sheet's appearance is consistent with the defined styles.\n\nLastly, the private method getRowStyleRead() is used internally to determine the appropriate RowStyleRead implementation to use for reading row styles. This decision is based on the configuration set within the SheetContext. This method is not exposed publicly but is crucial for the internal workings of the class, allowing it to adapt to different row style reading strategies as dictated by the context's configuration.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/cellstyle/defaults/DefaultSheetCellStyleRead.java",
        "class_name": "DefaultSheetCellStyleRead",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "DefaultSheetCellStyleReadTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/cellstyle/defaults/DefaultSheetCellStyleReadTest.java"
        },
        "task_id": 80,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.cellstyle.defaults;\n\nimport io.github.zouzhiy.excel.cellstyle.RowStyleRead;\nimport io.github.zouzhiy.excel.cellstyle.SheetCellStyleRead;\nimport io.github.zouzhiy.excel.cellstyle.registry.RowStyleReadRegistry;\nimport io.github.zouzhiy.excel.context.SheetContext;\nimport io.github.zouzhiy.excel.metadata.result.CellStyleResultSet;\nimport org.apache.poi.ss.usermodel.CellStyle;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class DefaultSheetCellStyleRead implements SheetCellStyleRead {\n\n    private final SheetContext sheetContext;\n\n    public DefaultSheetCellStyleRead(SheetContext sheetContext) {\n        this.sheetContext = sheetContext;\n    }\n\n    @Override\n    public SheetContext getSheetContext() {\n        return sheetContext;\n    }\n\n    @Override\n    public void read() {\n        SheetContext sheetContext = this.getSheetContext();\n\n        Integer titleRowIndex = this.sheetContext.getSheetParameter().getTitleRowStartIndex();\n        if (titleRowIndex == -1) {\n            return;\n        }\n        RowStyleRead rowStyleRead = this.getRowStyleRead();\n\n        CellStyle titleCellStyle = rowStyleRead.readTitle(sheetContext);\n        sheetContext.putTitleCellStyle(sheetContext.getExcelClassConfig(), titleCellStyle);\n\n        CellStyleResultSet headCellStyleResultSet = rowStyleRead.readHead(sheetContext);\n        sheetContext.putHeadCellStyle(headCellStyleResultSet);\n\n        CellStyleResultSet dataCellStyleResultSet = rowStyleRead.readData(sheetContext);\n        sheetContext.putDataCellStyle(dataCellStyleResultSet);\n\n    }\n\n    private RowStyleRead getRowStyleRead() {\n        Class<? extends RowStyleRead> rowStyleReadClazz = this.sheetContext.getExcelClassConfig().getRowStyleRead();\n        if (rowStyleReadClazz == null) {\n            rowStyleReadClazz = RowStyleReadRegistry.DEFAULT_ROW_STYLE_READ_CLASS;\n        }\n        return this.getSheetContext().getConfiguration().getRowStyleReadRegistry().getMappingRowStyleRead(rowStyleReadClazz);\n    }\n\n}\n"
    },
    {
        "detailed_description": "The public class S3ResultsOutput implements the ResultsOutput interface and is designed to handle the output of results to an S3 bucket. This class contains several private fields, including a Logger instance for logging, a Schema object to represent the schema of the data, a String for the S3 bucket name, a String for the file system, a long for the row group size, an int for the page size, a String for the compression codec, and three booleans for dictionary encoding for row key fields, sort key fields, and value fields.\n\nThe constructor for this class takes three arguments: an InstanceProperties object, a TableProperties object, and a Map of configuration settings. The constructor initializes the fields of the class based on these arguments and the properties they contain. If the S3 bucket is not specified in the configuration or the instance properties, an IllegalArgumentException is thrown.\n\nThe class also overrides the publish method from the ResultsOutput interface. This method takes a Query object and a CloseableIterator of Records, and writes the results of the query to a Parquet file in the specified S3 bucket. The method logs the progress of the writing process, and returns a ResultsOutputInfo object containing the count of records written and the output location. If an exception occurs during the writing process, it is logged and included in the returned ResultsOutputInfo object. Finally, the method attempts to close the results iterator, logging any IOException that may occur.\"",
        "sketchy_description": "The public class S3ResultsOutput, which implements the ResultsOutput interface, is designed to handle the output of query results to an Amazon S3 bucket. This class is equipped with a variety of class variables, including a logger for monitoring its operations, constants for S3 bucket configuration, and several settings related to the output format such as compression codec, row group size, and page size. Additionally, it holds a schema object and flags for dictionary encoding of different key fields and value fields.\n\nThe constructor of the S3ResultsOutput class takes an InstanceProperties object, a TableProperties object, and a configuration map as arguments. It uses these parameters to initialize the object with the necessary properties and configurations required for writing query results to an S3 bucket. This setup is crucial for ensuring that the output is formatted and stored correctly in the specified S3 bucket.\n\nThe publish method of the S3ResultsOutput class is responsible for publishing the results of a given query to an S3 bucket in the Parquet file format. It accepts a Query object and a CloseableIterator of Record objects as parameters. During the publishing process, the method logs the progress to keep track of the operation. Upon completion, it returns a ResultsOutputInfo object that contains details about the output location and the number of records that were successfully written to the S3 bucket. This method is essential for transferring query results to a durable storage solution like Amazon S3, where they can be accessed or analyzed later.",
        "file": "sleeper/java/query/src/main/java/sleeper/query/model/output/S3ResultsOutput.java",
        "class_name": "S3ResultsOutput",
        "repo_metadata": {
            "repo_name": "sleeper"
        },
        "evaluation_metadata": {
            "test_class_name": "S3ResultsOutputTest",
            "test_file": "sleeper/java/query/src/test/java/sleeper/query/model/output/S3ResultsOutputTest.java"
        },
        "task_id": 81,
        "ground_truth_class_body": "/*\n * Copyright 2022-2023 Crown Copyright\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage sleeper.query.model.output;\n\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.parquet.hadoop.ParquetWriter;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport sleeper.configuration.properties.InstanceProperties;\nimport sleeper.configuration.properties.table.TableProperties;\nimport sleeper.configuration.properties.table.TableProperty;\nimport sleeper.core.iterator.CloseableIterator;\nimport sleeper.core.record.Record;\nimport sleeper.core.schema.Schema;\nimport sleeper.io.parquet.record.ParquetRecordWriterFactory;\nimport sleeper.query.model.Query;\n\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.Map;\nimport java.util.UUID;\n\nimport static sleeper.configuration.properties.SystemDefinedInstanceProperty.QUERY_RESULTS_BUCKET;\nimport static sleeper.configuration.properties.UserDefinedInstanceProperty.DEFAULT_RESULTS_PAGE_SIZE;\nimport static sleeper.configuration.properties.UserDefinedInstanceProperty.DEFAULT_RESULTS_ROW_GROUP_SIZE;\nimport static sleeper.configuration.properties.UserDefinedInstanceProperty.FILE_SYSTEM;\nimport static sleeper.configuration.properties.table.TableProperty.DICTIONARY_ENCODING_FOR_ROW_KEY_FIELDS;\nimport static sleeper.configuration.properties.table.TableProperty.DICTIONARY_ENCODING_FOR_SORT_KEY_FIELDS;\nimport static sleeper.configuration.properties.table.TableProperty.DICTIONARY_ENCODING_FOR_VALUE_FIELDS;\n\n/**\n * An implementation of {@link ResultsOutput} that writes results to Parquet files in an S3 bucket.\n */\npublic class S3ResultsOutput implements ResultsOutput {\n    private static final Logger LOGGER = LoggerFactory.getLogger(S3ResultsOutput.class);\n\n    public static final String S3 = \"S3\";\n    public static final String S3_BUCKET = \"bucket\";\n    public static final String COMPRESSION_CODEC = \"compressionCodec\";\n    public static final String ROW_GROUP_SIZE = \"rowGroupSize\";\n    public static final String PAGE_SIZE = \"pageSize\";\n    private final Schema schema;\n    private String s3Bucket;\n    private final String fileSystem;\n    private final long rowGroupSize;\n    private final int pageSize;\n    private final String compressionCodec;\n    private final boolean dictionaryEncodingForRowKeyFields;\n    private final boolean dictionaryEncodingForSortKeyFields;\n    private final boolean dictionaryEncodingForValueFields;\n\n    public S3ResultsOutput(InstanceProperties instanceProperties, TableProperties tableProperties, Map<String, String> config) {\n        this.schema = tableProperties.getSchema();\n        this.s3Bucket = config.get(S3_BUCKET);\n        if (null == this.s3Bucket) {\n            this.s3Bucket = instanceProperties.get(QUERY_RESULTS_BUCKET);\n        }\n        if (null == this.s3Bucket) {\n            throw new IllegalArgumentException(\"Bucket to output results to cannot be found in either the config or the instance properties\");\n        }\n\n        String defaultRowGroupSize = instanceProperties.get(DEFAULT_RESULTS_ROW_GROUP_SIZE);\n        String defaultPageSize = instanceProperties.get(DEFAULT_RESULTS_PAGE_SIZE);\n\n        this.fileSystem = instanceProperties.get(FILE_SYSTEM);\n        this.rowGroupSize = Long.parseLong(config.getOrDefault(ROW_GROUP_SIZE, defaultRowGroupSize));\n        this.pageSize = Integer.parseInt(config.getOrDefault(PAGE_SIZE, defaultPageSize));\n        this.compressionCodec = config.getOrDefault(COMPRESSION_CODEC, tableProperties.get(TableProperty.COMPRESSION_CODEC));\n        this.dictionaryEncodingForRowKeyFields = tableProperties.getBoolean(DICTIONARY_ENCODING_FOR_ROW_KEY_FIELDS);\n        this.dictionaryEncodingForSortKeyFields = tableProperties.getBoolean(DICTIONARY_ENCODING_FOR_SORT_KEY_FIELDS);\n        this.dictionaryEncodingForValueFields = tableProperties.getBoolean(DICTIONARY_ENCODING_FOR_VALUE_FIELDS);\n    }\n\n    @Override\n    public ResultsOutputInfo publish(Query query, CloseableIterator<Record> results) {\n        String outputFile = fileSystem + s3Bucket + \"/query-\" + query.getQueryId() + \"/\" + UUID.randomUUID() + \".parquet\";\n        ResultsOutputLocation outputLocation = new ResultsOutputLocation(\"s3\", outputFile);\n\n        LOGGER.info(\"Opening writer for results of query {} to {}\", query.getQueryId(), outputFile);\n        long count = 0L;\n        try (ParquetWriter<Record> writer = ParquetRecordWriterFactory.createParquetRecordWriter(new Path(outputFile), schema, compressionCodec,\n                rowGroupSize, pageSize, dictionaryEncodingForRowKeyFields, dictionaryEncodingForSortKeyFields, dictionaryEncodingForValueFields, new Configuration())) {\n            long startTime = System.currentTimeMillis();\n            while (results.hasNext()) {\n                writer.write(results.next());\n                count++;\n                if (0 == count % 1_000_000) {\n                    LOGGER.info(\"Wrote {} results\", count);\n                }\n            }\n            long finishTime = System.currentTimeMillis();\n            double durationInSeconds = (finishTime - startTime) / 1000.0;\n            double rate = count / durationInSeconds;\n            LOGGER.info(\"Wrote {} records to {} in {} seconds (rate of {})\",\n                    count, outputFile, durationInSeconds, rate);\n            return new ResultsOutputInfo(count, Collections.singletonList(outputLocation));\n        } catch (RuntimeException | IOException e) {\n            LOGGER.error(\"Exception writing results to S3\", e);\n            return new ResultsOutputInfo(count, Collections.singletonList(outputLocation), e);\n        } finally {\n            try {\n                results.close();\n            } catch (IOException e) {\n                LOGGER.error(\"IOException closing results of query\", e);\n            }\n        }\n    }\n}\n"
    },
    {
        "detailed_description": "The public class ByteNumberHandler is a subclass of the AbstractByteCellHandler class. This class is designed to handle byte numbers in Excel cells. It overrides two methods from its superclass. The first method, setCellValue, is responsible for setting the value of a cell in an Excel row. It takes four parameters: a RowContext object that represents the context of the row in which the cell is located, an ExcelFieldConfig object that contains configuration information for the Excel field, a Cell object that represents the cell itself, and a Byte value that represents the value to be set in the cell. The method converts the Byte value to a double and sets this as the value of the cell. The second method, getExcelType, returns the type of the Excel cell. In this case, it returns ExcelType.NUMERIC, indicating that the cell contains a numeric value.\"",
        "sketchy_description": "The public class ByteNumberHandler, which extends the AbstractByteCellHandler, is specifically designed to manage byte values within cells of an Excel spreadsheet. This class provides a method to set the value of a cell to the double equivalent of a Byte object. The method takes a RowContext, an ExcelFieldConfig, a Cell, and a Byte value as parameters, and it is responsible for converting the Byte value to a double and setting it as the cell's value in the Excel sheet. This is particularly useful when dealing with numeric data that needs to be represented as bytes within the spreadsheet.\n\nAdditionally, the class offers a public method called getExcelType, which returns an ExcelType enum. This enum indicates the type of data the handler is dealing with, and in this case, it specifies that the handler is concerned with numeric values. This method is essential for ensuring that the data is handled correctly according to its type within the Excel environment, and it helps maintain consistency and accuracy when processing numeric data in byte form.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/bytes/ByteNumberHandler.java",
        "class_name": "ByteNumberHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "ByteNumberHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/ByteNumberHandlerTest.java"
        },
        "task_id": 82,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.bytes;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport org.apache.poi.ss.usermodel.Cell;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class ByteNumberHandler extends AbstractByteCellHandler {\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, Byte value) {\n        cell.setCellValue(value.doubleValue());\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.NUMERIC;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class OnlySelfDataPermissionChecker is a subclass of the AbstractDataPermissionChecker class. This class is designed to check if a user has permission to access certain data. It contains a private member, deptService, of type ISysDeptService. This member is likely used to interact with a department service, possibly to retrieve or manipulate department-related data.\n\nThe class overrides the check method from the AbstractDataPermissionChecker class. This method takes two parameters: a loginUser of type LoginUser and a condition of type DataCondition. The method first checks if either the condition or the loginUser is null, returning false if either is. It then checks if either the userId of the loginUser or the targetUserId of the condition is null, again returning false if either is. \n\nFinally, it retrieves the userId from the loginUser and the targetUserId from the condition, and checks if they are equal using the Objects.equals method. If they are equal, it returns true, indicating that the user has permission to access the data. Otherwise, it returns false. This class is likely used in a system where users can only access their own data.\"",
        "sketchy_description": "The public class OnlySelfDataPermissionChecker, which extends the class AbstractDataPermissionChecker, is designed to enforce a security policy where access to data is restricted based on whether the user is attempting to access their own data. This class is particularly useful in multi-user environments where data privacy is a concern, ensuring that users can only view or modify their personal information or data entries.\n\nThe class contains a private variable, deptService, which is likely used to interface with departmental services or to retrieve information about the organizational structure, which can be critical in determining data ownership or user roles within the application.\n\nThe key method in this class is check, which takes a LoginUser object representing the currently logged-in user and a DataCondition object that encapsulates the criteria for accessing the data. The method's purpose is to evaluate whether the logged-in user meets the condition of accessing only their own data. It returns a boolean value, with true indicating that the user is indeed trying to access their own data and is therefore permitted to proceed, and false indicating that the user does not have the necessary permission and should be denied access to the data in question. This method is essential for maintaining data integrity and privacy within the system.",
        "file": "AgileBoot-Back-End/agileboot-infrastructure/src/main/java/com/agileboot/infrastructure/web/domain/permission/checker/OnlySelfDataPermissionChecker.java",
        "class_name": "OnlySelfDataPermissionChecker",
        "repo_metadata": {
            "repo_name": "AgileBoot-Back-End"
        },
        "evaluation_metadata": {
            "test_class_name": "OnlySelfDataPermissionCheckerTest",
            "test_file": "AgileBoot-Back-End/agileboot-infrastructure/src/test/java/com/agileboot/infrastructure/web/domain/permission/checker/OnlySelfDataPermissionCheckerTest.java"
        },
        "task_id": 83,
        "ground_truth_class_body": "package com.agileboot.infrastructure.web.domain.permission.checker;\n\nimport com.agileboot.infrastructure.web.domain.login.LoginUser;\nimport com.agileboot.infrastructure.web.domain.permission.AbstractDataPermissionChecker;\nimport com.agileboot.infrastructure.web.domain.permission.DataCondition;\nimport com.agileboot.orm.system.service.ISysDeptService;\nimport java.util.Objects;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n/**\n * \u6570\u636e\u6743\u9650\u6d4b\u8bd5\u63a5\u53e3\n * @author valarchie\n */\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class OnlySelfDataPermissionChecker extends AbstractDataPermissionChecker {\n\n    private ISysDeptService deptService;\n\n    @Override\n    public boolean check(LoginUser loginUser, DataCondition condition) {\n        if (condition == null || loginUser == null) {\n            return false;\n        }\n\n        if (loginUser.getUserId() == null || condition.getTargetUserId() == null) {\n            return false;\n        }\n\n        Long currentUserId = loginUser.getUserId();\n        Long targetUserId = condition.getTargetUserId();\n        return Objects.equals(currentUserId, targetUserId);\n    }\n\n}\n"
    },
    {
        "detailed_description": "The public class CourseService is designed to manage the operations related to courses in an educational system. It uses a CourseRepository and a CourseMapper, which are injected through the constructor. The CourseRepository is used to interact with the database, while the CourseMapper is used to convert between the database model and the data transfer object (DTO).\n\nThe findAll method retrieves a page of courses from the database. It takes two parameters: the page number and the page size. It uses the CourseRepository to fetch the data, maps it to the DTO using the CourseMapper, and returns a CoursePageDTO object that contains the list of courses, the total number of courses, and the total number of pages.\n\nThe findByName method retrieves a list of courses with a specific name. It uses the CourseRepository to fetch the data, maps it to the DTO using the CourseMapper, and returns the list of courses.\n\nThe findById method retrieves a course with a specific id. It uses the CourseRepository to fetch the data, maps it to the DTO using the CourseMapper, and returns the course. If the course is not found, it throws a RecordNotFoundException.\n\nThe create method creates a new course. It first checks if a course with the same name already exists and is active. If it does, it throws a BusinessException. Otherwise, it creates a new course, sets its status to ACTIVE, saves it using the CourseRepository, maps it to the DTO using the CourseMapper, and returns the course.\n\nThe update method updates an existing course. It first fetches the course using the CourseRepository. If the course is not found, it throws a RecordNotFoundException. Otherwise, it updates the course's name and category, saves it using the CourseRepository, maps it to the DTO using the CourseMapper, and returns the course.\n\nThe delete method deletes a course with a specific id. It first fetches the course using the CourseRepository. If the course is not found, it throws a RecordNotFoundException. Otherwise, it deletes the course using the CourseRepository.\"",
        "sketchy_description": "The public class CourseService is designed to provide a range of services related to managing courses, including creating, reading, updating, and deleting (CRUD) operations, as well as supporting pagination for listing courses. The class is initialized with instances of CourseRepository and CourseMapper, which are essential for interacting with the data layer and mapping between data transfer objects (DTOs) and entity models.\n\nThe findAll method is responsible for retrieving all courses with support for pagination, taking in parameters for the page number and page size, and returning a CoursePageDTO that contains the course data along with metadata such as the total number of elements and total pages available.\n\nThe findByName method allows for searching courses based on their name. It accepts a string representing the course name and returns a list of CourseDTOs that match the provided name, facilitating the process of locating specific courses within the system.\n\nThe findById method is used to find a specific course by its unique identifier, the ID. It returns a CourseDTO representing the course if found, or it throws a RecordNotFoundException if the course with the given ID does not exist.\n\nThe create method enables the creation of a new course using the information provided in a CourseRequestDTO. It returns the newly created CourseDTO if successful, or it throws a BusinessException if a course with the same properties already exists, ensuring the uniqueness of courses.\n\nThe update method allows for modifying an existing course identified by its ID using the new data provided in a CourseRequestDTO. It returns the updated CourseDTO upon successful update, or it throws a RecordNotFoundException if the course with the specified ID cannot be found.\n\nLastly, the delete method is used to remove a course from the system by its ID. It performs the deletion operation and throws a RecordNotFoundException if the course with the given ID is not present in the system, ensuring that only existing courses can be deleted.",
        "file": "crud-angular-spring/crud-spring/src/main/java/com/loiane/service/CourseService.java",
        "class_name": "CourseService",
        "repo_metadata": {
            "repo_name": "crud-angular-spring"
        },
        "evaluation_metadata": {
            "test_class_name": "CourseServiceTest",
            "test_file": "crud-angular-spring/crud-spring/src/test/java/com/loiane/service/CourseServiceTest.java"
        },
        "task_id": 84,
        "ground_truth_class_body": "package com.loiane.service;\n\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nimport org.springframework.data.domain.Page;\nimport org.springframework.data.domain.PageRequest;\nimport org.springframework.stereotype.Service;\nimport org.springframework.validation.annotation.Validated;\n\nimport com.loiane.dto.CourseDTO;\nimport com.loiane.dto.CoursePageDTO;\nimport com.loiane.dto.CourseRequestDTO;\nimport com.loiane.dto.mapper.CourseMapper;\nimport com.loiane.enums.Status;\nimport com.loiane.exception.BusinessException;\nimport com.loiane.exception.RecordNotFoundException;\nimport com.loiane.model.Course;\nimport com.loiane.repository.CourseRepository;\n\nimport jakarta.validation.Valid;\nimport jakarta.validation.constraints.Max;\nimport jakarta.validation.constraints.NotBlank;\nimport jakarta.validation.constraints.NotNull;\nimport jakarta.validation.constraints.Positive;\nimport jakarta.validation.constraints.PositiveOrZero;\n\n@Service\n@Validated\npublic class CourseService {\n\n    private final CourseRepository courseRepository;\n    private final CourseMapper courseMapper;\n\n    public CourseService(CourseRepository courseRepository, CourseMapper courseMapper) {\n        this.courseRepository = courseRepository;\n        this.courseMapper = courseMapper;\n    }\n\n    public CoursePageDTO findAll(@PositiveOrZero int page, @Positive @Max(1000) int pageSize) {\n        Page<Course> coursePage = courseRepository.findAll(PageRequest.of(page, pageSize));\n        List<CourseDTO> list = coursePage.getContent().stream()\n                .map(courseMapper::toDTO)\n                .collect(Collectors.toList());\n        return new CoursePageDTO(list, coursePage.getTotalElements(), coursePage.getTotalPages());\n    }\n\n    public List<CourseDTO> findByName(@NotNull @NotBlank String name) {\n        return courseRepository.findByName(name).stream().map(courseMapper::toDTO).collect(Collectors.toList());\n    }\n\n    public CourseDTO findById(@Positive @NotNull Long id) {\n        return courseRepository.findById(id).map(courseMapper::toDTO)\n                .orElseThrow(() -> new RecordNotFoundException(id));\n    }\n\n    public CourseDTO create(@Valid CourseRequestDTO courseRequestDTO) {\n        courseRepository.findByName(courseRequestDTO.name()).stream()\n                .filter(c -> c.getStatus().equals(Status.ACTIVE))\n                .findAny().ifPresent(c -> {\n                    throw new BusinessException(\"A course with name \" + courseRequestDTO.name() + \" already exists.\");\n                });\n        Course course = courseMapper.toModel(courseRequestDTO);\n        course.setStatus(Status.ACTIVE);\n        return courseMapper.toDTO(courseRepository.save(course));\n    }\n\n    public CourseDTO update(@Positive @NotNull Long id, @Valid CourseRequestDTO courseRequestDTO) {\n        return courseRepository.findById(id).map(actual -> {\n            actual.setName(courseRequestDTO.name());\n            actual.setCategory(courseMapper.convertCategoryValue(courseRequestDTO.category()));\n            return courseMapper.toDTO(courseRepository.save(actual));\n        })\n                .orElseThrow(() -> new RecordNotFoundException(id));\n    }\n\n    public void delete(@Positive @NotNull Long id) {\n        courseRepository.delete(courseRepository.findById(id)\n                .orElseThrow(() -> new RecordNotFoundException(id)));\n    }\n}\n"
    },
    {
        "detailed_description": "The public class SparkSpecHelper is a utility class that provides a method for copying environment variables from one list to another. The class contains a single public static method named copyEnv. This method takes two arguments, both of which are lists of EnvVar objects. The first list is the source of the environment variables to be copied, and the second list is the destination where the environment variables will be copied to.\n\nThe method first creates a HashMap called destinationEnvIndex, which maps the name of each environment variable in the destination list to its index in the list. This is done to quickly find the index of a specific environment variable in the destination list.\n\nThen, the method iterates over each environment variable in the source list. For each environment variable, it checks if an environment variable with the same name already exists in the destination list by looking up the name in the destinationEnvIndex map. If the environment variable does not exist in the destination list, it is added to the list. If it does exist, the existing environment variable in the destination list is replaced with the one from the source list.\n\nThis method is useful for managing environment variables in a Spark application, where it may be necessary to overwrite certain environment variables with new values.\"",
        "sketchy_description": "The public class SparkSpecHelper is a utility class that is specifically designed to assist with the management of configurations and environment variables that are related to Apache Spark. This class does not represent a data model but rather provides static methods that can be used to manipulate and handle environment settings that are crucial for the proper functioning of Spark applications.\n\nOne of the key methods provided by this class is the static method copyEnv, which is designed to transfer environment variables from one list to another. This method takes two arguments, both of which are lists of EnvVar objects. The source list contains the environment variables that need to be copied, while the destination list is where these variables will be transferred to. The method iterates through the source list and copies each environment variable to the destination list. If an environment variable with the same name already exists in the destination list, it is overwritten with the value from the source list. This method is particularly useful when setting up a Spark environment, as it allows for the easy and efficient transfer of necessary environment variables, ensuring that the Spark application has access to the correct configurations.",
        "file": "batch-processing-gateway/src/main/java/com/apple/spark/core/SparkSpecHelper.java",
        "class_name": "SparkSpecHelper",
        "repo_metadata": {
            "repo_name": "batch-processing-gateway"
        },
        "evaluation_metadata": {
            "test_class_name": "SparkSpecHelperTest",
            "test_file": "batch-processing-gateway/src/test/java/com/apple/spark/core/SparkSpecHelperTest.java"
        },
        "task_id": 85,
        "ground_truth_class_body": "/*\n *\n * This source file is part of the Batch Processing Gateway open source project\n *\n * Copyright 2022 Apple Inc. and the Batch Processing Gateway project authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.apple.spark.core;\n\nimport com.apple.spark.operator.EnvVar;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class SparkSpecHelper {\n\n  // Copy environment variables from source to destination, with proper overwriting\n  public static void copyEnv(List<EnvVar> source, List<EnvVar> destination) {\n    Map<String, Integer> destinationEnvIndex = new HashMap<>();\n    for (int i = 0; i < destination.size(); i++) {\n      destinationEnvIndex.put(destination.get(i).getName(), i);\n    }\n    for (EnvVar sourceEnvEntry : source) {\n      Integer indexInDestinationEnv = destinationEnvIndex.get(sourceEnvEntry.getName());\n      if (indexInDestinationEnv == null) {\n        destination.add(sourceEnvEntry);\n      } else {\n        destination.set(indexInDestinationEnv, sourceEnvEntry);\n      }\n    }\n  }\n}\n"
    },
    {
        "detailed_description": "The public class FilePdfSource is a subclass of the AbstractPdfBoxSource class, with File as its generic type. This class is designed to handle PDF files as its source of data. The constructor for this class takes a File object as an argument, which represents the source PDF file, and passes it to the superclass constructor. The class overrides the doLoad method from the superclass, which is designed to load the source data into a PDDocument object. This method throws an IOException if there is a problem with reading the file. The PDDocument object returned by the doLoad method can then be used for further processing of the PDF file, such as extracting text, images, or metadata.\"",
        "sketchy_description": "The public class FilePdfSource, which extends the AbstractPdfBoxSource class with a generic type of File, is designed to represent a PDF source that is obtained from a file. This is particularly useful when dealing with PDF processing or manipulation in applications that require reading from or writing to PDF documents stored on a file system.\n\nThe constructor of the FilePdfSource class takes a single argument of type File, which represents the file that contains the PDF document to be processed. The purpose of the constructor is to initialize the FilePdfSource object with the provided File object, setting it as the source from which the PDF will be loaded.\n\nOnce the FilePdfSource object has been instantiated, it provides a protected method named doLoad, which is responsible for loading the PDF document from the file source. This method throws an IOException to handle any input/output errors that may occur during the reading process. Upon successful execution, doLoad returns a PDDocument object, which is a representation of the PDF document as defined by the PDFBox library. This PDDocument object can then be used for further operations, such as reading content from the PDF, adding annotations, or extracting text.",
        "file": "imglib/pipe/src/main/java/cn/pipe/in/pdf/FilePdfSource.java",
        "class_name": "FilePdfSource",
        "repo_metadata": {
            "repo_name": "imglib"
        },
        "evaluation_metadata": {
            "test_class_name": "FilePdfSourceTest",
            "test_file": "imglib/pipe/src/test/java/cn/pipe/in/pdf/FilePdfSourceTest.java"
        },
        "task_id": 86,
        "ground_truth_class_body": "package cn.pipe.in.pdf;\n\nimport cn.pipe.in.AbstractPdfBoxSource;\nimport org.apache.pdfbox.pdmodel.PDDocument;\nimport java.io.File;\nimport java.io.IOException;\n\n/**\n * A pdf source that from file.\n *\n * @author tracy\n * @since 0.2.1\n */\npublic class FilePdfSource extends AbstractPdfBoxSource<File> {\n\n    public FilePdfSource(File source) {\n        super(source);\n    }\n\n    @Override\n    protected PDDocument doLoad() throws IOException {\n        return PDDocument.load(source);\n    }\n}\n"
    },
    {
        "detailed_description": "The public class ThisBufferedImageSource implements the BufferedImageSource interface, which is designed to handle BufferedImage objects. This class has two member variables: a final BufferedImage object named 'image' and a protected boolean variable named 'readCompleted'. The constructor for this class takes a BufferedImage object as an argument and checks if it is null. If it is null, it throws a NullPointerException. Otherwise, it assigns the passed BufferedImage object to the 'image' member variable. \n\nThe class overrides four methods from the BufferedImageSource interface. The 'read' method sets the 'readCompleted' variable to true and returns the 'image' object. The 'getOriginalFormatName' method returns null, indicating that this implementation does not support retrieving the original format name of the image. The 'getSource' method returns the 'image' object, allowing access to the original BufferedImage object. The 'isReadCompleted' method returns the value of the 'readCompleted' variable, indicating whether the image has been read or not.\"",
        "sketchy_description": "The public class ThisBufferedImageSource implements the BufferedImageSource interface, specifically for BufferedImage objects. It serves as a wrapper that facilitates the use of a BufferedImage in various image processing contexts. The class contains a private final variable 'image' which holds the BufferedImage, and a protected boolean variable 'readCompleted' that indicates whether the image has been read.\n\nThe constructor of ThisBufferedImageSource takes a BufferedImage as an argument and initializes the object with it. It ensures that the provided BufferedImage is not null, throwing a NullPointerException if it is.\n\nThe class overrides several methods from the BufferedImageSource interface:\n\n- The read method is responsible for reading the BufferedImage and setting the 'readCompleted' flag to true once the operation is complete. It returns the BufferedImage object. This method may throw an IOException if an I/O error occurs during reading.\n\n- The getOriginalFormatName method is intended to return the original format name of the image. However, in its current implementation, it simply returns null.\n\n- The getSource method provides access to the source BufferedImage that was provided during the construction of the object.\n\n- The isReadCompleted method allows checking whether the read operation has been completed by returning the value of the 'readCompleted' flag. It returns true if the read operation is complete, and false otherwise.\n\nThese methods enable the ThisBufferedImageSource class to be used effectively in image processing tasks, providing both the image data and the state of the read operation.",
        "file": "imglib/core/src/main/java/cn/core/in/ThisBufferedImageSource.java",
        "class_name": "ThisBufferedImageSource",
        "repo_metadata": {
            "repo_name": "imglib"
        },
        "evaluation_metadata": {
            "test_class_name": "ThisBufferedImageSourceTest",
            "test_file": "imglib/core/src/test/java/cn/core/in/ThisBufferedImageSourceTest.java"
        },
        "task_id": 87,
        "ground_truth_class_body": "package cn.core.in;\n\nimport cn.core.utils.ObjectUtils;\n\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\n\n/**\n * Buffered image data source whose from BufferedImage object.\n *\n * @author tracy\n * @since 0.2.1\n */\npublic class ThisBufferedImageSource implements BufferedImageSource<BufferedImage> {\n\n    private final BufferedImage image;\n    protected boolean readCompleted = false;\n\n    public ThisBufferedImageSource(BufferedImage source) {\n        if (ObjectUtils.isNull(source)) {\n            throw new NullPointerException(\"BufferedImage is null.\");\n        }\n        this.image = source;\n    }\n\n    @Override\n    public BufferedImage read() throws IOException {\n        readCompleted = true;\n        return image;\n    }\n\n    @Override\n    public String getOriginalFormatName() {\n        return null;\n    }\n\n    @Override\n    public BufferedImage getSource() {\n        return image;\n    }\n\n    @Override\n    public boolean isReadCompleted() {\n        return readCompleted;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class MinGrayingStrategy is a subclass of the AbstractGrayingStrategy class. This class is designed to implement a specific strategy for calculating the grayness value of a color, based on the minimum value among the red, green, and blue color components. The class overrides the getGraynessValue method from the AbstractGrayingStrategy class. This method takes three integer arguments, representing the red, green, and blue color components respectively. The method returns the minimum value among these three arguments, which represents the grayness value of the color. This strategy can be used in image processing applications where it is necessary to convert a color image to grayscale.\"",
        "sketchy_description": "The public class MinGrayingStrategy, which extends the AbstractGrayingStrategy class, is designed to implement a specific strategy for converting a color image to grayscale. This strategy involves analyzing the RGB (red, green, and blue) components of a color and determining the grayness of that color by taking the minimum value among these three components. The method getGraynessValue is provided to perform this calculation. It accepts three integer arguments corresponding to the red, green, and blue color values and returns an integer that represents the calculated grayness value. This method is essential for applying the minimum value graying strategy to an image, ensuring that the resulting grayscale image reflects the minimum intensity of the original color components.",
        "file": "imglib/ext-t8s/src/main/java/cn/t8s/mode/graying/MinGrayingStrategy.java",
        "class_name": "MinGrayingStrategy",
        "repo_metadata": {
            "repo_name": "imglib"
        },
        "evaluation_metadata": {
            "test_class_name": "MinGrayingStrategyTest",
            "test_file": "imglib/ext-t8s/src/test/java/cn/t8s/mode/graying/MinGrayingStrategyTest.java"
        },
        "task_id": 88,
        "ground_truth_class_body": "package cn.t8s.mode.graying;\n\nimport cn.core.strategy.mode.AbstractGrayingStrategy;\n\n/**\n * A maximum graying strategy. The gray value of any pixel is equal to the maximum value of\n * the red component, green component and blue component.\n *\n * @author tracy\n * @since 0.2.1\n */\npublic class MinGrayingStrategy extends AbstractGrayingStrategy {\n    @Override\n    public int getGraynessValue(int r, int g, int b) {\n        return Math.min(Math.min(r, g), b);\n    }\n}\n"
    },
    {
        "detailed_description": "The public class DefaultRowContext is an implementation of the RowContext interface. This class is designed to provide a context for a row in a sheet, which is useful for operations such as reading and writing data to a sheet. The class has four private members: sheetContext, rowData, rowList, and rowspan. \n\nThe sheetContext member is of type SheetContext and represents the context of the sheet that the row belongs to. The rowData member is of type Object and holds the data of the row. The rowList member is a list of Row objects, representing a list of rows. The rowspan member is an integer that represents the number of rows that a cell should span.\n\nThe constructor for this class takes four arguments: a SheetContext object, an Object representing the row data, a List of Row objects, and an integer for the rowspan. These arguments are used to initialize the respective members of the class.\n\nThe class provides four public methods that override the methods in the RowContext interface. The getSheetContext method returns the SheetContext object, the getRowData method returns the row data, the getRowList method returns the list of Row objects, and the getRowspan method returns the rowspan. These methods allow the user to access the data and properties of the row in the sheet.\"",
        "sketchy_description": "The public class DefaultRowContext, which implements the RowContext interface, is designed to provide the necessary context for a row within a sheet. This context includes various pieces of information that are essential for understanding and manipulating the row within its sheet environment.\n\nThe constructor of the DefaultRowContext class takes four parameters: a SheetContext object, an Object representing the row data, a List of Row objects, and an integer representing the rowspan. The purpose of the constructor is to initialize the DefaultRowContext with these pieces of information, ensuring that all relevant data is available for the row's context.\n\nOnce an instance of DefaultRowContext is created, four public methods are available to access the context's components:\n\n- The getSheetContext method returns the SheetContext object associated with the row, which provides additional information and functionality related to the sheet that the row belongs to.\n- The getRowData method returns the data object associated with the row, which could contain any relevant information or values pertaining to that specific row.\n- The getRowList method returns a list of Row objects, which represents all the rows that are associated with the current context. This can be useful for operations that need to consider multiple rows at once.\n- The getRowspan method returns the integer value of the rowspan, which indicates how many rows the current row's data should span across. This is particularly important for rendering or processing the layout of rows within the sheet.\n\nThese methods collectively provide a comprehensive interface for interacting with and retrieving information about the row's context within a sheet.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/context/defualts/DefaultRowContext.java",
        "class_name": "DefaultRowContext",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "DefaultRowContextTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/context/defualts/DefaultRowContextTest.java"
        },
        "task_id": 89,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.context.defualts;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.context.SheetContext;\nimport org.apache.poi.ss.usermodel.Row;\n\nimport java.util.List;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class DefaultRowContext implements RowContext {\n\n    private final SheetContext sheetContext;\n\n    private final Object rowData;\n\n    private final List<Row> rowList;\n\n    private final int rowspan;\n\n\n    public DefaultRowContext(SheetContext sheetContext, Object rowData, List<Row> rowList, int rowspan) {\n        this.sheetContext = sheetContext;\n        this.rowData = rowData;\n        this.rowList = rowList;\n        this.rowspan = rowspan;\n    }\n\n    @Override\n    public SheetContext getSheetContext() {\n        return sheetContext;\n    }\n\n    @Override\n    public Object getRowData() {\n        return rowData;\n    }\n\n    @Override\n    public List<Row> getRowList() {\n        return rowList;\n    }\n\n    @Override\n    public int getRowspan() {\n        return rowspan;\n    }\n\n\n}\n"
    },
    {
        "detailed_description": "The public class LocalDateTimeNumberHandler is a subclass of the AbstractLocalDateTimeCellHandler class. This class is designed to handle the conversion of LocalDateTime values to a numeric format that can be used in an Excel spreadsheet. The class overrides two methods from its superclass. \n\nThe first overridden method is setCellValue. This method takes four parameters: a RowContext object, an ExcelFieldConfig object, a Cell object, and a LocalDateTime value. The method converts the LocalDateTime value to a double representation using the DateUtil.getExcelDate method, and then sets this value as the cell value in the Excel spreadsheet. \n\nThe second overridden method is getExcelType. This method does not take any parameters and returns an ExcelType enumeration value. Specifically, it returns ExcelType.NUMERIC, indicating that the Excel cell type for the values handled by this class is numeric. This class is useful for writing LocalDateTime values to an Excel spreadsheet in a format that Excel can understand and display correctly.\"",
        "sketchy_description": "The public class LocalDateTimeNumberHandler, which extends the AbstractLocalDateTimeCellHandler, is specifically designed to handle the conversion of LocalDateTime objects into a numeric format that is compatible with Excel for the purpose of setting cell values. This functionality is crucial when working with Excel documents in Java, as it ensures that date and time representations are correctly interpreted by Excel.\n\nThe class provides a protected method setCellValue, which takes a RowContext, an ExcelFieldConfig, a Cell, and a LocalDateTime value as parameters. This method is responsible for converting the LocalDateTime value into Excel's numeric date format and then setting this value as the content of the specified cell. This is an essential operation when one needs to accurately reflect date and time values within an Excel spreadsheet.\n\nAdditionally, the class offers a public method getExcelType, which returns an ExcelType enumeration value. This value indicates that the type of data being handled by this class is numeric, which aligns with the numeric representation of dates in Excel. This method is useful for clients of the class to understand the type of data conversion that is being performed.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/localdatetime/LocalDateTimeNumberHandler.java",
        "class_name": "LocalDateTimeNumberHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "LocalDateTimeNumberHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/LocalDateTimeNumberHandlerTest.java"
        },
        "task_id": 90,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.localdatetime;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport org.apache.poi.ss.usermodel.Cell;\nimport org.apache.poi.ss.usermodel.DateUtil;\n\nimport java.time.LocalDateTime;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class LocalDateTimeNumberHandler extends AbstractLocalDateTimeCellHandler {\n\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, LocalDateTime value) {\n        double excelLocalDate = DateUtil.getExcelDate(value);\n        cell.setCellValue(excelLocalDate);\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.NUMERIC;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class BooleanStringHandler is a subclass of the AbstractBooleanCellHandler class. This class is designed to handle boolean values in the context of Excel cells. It overrides two methods from its superclass. The first method, setCellValue, is responsible for setting the value of a cell in an Excel row. It takes four parameters: a RowContext object, an ExcelFieldConfig object, a Cell object, and a Boolean value. The method converts the Boolean value to a String and sets this as the value of the cell. The second method, getExcelType, returns the ExcelType of the cell, which in this case is always STRING. This class is useful for handling boolean values in Excel spreadsheets, particularly when these values need to be stored as strings rather than boolean values.\"",
        "sketchy_description": "The public class BooleanStringHandler, which extends the AbstractBooleanCellHandler, is specifically designed to manage the conversion of Boolean values into their String representations within Excel cells. This functionality is particularly useful when dealing with Excel spreadsheets that require a textual representation of Boolean values, such as \"TRUE\" or \"FALSE\", instead of using Excel's native Boolean formatting.\n\nThe class provides a protected method setCellValue, which takes a RowContext, an ExcelFieldConfig, a Cell, and a Boolean value as parameters. This method is responsible for setting the cell's value to the appropriate String representation of the Boolean value passed to it. This conversion ensures that the Boolean value is displayed correctly when the Excel file is viewed or edited.\n\nAdditionally, the class includes a public method getExcelType, which returns the ExcelType.STRING. This indicates that the handler is designed to work with String values within Excel cells. By returning this specific ExcelType, the handler informs any calling code that the data it processes will be in String format, which is essential for maintaining consistency and predictability in the handling of Excel cell values.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/booleans/BooleanStringHandler.java",
        "class_name": "BooleanStringHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "BooleanStringHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/BooleanStringHandlerTest.java"
        },
        "task_id": 91,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.booleans;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport org.apache.poi.ss.usermodel.Cell;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class BooleanStringHandler extends AbstractBooleanCellHandler {\n\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, Boolean value) {\n        cell.setCellValue(Boolean.toString(value));\n    }\n\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.STRING;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class DateDateHandler is a subclass of the AbstractDateCellHandler class. This class is designed to handle date cells in an Excel spreadsheet. It overrides three methods from its superclass. \n\nThe first overridden method, setCellValue, is responsible for setting the value of a cell in a row. It takes four parameters: a RowContext object that represents the context of the row in which the cell is located, an ExcelFieldConfig object that contains configuration information for the Excel field, a Cell object that represents the cell whose value is to be set, and a Date object that represents the value to be set in the cell. The method sets the cell's value to the Date object passed as an argument.\n\nThe second overridden method, getExcelType, returns the type of Excel cell that this handler is designed to handle. In this case, it returns ExcelType.DATE, indicating that this handler is designed to handle date cells.\n\nThe third overridden method, getDefaultExcelFormat, returns the default format for date cells that this handler is designed to handle. In this case, it returns \"yyyy-MM-dd HH:mm:ss\", which is a common format for representing dates and times.\"",
        "sketchy_description": "The public class DateDateHandler, which extends the AbstractDateCellHandler, is specifically designed to manage the setting of cell values for dates within an Excel spreadsheet. This class provides specialized functionality to ensure that date values are correctly formatted and inserted into the appropriate cells of an Excel sheet.\n\nThe setCellValue method is a protected method that takes a RowContext, an ExcelFieldConfig, a Cell, and a Date as parameters. Its primary responsibility is to set the value of a given cell to the Date value provided. This method ensures that the date is properly recorded in the cell, adhering to the format and configuration specified for the Excel sheet.\n\nThe getExcelType method is a public method that returns the ExcelType enumeration value that corresponds to the DATE format. This method informs users or other parts of the system that this handler deals with date values in Excel, allowing for appropriate handling and formatting of such values.\n\nLastly, the getDefaultExcelFormat method is a public method that returns a String representing the default Excel format for dates used by this handler. The format returned is \"yyyy-MM-dd HH:mm:ss\", which is a commonly used date and time format that includes the year, month, day, hour, minute, and second components. This default format can be used to ensure consistency across the handling of date values within the Excel sheet.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/date/DateDateHandler.java",
        "class_name": "DateDateHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "DateDateHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/DateDateHandlerTest.java"
        },
        "task_id": 92,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.date;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport org.apache.poi.ss.usermodel.Cell;\n\nimport java.util.Date;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class DateDateHandler extends AbstractDateCellHandler {\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, Date value) {\n        cell.setCellValue(value);\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.DATE;\n    }\n\n    @Override\n    public String getDefaultExcelFormat() {\n        return \"yyyy-MM-dd HH:mm:ss\";\n    }\n}\n"
    },
    {
        "detailed_description": "The public class RowTitleWriteRegistry is designed to manage the registration and retrieval of RowTitleWrite instances. It contains a static final field DEFAULT_ROW_TITLE_WRITE_CLASS which holds the class type of DefaultRowTitleWrite. \n\nThe class also has a private final field named configuration of type Configuration, which is used to store the configuration information for the registry. \n\nAnother private final field is rowTitleWriteMap, which is a concurrent hash map that stores the registered RowTitleWrite instances, with the class type as the key and the instance as the value. \n\nThe constructor of this class takes a Configuration object as an argument and initializes the configuration field with it. It also registers a new instance of DefaultRowTitleWrite to the rowTitleWriteMap. \n\nThe class exposes a public method getConfiguration that returns the configuration object. \n\nAnother public method, register, is used to register a new RowTitleWrite instance to the rowTitleWriteMap. \n\nThe getMappingRowWrite method is used to retrieve a registered RowTitleWrite instance from the rowTitleWriteMap using the class type as the key. If the requested class type is not found in the map, it throws an ExcelException with a message indicating that the requested RowTitleWrite does not exist.\"",
        "sketchy_description": "The public class RowTitleWriteRegistry is designed to manage the registration of various RowTitleWrite instances, which are likely used for writing row titles in an Excel-like context. The class contains a static class variable `DEFAULT_ROW_TITLE_WRITE_CLASS` which holds a reference to the `DefaultRowTitleWrite` class, indicating the default implementation of the RowTitleWrite that should be used if no other is specified.\n\nThe constructor of the class takes a `Configuration` object as an argument and uses it to initialize the registry. It also registers the default RowTitleWrite instance based on the `DEFAULT_ROW_TITLE_WRITE_CLASS`. This setup process is crucial for preparing the registry to handle requests for RowTitleWrite instances.\n\nThe `getConfiguration` method provides access to the `Configuration` object associated with the registry, allowing other parts of the system to retrieve configuration details as needed.\n\nThe `register` method is used to add a new RowTitleWrite instance to the registry. This allows for the dynamic addition of new row title writing strategies without modifying the existing codebase.\n\nFinally, the `getMappingRowWrite` method is designed to retrieve a registered RowTitleWrite instance based on its class. If the requested instance is not found in the registry, an `ExcelException` is thrown, indicating that the operation cannot be completed due to the absence of the required RowTitleWrite instance. This method is essential for obtaining the correct RowTitleWrite instance for a given task, ensuring that row titles are written correctly according to the specified class.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/write/registry/RowTitleWriteRegistry.java",
        "class_name": "RowTitleWriteRegistry",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "RowTitleWriteRegistryTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/write/registry/RowTitleWriteRegistryTest.java"
        },
        "task_id": 93,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.write.registry;\n\nimport io.github.zouzhiy.excel.exceptions.ExcelException;\nimport io.github.zouzhiy.excel.metadata.Configuration;\nimport io.github.zouzhiy.excel.write.RowTitleWrite;\nimport io.github.zouzhiy.excel.write.defaults.DefaultRowTitleWrite;\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * RowTitleWrite \u6ce8\u518c\u7ba1\u7406\n *\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class RowTitleWriteRegistry {\n\n    public final static Class<DefaultRowTitleWrite> DEFAULT_ROW_TITLE_WRITE_CLASS = DefaultRowTitleWrite.class;\n\n    private final Configuration configuration;\n\n    private final Map<Class<? extends RowTitleWrite>, RowTitleWrite> rowTitleWriteMap = new ConcurrentHashMap<>(16);\n\n    public RowTitleWriteRegistry(Configuration configuration) {\n        this.configuration = configuration;\n        register(new DefaultRowTitleWrite());\n    }\n\n    /**\n     * \u5168\u5bb6\u914d\u7f6e\u4fe1\u606f\n     *\n     * @return Configuration\n     */\n    public Configuration getConfiguration() {\n        return configuration;\n    }\n\n    /**\n     * \u6ce8\u518c\n     *\n     * @param rowTitleWrite \u5b9e\u4f8b\n     */\n    public void register(RowTitleWrite rowTitleWrite) {\n        rowTitleWriteMap.put(rowTitleWrite.getClass(), rowTitleWrite);\n    }\n\n    /**\n     * \u6839\u636e class \u67e5\u627e\u5df2\u6ce8\u518c\u7684\u5b9e\u4f8b\u5bf9\u8c61\n     *\n     * @param rowTitleWriteClazz class\n     * @return \u8fd4\u56de\u5df2\u6ce8\u518c\u7684\u5b9e\u4f8b\u5bf9\u8c61\n     */\n    public RowTitleWrite getMappingRowWrite(Class<? extends RowTitleWrite> rowTitleWriteClazz) {\n        RowTitleWrite rowTitleWrite = rowTitleWriteMap.get(rowTitleWriteClazz);\n        if (rowTitleWrite == null) {\n            throw new ExcelException(\"\u4e0d\u5b58\u5728\u7684\uff1aRowTitleWrite\");\n        }\n        return rowTitleWrite;\n    }\n}\n"
    },
    {
        "detailed_description": "The public abstract class AbstractGifSource is a generic class that implements the GifSource interface. It is designed to handle the source of a GIF file. The type of the GIF source is represented by the generic parameter T. \n\nThe class has three protected fields. The 'source' field of type T represents the source of the GIF. The 'readCompleted' boolean field indicates whether the reading of the GIF source is completed. The 'decoder' field is an instance of the GifDecoder class, which is used to decode the GIF source.\n\nThe class has a constructor that takes a parameter of type T to initialize the 'source' field.\n\nThe class implements several methods from the GifSource interface. The 'size' method returns the number of frames in the GIF. The 'read' methods return one or more frames from the GIF as BufferedImage objects. The 'getSource' method returns the GIF source. The 'isReadCompleted' method indicates whether the reading of the GIF source is completed.\n\nThe class also has a protected method 'loadIfNot' that loads the GIF source if it has not been loaded. It throws an IOException if there are I/O exceptions when loading the GIF source, and a HandlingException if there are runtime exceptions when loading the GIF source.\n\nThe class has an abstract method 'doLoad' that is responsible for loading the GIF source. It returns the read status and throws an IOException if there are I/O exceptions when loading the GIF source. The implementation of this method is left to the subclasses of AbstractGifSource.\"",
        "sketchy_description": "The `AbstractGifSource` class is an abstract class that serves as a blueprint for creating a GIF source reader. It implements the `GifSource` interface and is parameterized with a type `<T>`, which represents the type of the GIF source. The class was authored by Tracy and has been available since version 0.2.1.\n\nThe class contains a protected final variable `source` of type `T`, which is the source from which GIFs are read. It also has a protected boolean `readCompleted` that serves as a flag to indicate whether the reading process is complete, and a protected final `GifDecoder` called `decoder` that is used for reading frames from the GIF source.\n\nThe constructor of the class is protected and takes a single parameter of type `T`. It is responsible for initializing the GIF source with the provided source object.\n\nThe class exposes several methods:\n\n- `size()`: This public method throws an `IOException` and returns the number of frames in the GIF source after it has been loaded.\n- `read(int frameIndex)`: This public method also throws an `IOException` and reads and returns the `BufferedImage` of the specified frame index after the GIF source has been loaded.\n- `read(Integer[] frameIndexes)`: This public method throws an `IOException` and reads and returns a list of `BufferedImages` for the specified frame indexes after the GIF source has been loaded.\n- `readAll()`: This public method throws an `IOException` and reads and returns a list of all `BufferedImages` after loading the entire GIF source.\n- `getSource()`: This public method returns the source object associated with this GIF source.\n- `isReadCompleted()`: This public method checks if the reading of the GIF source has been completed.\n- `loadIfNot()`: This protected method throws an `IOException` and loads the GIF source if it has not been loaded yet, setting the `readCompleted` flag accordingly.\n- `doLoad()`: This is a protected abstract method that throws an `IOException` and must be implemented by subclasses to load the GIF source. It returns the read status.\n\nThese methods provide a framework for subclasses to implement the specifics of reading GIFs from various types of sources, ensuring that the reading process is handled consistently and that the necessary data is accessible for further processing or display.",
        "file": "imglib/pipe/src/main/java/cn/pipe/in/AbstractGifSource.java",
        "class_name": "AbstractGifSource",
        "repo_metadata": {
            "repo_name": "imglib"
        },
        "evaluation_metadata": {
            "test_class_name": "AbstractGifSourceTest",
            "test_file": "imglib/pipe/src/test/java/cn/pipe/in/AbstractGifSourceTest.java"
        },
        "task_id": 94,
        "ground_truth_class_body": "package cn.pipe.in;\n\nimport cn.core.ex.HandlingException;\nimport cn.core.in.GifSource;\nimport com.madgag.gif.fmsware.GifDecoder;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * An abstract superclass of gif source.\n *\n * @param <T> The type of gif source.\n * @author tracy\n * @since 0.2.1\n */\npublic abstract class AbstractGifSource<T> implements GifSource<T> {\n\n    /**\n     * The source.\n     */\n    protected final T source;\n\n    /**\n     * The flag that indicating the completion of reading.\n     */\n    protected boolean readCompleted = false;\n\n    /**\n     * The gif decoder.\n     */\n    protected final GifDecoder decoder = new GifDecoder();\n\n\n    protected AbstractGifSource(T source) {\n        this.source = source;\n    }\n\n    @Override\n    public int size() throws IOException {\n        loadIfNot();\n        return decoder.getFrameCount();\n    }\n\n    @Override\n    public BufferedImage read(int frameIndex) throws IOException {\n        loadIfNot();\n        return decoder.getFrame(frameIndex);\n    }\n\n    @Override\n    public List<BufferedImage> read(Integer[] frameIndexes) throws IOException {\n        loadIfNot();\n        List<BufferedImage> res = new ArrayList<>();\n        for (Integer index : frameIndexes) {\n            res.add(decoder.getFrame(index));\n        }\n        return res;\n    }\n\n    @Override\n    public List<BufferedImage> readAll() throws IOException {\n        loadIfNot();\n        List<BufferedImage> res = new ArrayList<>();\n        int size = decoder.getFrameCount();\n        for (int i = 0; i < size; i++) {\n            res.add(decoder.getFrame(i));\n        }\n        return res;\n    }\n\n    @Override\n    public T getSource() {\n        return source;\n    }\n\n    @Override\n    public boolean isReadCompleted() {\n        return readCompleted;\n    }\n\n    /**\n     * Load the gif source if the source have not loaded.\n     * @throws IOException If some I/O exceptions occurred when loading the gif source.\n     * @throws HandlingException If some runtime exceptions occurred when loading the gif source.\n     */\n    protected void loadIfNot() throws IOException {\n        if (readCompleted) {\n            return;\n        }\n        int status = doLoad();\n        switch (status) {\n            case GifDecoder.STATUS_OK:\n                readCompleted = true;\n                return;\n            case GifDecoder.STATUS_FORMAT_ERROR:\n                throw new HandlingException(\"Error decoding file (may be partially decoded).\");\n            case GifDecoder.STATUS_OPEN_ERROR:\n                throw new HandlingException(\"Unable to open source.\");\n            default:\n                throw new HandlingException(\"Unknown error.\");\n        }\n    }\n\n    /**\n     * Load the gif source.\n     * @return The read status.\n     * @throws IOException If some I/O exceptions occurred when loading the gif source.\n     */\n    protected abstract int doLoad() throws IOException;\n}\n"
    },
    {
        "detailed_description": "The public class CalendarDateHandler is a subclass of the AbstractCalendarCellHandler class. This class is designed to handle calendar dates in an Excel spreadsheet. It overrides three methods from its superclass. \n\nThe first overridden method, setCellValue, is responsible for setting the value of a cell in a row. It takes four parameters: a RowContext object, an ExcelFieldConfig object, a Cell object, and a Calendar object. The Calendar object represents the value to be set in the cell. \n\nThe second overridden method, getExcelType, returns the type of Excel data that this handler is designed to work with. In this case, it returns ExcelType.DATE, indicating that this handler is designed to work with date data.\n\nThe third overridden method, getDefaultExcelFormat, returns the default format for date data in Excel. In this case, it returns a string representing the format \"yyyy-MM-dd HH:mm:ss\", which is a common format for representing dates and times.\"",
        "sketchy_description": "The public class CalendarDateHandler, which extends AbstractCalendarCellHandler, is specifically designed to manage the cell values associated with calendar dates within an Excel spreadsheet. This class provides specialized methods to interact with the cells that contain date information, ensuring that dates are handled correctly according to the Excel format.\n\nThe setCellValue method is a protected method that takes a RowContext, an ExcelFieldConfig, a Cell, and a Calendar object as parameters. Its primary function is to set the value of a given cell in the Excel sheet to the date represented by the Calendar object. This method is crucial for maintaining the integrity of date information within the spreadsheet.\n\nThe getExcelType method is a public method that returns the ExcelType enumeration value that corresponds to the handler. In this case, the method returns DATE, indicating that this handler deals with date values within the Excel sheet.\n\nLastly, the getDefaultExcelFormat method is a public method that returns a String representing the default format for dates in Excel. The format returned is \"yyyy-MM-dd HH:mm:ss\", which is a commonly used date and time format that includes the year, month, day, hour, minute, and second components of a date. This format string is essential for users to understand how dates will be displayed or expected to be inputted within the Excel sheet.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/calendar/CalendarDateHandler.java",
        "class_name": "CalendarDateHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "CalendarDateHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/CalendarDateHandlerTest.java"
        },
        "task_id": 95,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.calendar;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport org.apache.poi.ss.usermodel.Cell;\n\nimport java.util.Calendar;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class CalendarDateHandler extends AbstractCalendarCellHandler {\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, Calendar value) {\n        cell.setCellValue(value);\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.DATE;\n    }\n\n    @Override\n    public String getDefaultExcelFormat() {\n        return \"yyyy-MM-dd HH:mm:ss\";\n    }\n}\n"
    },
    {
        "detailed_description": "The public class DoubleStringHandler is a subclass of the AbstractDoubleCellHandler class. This class is designed to handle the conversion of double values to string values in the context of an Excel spreadsheet. The class overrides two methods from its superclass. \n\nThe first overridden method is setCellValue. This method takes four parameters: a RowContext object, an ExcelFieldConfig object, a Cell object, and a Double value. The method first retrieves the Java format for the Excel field configuration using the getJavaFormat method. It then formats the Double value into a String using the ExcelNumberUtils.format method, with the retrieved Java format as one of the parameters. The formatted String value is then set as the value of the Cell object using the setCellValue method.\n\nThe second overridden method is getExcelType. This method returns an enumeration value of ExcelType.STRING, indicating that the Excel cell type handled by this class is a string.\"",
        "sketchy_description": "The public class DoubleStringHandler, which extends the AbstractDoubleCellHandler, is specifically designed to handle the conversion of double values into string representations for cell values within Excel spreadsheets. This class provides a method setCellValue, which is protected and takes a RowContext, an ExcelFieldConfig, a Cell, and a Double as parameters. The primary purpose of this method is to set the cell's value in the spreadsheet as a formatted string that accurately reflects the double value, while also taking into account any specific formatting or configuration rules defined by the ExcelFieldConfig. Additionally, the class offers a public method getExcelType, which returns an ExcelType enumeration value. This value corresponds to STRING, clearly indicating that the type of value this handler is concerned with is string representations of double values. This is particularly useful when dealing with Excel spreadsheets that require precise formatting and type consistency for numerical data.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/doubles/DoubleStringHandler.java",
        "class_name": "DoubleStringHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "DoubleStringHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/DoubleStringHandlerTest.java"
        },
        "task_id": 96,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.doubles;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport io.github.zouzhiy.excel.utils.ExcelNumberUtils;\nimport org.apache.poi.ss.usermodel.Cell;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class DoubleStringHandler extends AbstractDoubleCellHandler {\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, Double value) {\n        String javaFormat = this.getJavaFormat(excelFieldConfig);\n        String strValue = ExcelNumberUtils.format(value, javaFormat);\n        cell.setCellValue(strValue);\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.STRING;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class FileInfoSerDe is designed to handle the serialization and deserialization of FileInfo objects. This class has two main methods: serialiseFileInfo and deserialiseFileInfo.\n\nThe serialiseFileInfo method takes a FileInfo object as an argument and converts it into a byte array. This method uses a ByteArrayOutputStream and a DataOutputStream to write the data of the FileInfo object into a byte array. It first writes the size of the rowKeyTypes list, then it iterates over each PrimitiveType in the list and writes its class name and the corresponding min and max row keys. The method also writes the filename, file status, number of records, partition ID, and job ID of the FileInfo object. If the job ID is null, it writes a boolean value of false; otherwise, it writes a boolean value of true followed by the job ID. The method then closes the DataOutputStream and returns the byte array.\n\nThe deserialiseFileInfo method takes a byte array as an argument and converts it back into a FileInfo object. This method uses a ByteArrayInputStream and a DataInputStream to read the data from the byte array. It first reads the number of row keys, then it creates a new list for the rowKeyTypes, minRowKey, and maxRowKey. It then iterates over each row key and reads its class name and the corresponding min and max row keys. The method also reads the filename, file status, number of records, partition ID, and job ID of the FileInfo object. If the job ID is not null, it reads the job ID; otherwise, it skips it. The method then returns a new FileInfo object built with the read data.\"",
        "sketchy_description": "The public class FileInfoSerDe is responsible for the serialization and deserialization of FileInfo objects, which are presumably custom objects that contain metadata about files. Serialization is the process of converting an object into a byte array so that it can be easily stored or transmitted, while deserialization is the reverse process, converting a byte array back into an object.\n\nThe class provides two methods for these purposes. The serialiseFileInfo method takes a FileInfo object as a parameter and serializes it into a byte array. This process involves encoding various attributes of the FileInfo object, such as row key types, min and max row keys, filename, file status, number of records, partition ID, and job ID if they are present. This method may throw an IOException, which is a signal to the caller that something went wrong during the serialization process.\n\nOn the other hand, the deserialiseFileInfo method takes a byte array as input and deserializes it to reconstruct a FileInfo object. It extracts and interprets the data contained in the byte array to restore the FileInfo object's attributes, such as row key types, min and max row keys, filename, file status, number of records, partition ID, and job ID. Similar to the serialization method, deserialiseFileInfo can also throw an IOException, indicating an issue during the deserialization process.\n\nThese methods are essential for systems that need to persist FileInfo objects or transmit them between different parts of a system or across network boundaries.",
        "file": "sleeper/java/statestore/src/main/java/sleeper/statestore/FileInfoSerDe.java",
        "class_name": "FileInfoSerDe",
        "repo_metadata": {
            "repo_name": "sleeper"
        },
        "evaluation_metadata": {
            "test_class_name": "FileInfoSerDeTest",
            "test_file": "sleeper/java/statestore/src/test/java/sleeper/statestore/FileInfoSerDeTest.java"
        },
        "task_id": 97,
        "ground_truth_class_body": "/*\n * Copyright 2022-2023 Crown Copyright\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage sleeper.statestore;\n\nimport sleeper.core.key.Key;\nimport sleeper.core.schema.type.ByteArrayType;\nimport sleeper.core.schema.type.IntType;\nimport sleeper.core.schema.type.LongType;\nimport sleeper.core.schema.type.PrimitiveType;\nimport sleeper.core.schema.type.StringType;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Serialises a {@link FileInfo} to and from a <code>byte[]</code>.\n */\npublic class FileInfoSerDe {\n\n    public byte[] serialiseFileInfo(FileInfo fileInfo) throws IOException {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        DataOutputStream dos = new DataOutputStream(baos);\n        List<PrimitiveType> rowKeyTypes = fileInfo.getRowKeyTypes();\n        dos.writeInt(rowKeyTypes.size());\n        int count = 0;\n        for (PrimitiveType type : rowKeyTypes) {\n            dos.writeUTF(type.getClass().getSimpleName());\n            if (type instanceof IntType) {\n                dos.writeInt((int) fileInfo.getMinRowKey().get(count));\n                dos.writeInt((int) fileInfo.getMaxRowKey().get(count));\n            } else if (type instanceof LongType) {\n                dos.writeLong((long) fileInfo.getMinRowKey().get(count));\n                dos.writeLong((long) fileInfo.getMaxRowKey().get(count));\n            } else if (type instanceof StringType) {\n                dos.writeUTF((String) fileInfo.getMinRowKey().get(count));\n                dos.writeUTF((String) fileInfo.getMaxRowKey().get(count));\n            } else if (type instanceof ByteArrayType) {\n                byte[] minBA = (byte[]) fileInfo.getMinRowKey().get(count);\n                byte[] maxBA = (byte[]) fileInfo.getMaxRowKey().get(count);\n                dos.writeInt(minBA.length);\n                dos.write(minBA);\n                dos.writeInt(maxBA.length);\n                dos.write(maxBA);\n            } else {\n                throw new RuntimeException(\"Unknown type of \" + type);\n            }\n            count++;\n        }\n        dos.writeUTF(fileInfo.getFilename());\n        dos.writeUTF(fileInfo.getFileStatus().toString());\n        dos.writeLong(fileInfo.getNumberOfRecords());\n        dos.writeUTF(fileInfo.getPartitionId());\n        if (null != fileInfo.getJobId()) {\n            dos.writeBoolean(true);\n            dos.writeUTF(fileInfo.getJobId());\n        } else {\n            dos.writeBoolean(false);\n        }\n        dos.close();\n        return baos.toByteArray();\n    }\n\n    public FileInfo deserialiseFileInfo(byte[] bytes) throws IOException {\n        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n        DataInputStream dis = new DataInputStream(bais);\n        int numRowKeys = dis.readInt();\n        List<PrimitiveType> rowKeyTypes = new ArrayList<>();\n        List<Object> minRowKey = new ArrayList<>();\n        List<Object> maxRowKey = new ArrayList<>();\n        for (int i = 0; i < numRowKeys; i++) {\n            String simpleClassName = dis.readUTF();\n            PrimitiveType keyType;\n            if (simpleClassName.equals(IntType.class.getSimpleName())) {\n                keyType = new IntType();\n                minRowKey.add(dis.readInt());\n                maxRowKey.add(dis.readInt());\n            } else if (simpleClassName.equals(LongType.class.getSimpleName())) {\n                keyType = new LongType();\n                minRowKey.add(dis.readLong());\n                maxRowKey.add(dis.readLong());\n            } else if (simpleClassName.equals(StringType.class.getSimpleName())) {\n                keyType = new StringType();\n                minRowKey.add(dis.readUTF());\n                maxRowKey.add(dis.readUTF());\n            } else if (simpleClassName.equals(ByteArrayType.class.getSimpleName())) {\n                keyType = new ByteArrayType();\n                int minBASize = dis.readInt();\n                byte[] min = new byte[minBASize];\n                dis.readFully(min);\n                minRowKey.add(min);\n                int maxBASize = dis.readInt();\n                byte[] max = new byte[maxBASize];\n                dis.readFully(max);\n                maxRowKey.add(max);\n            } else {\n                throw new IOException(\"Unknown type of \" + simpleClassName);\n            }\n            rowKeyTypes.add(keyType);\n        }\n\n        return FileInfo.builder()\n                .rowKeyTypes(rowKeyTypes)\n                .minRowKey(Key.create(minRowKey))\n                .maxRowKey(Key.create(maxRowKey))\n                .filename(dis.readUTF())\n                .fileStatus(FileInfo.FileStatus.valueOf(dis.readUTF()))\n                .numberOfRecords(dis.readLong())\n                .partitionId(dis.readUTF())\n                .jobId(dis.readBoolean() ? dis.readUTF() : null)\n                .build();\n    }\n}\n"
    },
    {
        "detailed_description": "The public class HeadStringHandler is designed to handle string data in Excel cells. It implements the CellHandler interface, which is a generic interface that takes a type parameter. In this case, the type parameter is String, indicating that this class is designed to handle string data.\n\nThe getJavaType method is overridden from the CellHandler interface and returns the Class object for String, indicating that this class handles string data. The getExcelType method is also overridden and returns ExcelType.STRING, further indicating that this class handles string data.\n\nThe read method is responsible for reading string data from an Excel cell. It takes three parameters: a SheetContext object, an ExcelFieldConfig object, and a CellResultSet object. If the CellResultSet object is null, or if it contains no data or blank data, the method returns null. Otherwise, it returns the string value of the first cell in the CellResultSet.\n\nThe write method is responsible for writing string data to an Excel cell. It takes four parameters: a RowContext object, an Integer representing the column index, an ExcelFieldConfig object, and a String value. The method creates a new cell at the specified column index in the first row of the RowContext, sets the cell's value to the provided String value, and applies a style to the cell based on the ExcelFieldConfig. If the RowContext and ExcelFieldConfig specify a merged region, the method also adds this merged region to the sheet.\n\nOverall, this class provides a way to handle string data in Excel cells, including reading from and writing to cells, and applying styles and merged regions as necessary.\"",
        "sketchy_description": "The public class HeadStringHandler, which implements the CellHandler interface specifically for String types, is designed to facilitate the interaction with Excel cells, particularly for reading and writing String values. This class is equipped with methods that define the Java and Excel types it handles, as well as the operations for reading from and writing to Excel cells.\n\nThe getJavaType method indicates that the Java type managed by this handler is String.class, which is the standard class for representing strings in Java.\n\nThe getExcelType method specifies that the corresponding Excel type for this handler is ExcelType.STRING, which is the type used in Excel to represent text cells.\n\nThe read method takes a SheetContext, an ExcelFieldConfig, and a CellResultSet as parameters and is responsible for extracting a String value from an Excel cell. It returns null if the cell is empty or if the value is a blank string, ensuring that only meaningful string data is retrieved.\n\nThe write method is designed to insert a String value into an Excel cell at a given column index. It accepts a RowContext, an Integer for the column index, an ExcelFieldConfig, and the String value to be written. This method also takes care of applying the appropriate cell style and managing merged regions if necessary, ensuring that the written data is formatted correctly within the Excel sheet.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/head/HeadStringHandler.java",
        "class_name": "HeadStringHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "HeadStringHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/HeadStringHandlerTest.java"
        },
        "task_id": 98,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.head;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.context.SheetContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.handler.CellHandler;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport io.github.zouzhiy.excel.metadata.result.CellResult;\nimport io.github.zouzhiy.excel.metadata.result.CellResultSet;\nimport io.github.zouzhiy.excel.utils.RegionUtils;\nimport org.apache.poi.ss.usermodel.Cell;\nimport org.apache.poi.ss.usermodel.CellStyle;\nimport org.apache.poi.ss.usermodel.Row;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class HeadStringHandler implements CellHandler<String> {\n\n    @Override\n    public Class<String> getJavaType() {\n        return String.class;\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.STRING;\n    }\n\n    @Override\n    public String read(SheetContext sheetContext, ExcelFieldConfig excelFieldConfig, CellResultSet cellResultSet) {\n        if (cellResultSet == null) {\n            return null;\n        }\n        CellResult firstCellResult = cellResultSet.getFirstCellResult();\n        if (cellResultSet.isNone() || firstCellResult.isNone()) {\n            return null;\n        } else if (firstCellResult.isBlank()) {\n            return null;\n        }\n        return firstCellResult.getStringValue();\n    }\n\n    @Override\n    public void write(RowContext rowContext, Integer columnIndex, ExcelFieldConfig excelFieldConfig, String value) {\n        Row row = rowContext.getRowList().get(0);\n        Cell cell = row.createCell(columnIndex);\n        cell.setCellValue(value);\n\n        SheetContext sheetContext = rowContext.getSheetContext();\n        CellStyle cellStyle = sheetContext.getHeadCellStyle(excelFieldConfig);\n        cell.setCellStyle(cellStyle);\n\n        int rowspan = rowContext.getRowspan();\n        int colspan = excelFieldConfig.getColspan();\n        int rowIndex = row.getRowNum();\n        RegionUtils.addMergedRegionIfPresent(sheetContext, cellStyle, rowIndex, rowIndex + rowspan - 1, columnIndex, columnIndex + colspan - 1);\n    }\n}\n"
    },
    {
        "detailed_description": "The public class FloatNumberHandler is a subclass of the AbstractFloatCellHandler class. This class is designed to handle operations related to floating point numbers in Excel cells. It overrides two methods from its superclass. The first method, setCellValue, is designed to set the value of a cell in an Excel row. It takes four parameters: a RowContext object that represents the current row, an ExcelFieldConfig object that contains configuration details for the Excel field, a Cell object that represents the cell in which the value is to be set, and a Float value that is the value to be set in the cell. The method then calls the setCellValue method on the Cell object, passing the Float value as an argument. The second method, getExcelType, is designed to return the type of the Excel cell. In this case, it returns ExcelType.NUMERIC, indicating that the cell is expected to contain a numeric value.\"",
        "sketchy_description": "The public class FloatNumberHandler, which extends the AbstractFloatCellHandler, is designed to handle the manipulation of float values within Excel cells. This class provides a method to set the value of a cell with a float number, ensuring that the data is correctly formatted and stored within an Excel spreadsheet. The setCellValue method is a protected method that takes a RowContext, an ExcelFieldConfig, a Cell, and a Float as parameters. It is responsible for setting the cell's value to the specified float value, which is crucial for maintaining accurate numerical data in Excel documents. Additionally, the class offers a public method named getExcelType, which returns the ExcelType that corresponds to numeric values. This method is essential for identifying the type of data being handled, particularly when dealing with various data types in Excel spreadsheets.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/floats/FloatNumberHandler.java",
        "class_name": "FloatNumberHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "FloatNumberHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/FloatNumberHandlerTest.java"
        },
        "task_id": 99,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.floats;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport org.apache.poi.ss.usermodel.Cell;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class FloatNumberHandler extends AbstractFloatCellHandler {\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, Float value) {\n        cell.setCellValue(value);\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.NUMERIC;\n    }\n}\n"
    },
    {
        "detailed_description": "The public abstract class AbstractPdfBoxSource is a generic class that implements the PdfSource interface. It is designed to handle PDF sources of any type, as indicated by the generic parameter T. The class is authored by Tracy and has been in use since version 0.2.1.\n\nThe class has four protected member variables. The first, 'source', is of generic type T and represents the source of the PDF. The second, 'readCompleted', is a boolean flag that indicates whether the reading of the source is complete. The third, 'pdf', is an object of type PDDocument that represents the PDF document. The fourth, 'closed', is a boolean flag that indicates whether the source is closed.\n\nThe class has a constructor that takes a single argument of generic type T and assigns it to the 'source' member variable.\n\nThe class implements several methods from the PdfSource interface. The 'maxPageNumber' method returns the maximum number of pages in the PDF document. The 'read' method reads a specific page from the PDF document and returns it as a BufferedImage. The 'getSource' method returns the source of the PDF. The 'read' method with two parameters reads multiple pages from the PDF document and returns them as a list of BufferedImages. The 'isReadCompleted' method returns the 'readCompleted' flag.\n\nThe class also has three additional methods. The 'loadIfNot' method loads the PDF source if it has not been loaded yet. The 'doLoad' method is an abstract method that must be implemented by subclasses to load the PDF source. The 'close' method frees resources and resets the status of the source.\n\nFinally, the 'isClosed' method returns the 'closed' flag, indicating whether the source is closed.\"",
        "sketchy_description": "The public abstract class AbstractPdfBoxSource, parameterized by <T>, serves as a template for various PDF sources and is part of the PdfSource interface. Authored by Tracy and introduced in version 0.2.1, this class encapsulates the functionality common to all PDF sources. It holds a protected final variable 'source' of type T, which represents the underlying source of the PDF. Additionally, it maintains flags 'readCompleted' and 'closed' to track the state of reading completion and whether the source is closed, respectively, and a 'pdf' variable of type PDDocument for the PDF document object.\n\nThe constructor of this class takes a single argument of type T and is responsible for initializing the PDF source with the provided source object. The class exposes several methods for interacting with the PDF source:\n\n- The maxPageNumber method, which throws an IOException, returns the maximum number of pages in the PDF document.\n- The read method, also throwing an IOException, reads a single page from the PDF document at a specified DPI and returns it as a BufferedImage.\n- The getSource method returns the underlying source of the PDF.\n- Another read method allows reading multiple pages specified by an array of page indexes at a given DPI and returns a list of BufferedImages.\n- The isReadCompleted method checks if the reading of the PDF source has been completed.\n- The loadIfNot method, protected and throwing an IOException, loads the PDF source if it has not been loaded already.\n- The doLoad method is an abstract protected method that throws an IOException and must be implemented by subclasses to load the PDF source.\n- The close method, which throws an IOException, is responsible for closing the PDF source and releasing any system resources associated with it.\n- Lastly, the isClosed method checks if the PDF source is currently closed.\n\nThese methods provide a comprehensive interface for managing and accessing PDF documents, ensuring that subclasses can implement specific behaviors for different types of PDF sources while relying on the common functionality provided by the AbstractPdfBoxSource class.",
        "file": "imglib/pipe/src/main/java/cn/pipe/in/AbstractPdfBoxSource.java",
        "class_name": "AbstractPdfBoxSource",
        "repo_metadata": {
            "repo_name": "imglib"
        },
        "evaluation_metadata": {
            "test_class_name": "AbstractPdfBoxSourceTest",
            "test_file": "imglib/pipe/src/test/java/cn/pipe/in/AbstractPdfBoxSourceTest.java"
        },
        "task_id": 100,
        "ground_truth_class_body": "package cn.pipe.in;\n\nimport cn.core.in.PdfSource;\nimport org.apache.pdfbox.pdmodel.PDDocument;\nimport org.apache.pdfbox.rendering.ImageType;\nimport org.apache.pdfbox.rendering.PDFRenderer;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * An abstract superclass of pdf source.\n *\n * @param <T> The type of pdf source.\n * @author tracy\n * @since 0.2.1\n */\npublic abstract class AbstractPdfBoxSource<T> implements PdfSource<T> {\n\n    /**\n     * The source.\n     */\n    protected final T source;\n\n    /**\n     * The flag that indicating the completion of reading.\n     */\n    protected boolean readCompleted = false;\n\n    /**\n     * The pdf document object.\n     */\n    protected PDDocument pdf;\n\n    /**\n     * Indicates whether the source is closed.\n     * <ul>\n     * <li>It will be set to <code>true</code> because there has no resource to\n     * release when object is instantiated.</li>\n     *\n     * <li>It will become <code>false</code> when the pdf document is loaded.</li>\n     *\n     * <li>It will become <code>true</code> when method of\n     * {@link AbstractPdfBoxSource#close()} is called.</li>\n     * </ul>\n     */\n    protected boolean closed = true;\n\n\n    protected AbstractPdfBoxSource(T source) {\n        this.source = source;\n    }\n\n    @Override\n    public int maxPageNumber() throws IOException {\n        loadIfNot();\n        return pdf.getNumberOfPages();\n    }\n\n    @Override\n    public BufferedImage read(int pageIndex, float dpi) throws IOException {\n        loadIfNot();\n        PDFRenderer renderer = new PDFRenderer(pdf);\n        return renderer.renderImageWithDPI(pageIndex, dpi, ImageType.RGB);\n    }\n\n    @Override\n    public T getSource() {\n        return source;\n    }\n\n    @Override\n    public List<BufferedImage> read(Integer[] pageIndexes, float dpi) throws IOException {\n        loadIfNot();\n        PDFRenderer renderer = new PDFRenderer(pdf);\n\n        List<BufferedImage> tars = new ArrayList<>();\n        for (Integer pIndex : pageIndexes) {\n            tars.add(renderer.renderImageWithDPI(pIndex, dpi, ImageType.RGB));\n        }\n        return tars;\n    }\n\n    @Override\n    public boolean isReadCompleted() {\n        return readCompleted;\n    }\n\n    /**\n     * Load the pdf source if the source have not loaded.\n     * @throws IOException If some I/O exceptions occurred when loading the pdf source.\n     */\n    protected void loadIfNot() throws IOException {\n        if (readCompleted) {\n            return;\n        }\n        pdf = doLoad();\n        readCompleted = true;\n        closed = false;\n    }\n\n    /**\n     * Load the pdf source.\n     * @return The object of loaded GIF.\n     * @throws IOException If some I/O exceptions occurred when loading the pdf source.\n     */\n    protected abstract PDDocument doLoad() throws IOException;\n\n    /**\n     * Free resources and reset status.\n     *\n     * @throws IOException If some I/O exceptions occurred when loading the pdf source.\n     */\n    @Override\n    public void close() throws IOException {\n        if (pdf != null && !pdf.getDocument().isClosed()) {\n            // release the object of PDDocument\n            pdf.close();\n            // reset the closed flag\n            closed = true;\n        }\n    }\n\n    @Override\n    public boolean isClosed() {\n        return closed;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class BigIntegerStringHandler is a specialized class that extends the AbstractBigIntegerCellHandler class. This class is designed to handle BigInteger values in the context of Excel cells. It overrides two methods from its superclass. \n\nThe first overridden method is setCellValue. This method is designed to set the value of a cell in an Excel row. It takes four parameters: a RowContext object that represents the current row, an ExcelFieldConfig object that contains configuration information for the Excel field, a Cell object that represents the cell to be modified, and a BigInteger value that represents the value to be set in the cell. Inside this method, it first retrieves the Java format string from the ExcelFieldConfig object. Then, it formats the BigInteger value according to this format string using the ExcelNumberUtils.format method. Finally, it sets the formatted string as the value of the cell.\n\nThe second overridden method is getExcelType. This method returns an enumeration value that represents the type of Excel cell that this handler is designed to work with. In this case, it returns ExcelType.STRING, indicating that this handler is designed to work with cells that contain string values.\"",
        "sketchy_description": "The public class BigIntegerStringHandler, which extends the AbstractBigIntegerCellHandler, is specifically designed to handle the conversion of BigInteger values into a String format suitable for display in Excel cells. This functionality is particularly important when dealing with large integer values that need to be accurately represented within a spreadsheet environment.\n\nThe class provides a protected method setCellValue, which takes a RowContext, an ExcelFieldConfig, a Cell, and a BigInteger value as parameters. This method is responsible for setting the value of a given cell in the Excel sheet to the string representation of the BigInteger value, ensuring that the value is formatted correctly for the context of the Excel document.\n\nAdditionally, the class includes a public method getExcelType, which returns an ExcelType enumeration value. This method signifies the type of data that the handler is dealing with, which in this case is String types within Excel. This information can be used by other components of the system to understand how to interact with the handler when processing Excel documents that contain BigInteger values.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/biginteger/BigIntegerStringHandler.java",
        "class_name": "IntegerStringHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "IntegerStringHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/BigIntegerStringHandlerTest.java"
        },
        "task_id": 101,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.biginteger;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport io.github.zouzhiy.excel.utils.ExcelNumberUtils;\nimport org.apache.poi.ss.usermodel.Cell;\n\nimport java.math.BigInteger;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class BigIntegerStringHandler extends AbstractBigIntegerCellHandler {\n\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, BigInteger value) {\n        String javaFormat = this.getJavaFormat(excelFieldConfig);\n        String strValue = ExcelNumberUtils.format(value, javaFormat);\n        cell.setCellValue(strValue);\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.STRING;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class LocalTimeNumberHandler is a subclass of the AbstractLocalTimeCellHandler class. This class is designed to handle the conversion of local time values to a format that can be used in an Excel cell. The class overrides two methods from its superclass.\n\nThe first overridden method is setCellValue. This method takes four parameters: a RowContext object, an ExcelFieldConfig object, a Cell object, and a LocalTime value. The method first creates a LocalDateTime object by adding one day to the epoch (the start of Unix time, represented as 0), and then setting the hour, minute, second, and nanosecond to match the LocalTime value passed in. It then sets the value of the Excel cell to the Excel date representation of this LocalDateTime.\n\nThe second overridden method is getExcelType. This method returns an ExcelType enumeration value, specifically ExcelType.NUMERIC. This indicates that the Excel cell should be formatted to hold a numeric value, which in this case is a date and time value.\"",
        "sketchy_description": "The public class LocalTimeNumberHandler, which extends the AbstractLocalTimeCellHandler, is specifically designed to handle the conversion of LocalTime values into a numeric format that is compatible with Excel. This functionality is crucial when dealing with time data in Java applications that need to interact with Excel spreadsheets, ensuring that time values are represented accurately and consistently within the spreadsheet environment.\n\nThe class overrides two methods from its superclass. The first method, setCellValue, takes a RowContext, an ExcelFieldConfig, a Cell, and a LocalTime value as parameters. This method is responsible for setting the cell's value in an Excel sheet to the numeric representation of the provided LocalTime value. This conversion is essential for maintaining the integrity of time data when it is transferred to an Excel spreadsheet.\n\nThe second method, getExcelType, is also an overridden method that returns the ExcelType enumeration value corresponding to the numeric type. This method informs the system of the type of Excel cell that should be used to represent the LocalTime value, ensuring that the data is handled and formatted correctly within the spreadsheet.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/localtime/LocalTimeNumberHandler.java",
        "class_name": "LocalTimeNumberHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "LocalTimeNumberHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/LocalTimeNumberHandlerTest.java"
        },
        "task_id": 102,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.localtime;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport org.apache.poi.ss.usermodel.Cell;\nimport org.apache.poi.ss.usermodel.DateUtil;\n\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class LocalTimeNumberHandler extends AbstractLocalTimeCellHandler {\n\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, LocalTime value) {\n        LocalDateTime localDateTime = DateUtil.getLocalDateTime(0)\n                .plusDays(1)\n                .withHour(value.getHour())\n                .withMinute(value.getMinute())\n                .withSecond(value.getSecond())\n                .withNano(value.getNano());\n        cell.setCellValue(DateUtil.getExcelDate(localDateTime));\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.NUMERIC;\n    }\n}\n"
    },
    {
        "detailed_description": "The class AbstractQuery<T> is a generic class that is designed to create and manage query conditions for a database. It has two protected String members, orderByColumn and isAsc, which are used to specify the column by which the query results should be ordered and the direction of the ordering, respectively. It also has two private Date members, beginTime and endTime, which are used to specify the time range for the query. These Date members are annotated with @JsonFormat to specify the format in which they should be serialized/deserialized.\n\nThe class also defines two static final String constants, ASC and DESC, which represent the possible values for the isAsc member.\n\nThe class has an abstract method toQueryWrapper, which is intended to be overridden by subclasses to generate a QueryWrapper object based on the current state of the AbstractQuery object.\n\nThe class also has three public methods, addSortCondition, addTimeCondition, and convertSortDirection. The addSortCondition method takes a QueryWrapper object and adds a sort condition to it based on the orderByColumn and isAsc members. The addTimeCondition method takes a QueryWrapper object and a fieldName, and adds a time condition to the QueryWrapper based on the beginTime and endTime members and the specified field. The convertSortDirection method converts the isAsc member to a boolean value, with true representing ascending order and false representing descending order.\"",
        "sketchy_description": "The `AbstractQuery` class is a generic abstract class that serves as a template for creating query conditions for a specific type `T`. It is designed to be extended by other classes that will implement the abstract methods and utilize the provided functionality to construct query conditions for database operations or similar use cases.\n\nThe class contains several class variables, including `orderByColumn` and `isAsc`, which are used to specify the column by which the results should be ordered and the direction of the sort (ascending or descending), respectively. Additionally, it includes `beginTime` and `endTime` fields, which are annotated with `@JsonFormat` to ensure proper serialization and deserialization of date values in a specific pattern. The class also defines constants `ASC` and `DESC` to represent the ascending and descending sort directions.\n\nThe `toQueryWrapper` method is an abstract method that must be implemented by subclasses. This method is responsible for converting the current state of the query into a `QueryWrapper` object, which is typically used to encapsulate query conditions and parameters.\n\nThe `addSortCondition` method is a concrete method that takes a `QueryWrapper` object as an argument and adds sorting conditions to it based on the current values of `orderByColumn` and `isAsc`. This allows for dynamic sorting of query results based on the specified conditions.\n\nThe `addTimeCondition` method is another concrete method that adds time range conditions to the provided `QueryWrapper` object. It uses the `beginTime` and `endTime` fields to define the range and applies these conditions to the specified `fieldName` within the `QueryWrapper`.\n\nLastly, the `convertSortDirection` method is a utility method that converts the `isAsc` string into a boolean value representing the sort direction. This method returns `true` if the sort direction is ascending, allowing for easier interpretation and use of the sort direction in code.\n\nIn summary, the `AbstractQuery` class provides a foundation for building complex query conditions with sorting and time range capabilities, which can be tailored to specific types and use cases by subclasses that implement the abstract methods.",
        "file": "AgileBoot-Back-End/agileboot-orm/src/main/java/com/agileboot/orm/common/query/AbstractQuery.java",
        "class_name": "AbstractQuery",
        "repo_metadata": {
            "repo_name": "AgileBoot-Back-End"
        },
        "evaluation_metadata": {
            "test_class_name": "AbstractQueryTest",
            "test_file": "AgileBoot-Back-End/agileboot-infrastructure/src/test/java/com/agileboot/orm/query/AbstractQueryTest.java"
        },
        "task_id": 103,
        "ground_truth_class_body": "package com.agileboot.orm.common.query;\n\nimport cn.hutool.core.util.StrUtil;\nimport com.agileboot.common.utils.time.DatePickUtil;\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\nimport com.fasterxml.jackson.annotation.JsonFormat;\nimport com.fasterxml.jackson.annotation.JsonFormat.Shape;\nimport java.util.Date;\nimport lombok.Data;\n\n/**\n * @author valarchie\n */\n@Data\npublic abstract class AbstractQuery<T> {\n\n    protected String orderByColumn;\n\n    protected String isAsc;\n\n    @JsonFormat(shape = Shape.STRING, pattern = \"yyyy-MM-dd\")\n    private Date beginTime;\n\n    @JsonFormat(shape = Shape.STRING, pattern = \"yyyy-MM-dd\")\n    private Date endTime;\n\n    private static final String ASC = \"ascending\";\n    private static final String DESC = \"descending\";\n\n    /**\n     * \u751f\u6210query conditions\n     * @return\n     */\n    public abstract QueryWrapper<T> toQueryWrapper();\n\n    public void addSortCondition(QueryWrapper<T> queryWrapper) {\n        if(queryWrapper != null) {\n            boolean sortDirection = convertSortDirection();\n            queryWrapper.orderBy(StrUtil.isNotBlank(orderByColumn), sortDirection,\n                StrUtil.toUnderlineCase(orderByColumn));\n        }\n    }\n\n    public void addTimeCondition(QueryWrapper<T> queryWrapper, String fieldName) {\n        if (queryWrapper != null) {\n            queryWrapper\n                .ge(beginTime != null, fieldName, DatePickUtil.getBeginOfTheDay(beginTime))\n                .le(endTime != null, fieldName, DatePickUtil.getEndOfTheDay(endTime));\n        }\n    }\n\n    public boolean convertSortDirection() {\n        boolean orderDirection = true;\n        if (StrUtil.isNotEmpty(isAsc)) {\n            if (ASC.equals(isAsc)) {\n                orderDirection = true;\n            } else if (DESC.equals(isAsc)) {\n                orderDirection = false;\n            }\n        }\n        return orderDirection;\n    }\n\n}\n"
    },
    {
        "detailed_description": "The public class BuildEC2Parameters is designed to handle parameters for building an EC2 instance in a cloud environment. It contains three public static final StringParameters: REPOSITORY, FORK, and BRANCH, which are initialized with corresponding values from the AppParameters class. \n\nThe class also has four private final fields: repository, fork, branch, and image. The repository, fork, and branch fields are of type String and are initialized with the values from the AppContext context passed to the private constructor of the class. The image field is of type BuildEC2Image and is initialized using the static method from() of the BuildEC2Image class, which also takes the AppContext context as an argument.\n\nThe class provides a static method from() that takes an AppContext context as an argument and returns a new instance of BuildEC2Parameters, initialized with the values from the context.\n\nThe fillUserDataTemplate() method is a public method that takes a String template as an argument and returns a String. It replaces placeholders in the template with the values of the repository, fork, branch fields, and the loginUser from the image field.\n\nThe image() method is a public method that returns the value of the image field. This method can be used to access the BuildEC2Image object associated with the instance of the BuildEC2Parameters class.\"",
        "sketchy_description": "The public class BuildEC2Parameters is designed to encapsulate the various parameters that are necessary for constructing an Amazon EC2 (Elastic Compute Cloud) instance. These parameters are represented as class variables and include the repository, fork, and branch information, which are essential for defining the source and configuration of the code that the EC2 instance will run. The class variables are initialized with values from the AppParameters class, ensuring that they are consistent and easily manageable.\n\nThe constructor of the class is private, indicating that instances of BuildEC2Parameters are not meant to be created directly using the new keyword. Instead, the class provides a static factory method named from, which takes an AppContext object as an argument. This method is responsible for creating a new instance of BuildEC2Parameters, ensuring that it is properly initialized with the context provided.\n\nAdditionally, the class offers a method called fillUserDataTemplate, which takes a String representing a user data template and replaces placeholders within it with the actual parameter values. This is particularly useful for customizing the startup behavior of the EC2 instance by injecting specific configuration details into the user data script.\n\nFinally, the image method returns a BuildEC2Image object that is associated with the parameters contained within the BuildEC2Parameters instance. This method allows for the retrieval of an image object that can be used to perform further actions or obtain additional information related to the EC2 instance being built.",
        "file": "sleeper/java/cdk-environment/src/main/java/sleeper/environment/cdk/buildec2/BuildEC2Parameters.java",
        "class_name": "BuildEC2Parameters",
        "repo_metadata": {
            "repo_name": "sleeper"
        },
        "evaluation_metadata": {
            "test_class_name": "BuildEC2ParametersTest",
            "test_file": "sleeper/java/cdk-environment/src/test/java/sleeper/environment/cdk/buildec2/BuildEC2ParametersTest.java"
        },
        "task_id": 104,
        "ground_truth_class_body": "/*\n * Copyright 2022-2023 Crown Copyright\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage sleeper.environment.cdk.buildec2;\n\nimport sleeper.environment.cdk.config.AppContext;\nimport sleeper.environment.cdk.config.AppParameters;\nimport sleeper.environment.cdk.config.StringParameter;\n\npublic class BuildEC2Parameters {\n\n    public static final StringParameter REPOSITORY = AppParameters.BUILD_REPOSITORY;\n    public static final StringParameter FORK = AppParameters.BUILD_FORK;\n    public static final StringParameter BRANCH = AppParameters.BUILD_BRANCH;\n\n    private final String repository;\n    private final String fork;\n    private final String branch;\n    private final BuildEC2Image image;\n\n    private BuildEC2Parameters(AppContext context) {\n        repository = context.get(REPOSITORY);\n        fork = context.get(FORK);\n        branch = context.get(BRANCH);\n        image = BuildEC2Image.from(context);\n    }\n\n    static BuildEC2Parameters from(AppContext context) {\n        return new BuildEC2Parameters(context);\n    }\n\n    String fillUserDataTemplate(String template) {\n        return template.replace(\"${repository}\", repository)\n                .replace(\"${fork}\", fork)\n                .replace(\"${branch}\", branch)\n                .replace(\"${loginUser}\", image.loginUser());\n    }\n\n    BuildEC2Image image() {\n        return image;\n    }\n\n}\n"
    },
    {
        "detailed_description": "The public class MaxGrayingStrategy is a subclass of the AbstractGrayingStrategy class. This class is designed to implement a specific strategy for calculating the grayness value of a color, based on the maximum value among the red, green, and blue color components. The class overrides the getGraynessValue method from the AbstractGrayingStrategy class. This method takes three integer arguments, representing the red, green, and blue color components respectively. The method returns the maximum value among these three arguments, which represents the grayness value of the color. This strategy can be used in image processing applications where the grayness value of a color is needed, such as in grayscale conversion or image filtering.\"",
        "sketchy_description": "The public class MaxGrayingStrategy, which extends the AbstractGrayingStrategy class, is designed to implement a specific strategy for converting a color to a grayscale value. This strategy is based on taking the maximum value among the red (r), green (g), and blue (b) components of a color to determine its grayness level. The method getGraynessValue is provided to perform this calculation. It takes three integer arguments corresponding to the RGB components of a color and returns an integer that represents the grayness value. By using the maximum value among the RGB components, this strategy emphasizes the brightest color channel, which can lead to a specific visual effect in the resulting grayscale image.",
        "file": "imglib/ext-t8s/src/main/java/cn/t8s/mode/graying/MaxGrayingStrategy.java",
        "class_name": "MaxGrayingStrategy",
        "repo_metadata": {
            "repo_name": "imglib"
        },
        "evaluation_metadata": {
            "test_class_name": "MaxGrayingStrategyTest",
            "test_file": "imglib/ext-t8s/src/test/java/cn/t8s/mode/graying/MaxGrayingStrategyTest.java"
        },
        "task_id": 105,
        "ground_truth_class_body": "package cn.t8s.mode.graying;\n\nimport cn.core.strategy.mode.AbstractGrayingStrategy;\n\n/**\n * A maximum graying strategy. The gray value of any pixel is equal to the maximum value of\n * the red component, green component and blue component.\n *\n * @author tracy\n * @since 0.2.1\n */\npublic class MaxGrayingStrategy extends AbstractGrayingStrategy {\n    @Override\n    public int getGraynessValue(int r, int g, int b) {\n        return Math.max(Math.max(r, g), b);\n    }\n}\n"
    },
    {
        "detailed_description": "The public class CtaComponent is a class that implements the Styled interface. This class is designed to represent a component of a Call to Action (CTA) in a web application. The class uses annotations to inject dependencies and define default values for its fields. \n\nThe class has a private field 'resourceResolver' of type ResourceResolver, which is annotated with @SlingObject. This field is used to resolve resources in the application.\n\nThe class has a private field 'label' of type String, which is annotated with @Getter, @Inject, and @Default. The @Getter annotation indicates that a getter method for this field is automatically generated. The @Inject annotation is used for dependency injection, and the @Default annotation specifies a default value for this field, which is \"CTA label\".\n\nThe class also has a private field 'link' of type String, which is annotated with @Inject. This field represents the link associated with the CTA component.\n\nThe class has two more private fields 'openInNewTab' and 'displayIcon' of type String, both of which are annotated with @Getter, @Inject, and @Default. The default value for both fields is \"false\".\n\nThe class has a private field 'styled' of type DefaultStyledComponent, which is annotated with @Self and @Delegate. This field represents the default style of the CTA component.\n\nThe class has a public method 'getLink' that returns a String. This method uses the 'link' field and the 'resourceResolver' field to handle the link associated with the CTA component.\"",
        "sketchy_description": "The public class CtaComponent, which implements the Styled interface, is designed to represent a Call-to-Action (CTA) component within a user interface, complete with style options. This class is equipped with various class variables that are annotated to integrate with a content management system, such as Sling in Adobe Experience Manager (AEM). The ResourceResolver is annotated with @SlingObject to facilitate resource resolution within the AEM context.\n\nThe label of the CTA component is managed by a private String variable, which is injected into the class and has a default value of \"CTA label\". This label is accessible through a getter method, thanks to the @Getter annotation. Similarly, the link for the CTA is injected into the class without a default value, and its getter method is provided by the class itself.\n\nThe openInNewTab and displayIcon variables are both Strings that determine whether the CTA should open in a new tab and whether an icon should be displayed, respectively. Both are injected with default values of \"false\" and are accessible through their respective getter methods.\n\nThe styled variable represents the default style component for the CTA and is annotated with @Self to indicate that the instance should be the same as the one being injected, and @Delegate to delegate the implementation of the Styled interface to the DefaultStyledComponent.\n\nThe getLink method is a public method that processes the CTA link using a utility class, LinkUtil, and returns the processed link. This method is essential for ensuring that the link is correctly formatted and ready for use within the CTA component.",
        "file": "howlite/core/src/main/java/pl/ds/howlite/components/models/CtaComponent.java",
        "class_name": "CtaComponent",
        "repo_metadata": {
            "repo_name": "howlite"
        },
        "evaluation_metadata": {
            "test_class_name": "CtaComponentTest",
            "test_file": "howlite/core/src/test/java/pl/ds/howlite/components/models/CtaComponentTest.java"
        },
        "task_id": 106,
        "ground_truth_class_body": "/*\n * Copyright (C) 2022 Dynamic Solutions\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage pl.ds.howlite.components.models;\n\nimport static org.apache.sling.models.annotations.DefaultInjectionStrategy.OPTIONAL;\n\nimport javax.inject.Inject;\nimport lombok.Getter;\nimport lombok.experimental.Delegate;\nimport org.apache.sling.api.resource.Resource;\nimport org.apache.sling.api.resource.ResourceResolver;\nimport org.apache.sling.models.annotations.Default;\nimport org.apache.sling.models.annotations.Model;\nimport org.apache.sling.models.annotations.injectorspecific.Self;\nimport org.apache.sling.models.annotations.injectorspecific.SlingObject;\nimport pl.ds.howlite.components.Styled;\nimport pl.ds.howlite.components.utils.LinkUtil;\n\n@Model(adaptables = Resource.class, defaultInjectionStrategy = OPTIONAL)\npublic class CtaComponent implements Styled {\n\n  @SlingObject\n  private ResourceResolver resourceResolver;\n\n  @Getter\n  @Inject\n  @Default(values = \"CTA label\")\n  private String label;\n\n  @Inject\n  private String link;\n\n  @Getter\n  @Inject\n  @Default(values = \"false\")\n  private String openInNewTab;\n\n  @Getter\n  @Inject\n  @Default(values = \"false\")\n  private String displayIcon;\n\n  @Self\n  @Delegate\n  private DefaultStyledComponent styled;\n\n  public String getLink() {\n    return LinkUtil.handleLink(link, resourceResolver);\n  }\n}\n"
    },
    {
        "detailed_description": "The public class WrappedKeyComparator is designed to compare two keys based on a given schema. This class implements the Comparator interface for the Key type and is also Serializable, meaning it can be converted into a byte stream and restored from it. The class has a serialVersionUID, which is used for version control during the serialization process. \n\nThe class has two private fields: a String 'schemaAsString' and a transient KeyComparator 'keyComparator'. The 'schemaAsString' field holds the schema in a string format, while the 'keyComparator' field is used to compare keys. The 'transient' keyword indicates that 'keyComparator' should not be serialized.\n\nThe constructor for this class takes a string argument representing the schema and initializes the 'schemaAsString' field with this value.\n\nThe class overrides the 'compare' method from the Comparator interface. This method takes two Key objects as arguments and returns an integer. If the 'keyComparator' field is null, it initializes it using the schema. It first converts the schema from JSON format to a Schema object, then gets the row key types and sort key types from the schema, and finally creates a new KeyComparator with these types. After this, it uses the 'keyComparator' to compare the two keys and returns the result.\"",
        "sketchy_description": "The public class WrappedKeyComparator is designed to provide a custom comparison mechanism for Key objects, which is essential when Keys need to be sorted or ordered in a specific way. This class implements the Comparator interface, which requires the implementation of the compare method, and is also marked as Serializable, allowing it to be used in contexts where object serialization is necessary.\n\nThe class contains a static final long serialVersionUID, which is a unique identifier for the Serializable class, ensuring that the serialization process is correctly managed by the JVM. Additionally, the class holds a final String variable named schemaAsString, which represents the schema that will be used for comparing Key objects.\n\nThe constructor of the WrappedKeyComparator class takes a single String argument representing the schema and is responsible for initializing the comparator with this schema. This allows the comparator to be configured with the necessary information to perform comparisons between Key objects according to the rules defined by the schema.\n\nThe compare method is the core of the WrappedKeyComparator class. It takes two Key objects as parameters and compares them based on the schema provided during the initialization of the comparator. The method's implementation ensures that if the KeyComparator has not been initialized with a schema, it will do so using the schema provided at construction. The result of the comparison is an integer that indicates the ordering of the two Key objects: a negative integer if the first Key is less than the second, zero if they are equal, and a positive integer if the first Key is greater than the second. This method is crucial for sorting and ordering Key objects in collections and other data structures that rely on comparison logic.",
        "file": "sleeper/java/bulk-import/bulk-import-runner/src/main/java/sleeper/bulkimport/job/runner/rdd/WrappedKeyComparator.java",
        "class_name": "KeyComparator",
        "repo_metadata": {
            "repo_name": "sleeper"
        },
        "evaluation_metadata": {
            "test_class_name": "KeyComparatorTest",
            "test_file": "sleeper/java/bulk-import/bulk-import-runner/src/test/java/sleeper/bulkimport/job/runner/rdd/WrappedKeyComparatorTest.java"
        },
        "task_id": 107,
        "ground_truth_class_body": "/*\n * Copyright 2022-2023 Crown Copyright\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage sleeper.bulkimport.job.runner.rdd;\n\nimport sleeper.core.key.Key;\nimport sleeper.core.record.KeyComparator;\nimport sleeper.core.schema.Schema;\nimport sleeper.core.schema.SchemaSerDe;\nimport sleeper.core.schema.type.PrimitiveType;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\n\n\n/**\n * The {@link WrappedKeyComparator} is a {@link Comparator} of Sleeper {@link Key}s\n * that sorts them in the natural way as defined by the Sleeper schema, i.e.\n * it sorts by the row keys and then the sort keys.\n */\npublic class WrappedKeyComparator implements Comparator<Key>, Serializable {\n    private static final long serialVersionUID = 7448396149070034670L;\n    private final String schemaAsString;\n    private transient KeyComparator keyComparator;\n\n    public WrappedKeyComparator(String schemaAsString) {\n        this.schemaAsString = schemaAsString;\n    }\n\n    @Override\n    public int compare(Key key1, Key key2) {\n        if (null == keyComparator) {\n            Schema schema = new SchemaSerDe().fromJson(schemaAsString);\n            List<PrimitiveType> rowAndSortKeyTypes = new ArrayList<>();\n            rowAndSortKeyTypes.addAll(schema.getRowKeyTypes());\n            rowAndSortKeyTypes.addAll(schema.getSortKeyTypes());\n            keyComparator = new KeyComparator(rowAndSortKeyTypes);\n        }\n        return keyComparator.compare(key1, key2);\n    }\n}\n"
    },
    {
        "detailed_description": "The public class ExcelClassConfig is designed to configure the Excel class. It contains several private final fields, each representing a different aspect of the Excel class configuration. These fields include rowTitleWrite, rowHeadWrite, rowFootWrite, rowTitleRead, rowHeadRead, rowFootRead, titleFormat, titleStyle, rowStyleRead, itemList, and autoSizeColumn. \n\nThe rowTitleWrite, rowHeadWrite, and rowFootWrite fields are classes that extend the RowTitleWrite, RowHeadWrite, and RowFootWrite classes respectively. They are responsible for writing the title, head, and foot of a row in an Excel sheet. Similarly, the rowTitleRead, rowHeadRead, and rowFootRead fields are classes that extend the RowTitleRead, RowHeadRead, and RowFootRead classes respectively. They are responsible for reading the title, head, and foot of a row in an Excel sheet.\n\nThe titleFormat field is a string that represents the format of the title in the Excel sheet. The titleStyle field is an instance of the ExcelStyleConfig class that represents the style of the title in the Excel sheet. The rowStyleRead field is a class that extends the RowStyleRead class and is responsible for reading the style of a row in an Excel sheet.\n\nThe itemList field is a list of ExcelFieldConfig objects that represent the configuration of fields in the Excel sheet. The autoSizeColumn field is a Boolean that indicates whether the columns in the Excel sheet should be automatically sized.\n\nThe class also contains two static methods: getDefaultExcelClassConfig and buildByExcelClass. The getDefaultExcelClassConfig method returns a default ExcelClassConfig object with a specified list of ExcelFieldConfig objects. The buildByExcelClass method returns an ExcelClassConfig object built from a specified ExcelClass object and a list of ExcelFieldConfig objects.\"",
        "sketchy_description": "The public class ExcelClassConfig is designed to encapsulate the configuration settings for processing Excel classes. This class contains a series of class variables with default values that define the behavior of various components involved in reading and writing Excel rows and styles. These components include classes for writing row titles, headers, and footers, as well as classes for reading the same. Additionally, it includes default formatting for titles, a default style configuration for titles, and a class for reading row styles. The class also maintains a list of ExcelFieldConfig items and a flag to determine whether columns should be automatically sized.\n\nThe method `getDefaultExcelClassConfig` is a static factory method that returns a new instance of ExcelClassConfig with a specified list of ExcelFieldConfig items. This allows for the creation of a default configuration tailored to the needs of the user based on the provided field configurations.\n\nThe method `buildByExcelClass` is another static factory method that constructs an ExcelClassConfig object based on the provided ExcelClass and a list of ExcelFieldConfig items. This method enables the creation of a configuration that is specific to the given ExcelClass, allowing for a more customized setup for Excel processing tasks.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/metadata/config/ExcelClassConfig.java",
        "class_name": "ExcelClassConfig",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "ExcelClassConfigTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/metadata/config/ExcelClassConfigTest.java"
        },
        "task_id": 108,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.metadata.config;\n\nimport io.github.zouzhiy.excel.annotation.ExcelClass;\nimport io.github.zouzhiy.excel.cellstyle.RowStyleRead;\nimport io.github.zouzhiy.excel.cellstyle.defaults.DefaultRowStyleRead;\nimport io.github.zouzhiy.excel.read.RowFootRead;\nimport io.github.zouzhiy.excel.read.RowHeadRead;\nimport io.github.zouzhiy.excel.read.RowTitleRead;\nimport io.github.zouzhiy.excel.read.defaults.DefaultRowFootRead;\nimport io.github.zouzhiy.excel.read.defaults.DefaultRowHeadRead;\nimport io.github.zouzhiy.excel.read.defaults.DefaultRowTitleRead;\nimport io.github.zouzhiy.excel.write.RowFootWrite;\nimport io.github.zouzhiy.excel.write.RowHeadWrite;\nimport io.github.zouzhiy.excel.write.RowTitleWrite;\nimport io.github.zouzhiy.excel.write.defaults.DefaultRowFootWrite;\nimport io.github.zouzhiy.excel.write.defaults.DefaultRowHeadWrite;\nimport io.github.zouzhiy.excel.write.defaults.DefaultRowTitleWrite;\nimport lombok.Builder;\nimport lombok.EqualsAndHashCode;\nimport lombok.Getter;\nimport lombok.ToString;\n\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * \u914d\u7f6e\u4fe1\u606f {@link io.github.zouzhiy.excel.annotation.ExcelClass}\n *\n * @author zouzhiy\n * @since 2022/7/2\n */\n@Getter\n@ToString\n@EqualsAndHashCode\n@Builder\npublic class ExcelClassConfig {\n\n    @Builder.Default\n    private final Class<? extends RowTitleWrite> rowTitleWrite = DefaultRowTitleWrite.class;\n\n    @Builder.Default\n    private final Class<? extends RowHeadWrite> rowHeadWrite = DefaultRowHeadWrite.class;\n\n    @Builder.Default\n    private final Class<? extends RowFootWrite> rowFootWrite = DefaultRowFootWrite.class;\n\n    @Builder.Default\n    private final Class<? extends RowTitleRead> rowTitleRead = DefaultRowTitleRead.class;\n\n    @Builder.Default\n    private final Class<? extends RowHeadRead> rowHeadRead = DefaultRowHeadRead.class;\n\n    @Builder.Default\n    private final Class<? extends RowFootRead> rowFootRead = DefaultRowFootRead.class;\n\n    @Builder.Default\n    private final String titleFormat = \"@\";\n\n    @Builder.Default\n    private final ExcelStyleConfig titleStyle = ExcelStyleConfig.getDefaultExcelStyleConfigTitle();\n\n    @Builder.Default\n    private final Class<? extends RowStyleRead> rowStyleRead = DefaultRowStyleRead.class;\n    @Builder.Default\n    private final List<ExcelFieldConfig> itemList = Collections.emptyList();\n    @Builder.Default\n    private Boolean autoSizeColumn = false;\n\n    public static ExcelClassConfig getDefaultExcelClassConfig(List<ExcelFieldConfig> itemList) {\n        return ExcelClassConfig.builder()\n                .itemList(itemList)\n                .build();\n    }\n\n    public static ExcelClassConfig buildByExcelClass(ExcelClass excelClass, List<ExcelFieldConfig> excelFieldConfigList) {\n        return ExcelClassConfig.builder()\n                .rowTitleWrite(excelClass.rowTitleWrite())\n                .rowHeadWrite(excelClass.rowHeadWrite())\n                .rowFootWrite(excelClass.rowFootWrite())\n                .rowTitleRead(excelClass.rowTitleRead())\n                .rowHeadRead(excelClass.rowHeadRead())\n                .rowFootRead(excelClass.rowFootRead())\n                .titleStyle(ExcelStyleConfig.buildByExcelStyle(excelClass.titleStyle()))\n                .rowStyleRead(excelClass.rowStyleRead())\n                .titleFormat(excelClass.titleFormat())\n                .autoSizeColumn(excelClass.autoSizeColumn())\n                .itemList(excelFieldConfigList)\n                .build();\n    }\n}\n"
    },
    {
        "detailed_description": "The public class BigIntegerStringHandler is a specialized class that extends the AbstractBigIntegerCellHandler class. This class is designed to handle BigInteger values in the context of Excel cells. It overrides two methods from its superclass.\n\nThe first overridden method is setCellValue. This method is designed to set the value of a cell in an Excel row. It takes four parameters: a RowContext object, an ExcelFieldConfig object, a Cell object, and a BigInteger value. The method first retrieves the Java format for the Excel field configuration using the getJavaFormat method. It then formats the BigInteger value according to this format using the ExcelNumberUtils.format method. Finally, it sets the cell's value to the formatted string.\n\nThe second overridden method is getExcelType. This method returns the ExcelType of the cell, which in this case is always ExcelType.STRING. This indicates that the BigInteger values are being handled as strings within the Excel cells.\"",
        "sketchy_description": "The public class BigIntegerStringHandler, which extends the AbstractBigIntegerCellHandler, is specifically designed to handle the conversion of BigInteger values into a String format suitable for display in Excel cells. This functionality is particularly important when dealing with large integer values that need to be accurately represented within the constraints of an Excel spreadsheet.\n\nThe class provides a protected method setCellValue, which takes a RowContext, an ExcelFieldConfig, a Cell, and a BigInteger value as parameters. This method is responsible for setting the value of an Excel cell to the string representation of the BigInteger value, ensuring that the data is formatted correctly for the spreadsheet environment.\n\nAdditionally, the class includes a public method getExcelType, which returns an ExcelType enumeration value. This value corresponds to the String type, indicating that the handler is associated with string representations of data within Excel. This method is crucial for the system to understand the type of data being processed and to handle it appropriately within the context of Excel operations.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/biginteger/BigIntegerStringHandler.java",
        "class_name": "BigIntegerStringHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "BigIntegerStringHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/BigIntegerStringHandlerTest.java"
        },
        "task_id": 109,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.biginteger;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport io.github.zouzhiy.excel.utils.ExcelNumberUtils;\nimport org.apache.poi.ss.usermodel.Cell;\n\nimport java.math.BigInteger;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class BigIntegerStringHandler extends AbstractBigIntegerCellHandler {\n\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, BigInteger value) {\n        String javaFormat = this.getJavaFormat(excelFieldConfig);\n        String strValue = ExcelNumberUtils.format(value, javaFormat);\n        cell.setCellValue(strValue);\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.STRING;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class InputStreamPdfSource is a subclass of the AbstractPdfBoxSource class, which is parameterized with InputStream. This class is designed to handle PDF sources that come from an InputStream. The constructor for this class takes an InputStream object as an argument and passes it to the superclass constructor. This class overrides the doLoad method from the superclass. The doLoad method is designed to load the PDF document from the InputStream source. It returns a PDDocument object, which represents a PDF document. This method can throw an IOException if there is a problem reading the InputStream. This class is useful for handling PDF files that are not stored as files on disk but are instead received from a network connection or other sources.\"",
        "sketchy_description": "The public class InputStreamPdfSource, which extends the AbstractPdfBoxSource class parameterized with InputStream, is designed to represent a source of a PDF document that is read from an InputStream. This is particularly useful when dealing with PDF data that is not stored in a file but is instead received through a stream, such as from a network connection or an in-memory representation.\n\nThe constructor for this class takes a single argument of type InputStream, which represents the source of the PDF data. The purpose of the constructor is to initialize a new InputStreamPdfSource object with the provided InputStream, thereby setting up the object to be ready to load the PDF content from the stream.\n\nOnce the object has been initialized, it provides a protected method named doLoad, which is responsible for actually loading the PDF document from the InputStream source. This method returns a PDDocument, which is a representation of the PDF document within the PDFBox library. The doLoad method may throw an IOException, which is a signal to the caller that an input or output operation has failed or been interrupted, and proper error handling should be implemented when invoking this method.",
        "file": "imglib/pipe/src/main/java/cn/pipe/in/pdf/InputStreamPdfSource.java",
        "class_name": "InputStreamPdfSource",
        "repo_metadata": {
            "repo_name": "imglib"
        },
        "evaluation_metadata": {
            "test_class_name": "InputStreamPdfSourceTest",
            "test_file": "imglib/pipe/src/test/java/cn/pipe/in/pdf/InputStreamPdfSourceTest.java"
        },
        "task_id": 110,
        "ground_truth_class_body": "package cn.pipe.in.pdf;\n\nimport cn.pipe.in.AbstractPdfBoxSource;\nimport org.apache.pdfbox.pdmodel.PDDocument;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * A pdf source that from input stream.\n *\n * @author tracy\n * @since 0.2.1\n */\npublic class InputStreamPdfSource extends AbstractPdfBoxSource<InputStream> {\n\n    public InputStreamPdfSource(InputStream source) {\n        super(source);\n    }\n\n    @Override\n    protected PDDocument doLoad() throws IOException {\n        return PDDocument.load(source);\n    }\n}\n"
    },
    {
        "detailed_description": "The public class BigIntegerNumberHandler is a subclass of the AbstractBigIntegerCellHandler class. This class is designed to handle BigInteger values in Excel cells. It overrides two methods from its superclass. The first method, setCellValue, is responsible for setting the value of a cell in an Excel row. It takes four parameters: a RowContext object, an ExcelFieldConfig object, a Cell object, and a BigInteger value. The BigInteger value is converted to a double value before being set as the cell's value. The second method, getExcelType, returns the type of Excel cell that this handler is designed to work with. In this case, it returns ExcelType.NUMERIC, indicating that this handler is designed to work with numeric cells in Excel.\"",
        "sketchy_description": "The public class BigIntegerNumberHandler, which extends AbstractBigIntegerCellHandler, is designed to handle the setting of BigInteger values in Excel cells. This class is specifically tailored to work with Excel spreadsheets and provides functionality to manage cells that contain large integer values that are beyond the range of standard integer types.\n\nThe class includes a protected method setCellValue, which takes a RowContext, an ExcelFieldConfig, a Cell, and a BigInteger as parameters. This method is responsible for setting the value of a cell in an Excel sheet to the double representation of a BigInteger value. This is particularly useful when dealing with large numbers that need to be accurately represented in an Excel document.\n\nAdditionally, the class provides a public method getExcelType, which returns the ExcelType for the cells that this handler is responsible for. In this case, the ExcelType returned is NUMERIC, indicating that the cells managed by this handler are expected to contain numeric values. This method is essential for ensuring that the cells are formatted and treated correctly within the Excel environment, particularly when it comes to performing calculations or applying formulas.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/biginteger/BigIntegerNumberHandler.java",
        "class_name": "BigIntegerNumberHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "BigIntegerNumberHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/BigIntegerNumberHandlerTest.java"
        },
        "task_id": 111,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.biginteger;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport org.apache.poi.ss.usermodel.Cell;\n\nimport java.math.BigInteger;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class BigIntegerNumberHandler extends AbstractBigIntegerCellHandler {\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, BigInteger value) {\n        cell.setCellValue(value.doubleValue());\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.NUMERIC;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class BooleanBooleanHandler is a subclass of the AbstractBooleanCellHandler class. This class is designed to handle boolean values in Excel cells. It overrides two methods from its superclass. The first method, setCellValue, is responsible for setting the value of a cell in an Excel row. It takes four parameters: a RowContext object that represents the context of the row in which the cell is located, an ExcelFieldConfig object that contains configuration information for the Excel field, a Cell object that represents the cell itself, and a Boolean value that is the value to be set in the cell. The method then calls the setCellValue method on the Cell object, passing the Boolean value as an argument. The second method, getExcelType, is a simple getter method that returns an enumeration value representing the type of Excel data that this handler is designed to work with, in this case, BOOLEAN.\"",
        "sketchy_description": "The public class BooleanBooleanHandler, which extends the AbstractBooleanCellHandler, is specifically designed to manage and manipulate boolean cell values within an Excel sheet. This class provides a method to set the value of a cell to a boolean value, which is essential when dealing with boolean data types in Excel documents. The method setCellValue takes a RowContext, an ExcelFieldConfig, a Cell, and a Boolean value as parameters. It is a protected method, meaning it is intended to be accessed within the class itself or by subclasses, and it is responsible for assigning the specified boolean value to the cell in the given row context. Additionally, the class offers a public method getExcelType that returns the ExcelType for the handler. In this case, the ExcelType is BOOLEAN, indicating that this handler deals with boolean values in Excel. This method is crucial for ensuring that the data is correctly identified and processed as a boolean type within the Excel framework.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/booleans/BooleanBooleanHandler.java",
        "class_name": "BooleanBooleanHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "BooleanBooleanHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/BooleanBooleanHandlerTest.java"
        },
        "task_id": 112,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.booleans;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport org.apache.poi.ss.usermodel.Cell;\n\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class BooleanBooleanHandler extends AbstractBooleanCellHandler {\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, Boolean value) {\n        cell.setCellValue(value);\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.BOOLEAN;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class ByteStringHandler is a subclass of the AbstractByteCellHandler class. This class is designed to handle byte strings in the context of Excel cells. It overrides two methods from its superclass. \n\nThe first overridden method is setCellValue. This method is designed to set the value of a cell in an Excel row. It takes four parameters: a RowContext object, an ExcelFieldConfig object, a Cell object, and a Byte value. The method first retrieves the Java format for the Excel field configuration using the getJavaFormat method. It then formats the Byte value according to this format using the ExcelNumberUtils.format method. The resulting string is then set as the value of the cell using the setCellValue method of the Cell object.\n\nThe second overridden method is getExcelType. This method returns the ExcelType of the ByteStringHandler, which is ExcelType.STRING. This indicates that the ByteStringHandler is designed to handle string data in Excel.\"",
        "sketchy_description": "The public class ByteStringHandler, which extends the AbstractByteCellHandler, is designed to handle the conversion of byte values to string values specifically for cells within an Excel spreadsheet. This functionality is particularly useful when dealing with data that needs to be formatted and displayed as strings in an Excel document.\n\nThe class provides a protected method setCellValue, which takes a RowContext, an ExcelFieldConfig, a Cell, and a Byte as parameters. This method is responsible for setting the value of a cell as a string. It does so by formatting the given byte value according to the rules and configurations specified in the ExcelFieldConfig parameter. This allows for a flexible and dynamic approach to cell value setting, accommodating various formatting needs.\n\nAdditionally, the class offers a public method getExcelType, which returns the ExcelType.STRING. This indicates that the handler is specifically dealing with string values within Excel cells. This method is useful for identifying the type of data the handler is expected to process and can be used to ensure that the handler is used in the correct context within the broader Excel data processing framework.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/bytes/ByteStringHandler.java",
        "class_name": "ByteStringHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "ByteStringHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/ByteStringHandlerTest.java"
        },
        "task_id": 113,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.bytes;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport io.github.zouzhiy.excel.utils.ExcelNumberUtils;\nimport org.apache.poi.ss.usermodel.Cell;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class ByteStringHandler extends AbstractByteCellHandler {\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, Byte value) {\n        String javaFormat = this.getJavaFormat(excelFieldConfig);\n        String strValue = ExcelNumberUtils.format(value, javaFormat);\n        cell.setCellValue(strValue);\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.STRING;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class BigIntegerNumberHandler is a subclass of the AbstractBigIntegerCellHandler class. This class is designed to handle BigInteger values in Excel cells. It overrides two methods from its superclass. The first method, setCellValue, is responsible for setting the value of a cell in an Excel row. It takes four parameters: a RowContext object that represents the current row, an ExcelFieldConfig object that contains configuration information for the Excel field, a Cell object that represents the cell to be modified, and a BigInteger value that is the value to be set in the cell. The method converts the BigInteger value to a double and sets this as the value of the cell. The second method, getExcelType, returns the type of the Excel cell. In this case, it returns ExcelType.NUMERIC, indicating that the cell contains a numeric value.\"",
        "sketchy_description": "The public class BigIntegerNumberHandler, which extends AbstractBigIntegerCellHandler, is designed to handle the insertion of BigInteger values into cells within an Excel spreadsheet. This class provides a method that allows for the setting of cell values based on BigInteger inputs, which is particularly useful when dealing with large numbers that exceed the standard numeric types supported by Excel.\n\nThe protected method setCellValue takes four parameters: RowContext, ExcelFieldConfig, Cell, and BigInteger. It is responsible for converting the BigInteger value into a double and then setting this value into the specified cell within an Excel sheet. This method ensures that the BigInteger values are properly formatted and inserted into the spreadsheet.\n\nAdditionally, the public method getExcelType returns an ExcelType enumeration value that indicates the numeric type that corresponds to the data being handled by this class. This method is useful for determining the type of data that the BigIntegerNumberHandler is capable of processing and for ensuring that the data is compatible with Excel's cell formatting options.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/biginteger/BigIntegerNumberHandler.java",
        "class_name": "IntegerNumberHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "IntegerNumberHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/BigIntegerNumberHandlerTest.java"
        },
        "task_id": 114,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.biginteger;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport org.apache.poi.ss.usermodel.Cell;\n\nimport java.math.BigInteger;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class BigIntegerNumberHandler extends AbstractBigIntegerCellHandler {\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, BigInteger value) {\n        cell.setCellValue(value.doubleValue());\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.NUMERIC;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class BigIntegerBooleanHandler is a subclass of the AbstractBigIntegerCellHandler class. This class is designed to handle BigInteger values in the context of Excel cells, specifically for boolean values. It contains a private static final BigInteger member, TRUE_VALUE, which is set to BigInteger.ONE, representing the boolean value of true in the context of BigInteger. \n\nThe class overrides two methods from its superclass. The first method, setCellValue, takes four parameters: a RowContext object, an ExcelFieldConfig object, a Cell object, and a BigInteger value. This method sets the value of the cell to true if the BigInteger value is equal to TRUE_VALUE (i.e., BigInteger.ONE), and false otherwise. This is determined by comparing the BigInteger value to TRUE_VALUE using the compareTo method, which returns 0 if the two values are equal. \n\nThe second overridden method, getExcelType, returns the ExcelType of the cell, which in this case is BOOLEAN. This method does not take any parameters and is used to indicate the type of data that the cell contains.\"",
        "sketchy_description": "The public class BigIntegerBooleanHandler, which extends the AbstractBigIntegerCellHandler, is designed to handle the conversion of BigInteger values to boolean values specifically for Excel cells. This class is particularly useful when dealing with Excel spreadsheets that require a representation of boolean values as BigInteger objects. The class defines a constant TRUE_VALUE which is set to BigInteger.ONE, indicating the value that will be considered as 'true' in the context of this handler.\n\nThe class provides a protected method setCellValue, which takes a RowContext, an ExcelFieldConfig, a Cell, and a BigInteger value as parameters. This method is responsible for setting the cell's value within an Excel spreadsheet. If the BigInteger value passed to the method is equal to the predefined TRUE_VALUE, the cell's value is set to true; otherwise, it is set to false. This method ensures that BigInteger values are correctly interpreted as boolean values when populating Excel cells.\n\nAdditionally, the class includes a public method getExcelType, which returns the ExcelType for the handler. In this case, the ExcelType returned is BOOLEAN, indicating that this handler deals with boolean values within Excel. This method is useful for integrating with systems that need to understand the type of data the handler is managing, ensuring that the correct data type is used when processing Excel cells.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/biginteger/BigIntegerBooleanHandler.java",
        "class_name": "BigIntegerBooleanHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "BigIntegerBooleanHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/BigIntegerBooleanHandlerTest.java"
        },
        "task_id": 115,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.biginteger;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport org.apache.poi.ss.usermodel.Cell;\n\nimport java.math.BigInteger;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class BigIntegerBooleanHandler extends AbstractBigIntegerCellHandler {\n\n    private final static BigInteger TRUE_VALUE = BigInteger.ONE;\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, BigInteger value) {\n        cell.setCellValue(value.compareTo(TRUE_VALUE) == 0);\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.BOOLEAN;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class CellResult is designed to represent the result of a cell in an Excel spreadsheet. It contains several private fields, including a Cell object, row and column indices, rowspan and colspan for merged cells, an ExcelType enum to represent the type of data in the cell, and fields for string, number, boolean, and date values. It also contains flags to indicate whether these values have been calculated yet.\n\nThe constructor for this class takes a Cell object, a CellSpan object, an ExcelType enum, and values and flags for string, number, boolean, and date values. It initializes the object with these values.\n\nThe class also contains several static methods to create CellResult objects for different types of cells, including none (for null cells), blank (for cells with no value), and valueOf (for cells with numeric, boolean, or string values).\n\nThe class also contains several getter methods to retrieve the values of the fields. These methods check whether the value has been calculated yet, and if not, they call a private method to recalculate the value.\n\nThe class also contains several methods to check whether the cell is blank or null, and to recalculate the string, number, boolean, and date values if necessary. These methods use a switch statement to handle different types of data in the cell.\"",
        "sketchy_description": "The public class CellResult is designed to encapsulate the value of a cell within an Excel sheet, providing support for merged cells and handling various data types such as strings, numbers, booleans, and dates. The class includes a set of static final variables representing the boolean values as BigDecimal objects for consistency in calculations.\n\nThe constructor of the CellResult class takes multiple parameters, including a Cell object, a CellSpan object, an ExcelType enumeration, and flags and values for each data type supported. This constructor is responsible for initializing a CellResult instance with all the necessary information about the cell's value and its state.\n\nThe class provides several static factory methods, such as none(), blank(), and valueOf(), each designed to create a CellResult object representing different states or types of cell values, such as non-existent, blank, numeric, boolean, or string values.\n\nAdditionally, the class offers methods to determine if a cell is blank or non-existent, as well as methods to retrieve the cell's value in its respective data type, either directly or by converting it as necessary. The getStringValue(), getNumberValue(), getBooleanValue(), and getDateValue() methods provide access to the cell's value, while the private recalculate methods are used internally to convert and recalculate the cell's value based on its type and, in the case of dates, a provided format string.\n\nThese methods and the class structure allow for a robust representation of cell values in an Excel sheet, facilitating the manipulation and retrieval of data within Excel-related applications or libraries.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/metadata/result/CellResult.java",
        "class_name": "CellResult",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "CellResultTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/metadata/result/CellResultTest.java"
        },
        "task_id": 116,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.metadata.result;\n\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.exceptions.ExcelException;\nimport io.github.zouzhiy.excel.metadata.CellSpan;\nimport io.github.zouzhiy.excel.utils.ExcelDateParseUtils;\nimport lombok.EqualsAndHashCode;\nimport lombok.Getter;\nimport lombok.ToString;\nimport org.apache.poi.ss.usermodel.Cell;\n\nimport java.math.BigDecimal;\nimport java.time.LocalDateTime;\n\n/**\n * \u5355\u4e2a\u5355\u5143\u683c\u503c\u8bfb\u53d6\u7ed3\u679c\n *\n * @author zouzhiy\n * @since 2022/7/2\n */\n@ToString\n@EqualsAndHashCode\npublic class CellResult {\n\n    private final static BigDecimal TRUE_VALUE_BIG_DECIMAL = BigDecimal.ONE;\n    private final static BigDecimal FALSE_VALUE_BIG_DECIMAL = BigDecimal.ZERO;\n    /**\n     * \u5bf9\u5e94\u7684\u5355\u5143\u683c\n     */\n    @Getter\n    private final Cell cell;\n    /**\n     * \u6240\u5728\u884c\n     */\n    @Getter\n    private final Integer rowIndex;\n    /**\n     * \u6240\u5728\u5217\n     */\n    @Getter\n    private final Integer columnIndex;\n    /**\n     * \u7eb5\u5411\u8de8\u7684\u884c\u6570\u3002\u5408\u5e76\u5355\u5143\u683c\u65f6\uff0c\u503c\u53ef\u80fd\u5927\u4e8e1\n     */\n    @Getter\n    private final Integer rowspan;\n    /**\n     * \u6a2a\u5411\u8de8\u7684\u5217\u6570\u3002\u5408\u5e76\u5355\u5143\u683c\u65f6\uff0c\u503c\u53ef\u80fd\u5927\u4e8e1\n     */\n    @Getter\n    private final Integer colspan;\n    /**\n     * \u5355\u5143\u683c\u7c7b\u578b\n     */\n    @Getter\n    private final ExcelType excelType;\n    /**\n     * \u6587\u672c\u503c\n     */\n    private String stringValue;\n    /**\n     * \u662f\u5426\u5df2\u8ba1\u7b97\u8fc7stringValue\n     * \u5f53\u5355\u5143\u683c\u7c7b\u578b\u4e0d\u662f{@link ExcelType#STRING}\uff0c\u9700\u8981\u8f6c\u6362\n     */\n    private boolean stringValueFlag;\n    /**\n     * \u6570\u503c\n     */\n    private BigDecimal numberValue;\n    /**\n     * \u662f\u5426\u5df2\u8ba1\u7b97\u8fc7numberValue\n     * \u5f53\u5355\u5143\u683c\u7c7b\u578b\u4e0d\u662f{@link ExcelType#NUMERIC}\uff0c\u9700\u8981\u8f6c\u6362\n     */\n    private boolean numberValueFlag;\n    /**\n     * \u5e03\u5c14\u503c\n     */\n    private Boolean booleanValue;\n    /**\n     * \u662f\u5426\u5df2\u8ba1\u7b97\u8fc7booleanValue\n     * \u5f53\u5355\u5143\u683c\u7c7b\u578b\u4e0d\u662f{@link ExcelType#BOOLEAN}\uff0c\u9700\u8981\u8f6c\u6362\n     */\n    private boolean booleanValueFlag;\n    /**\n     * \u65e5\u671f\n     */\n    private LocalDateTime dateValue;\n    /**\n     * \u662f\u5426\u5df2\u8ba1\u7b97\u8fc7booleanValue\n     * \u65e5\u671f\u53ef\u4ecenumberValue\u6216\u8005StringValue\u8f6c\u6362\u800c\u6765\n     */\n    private boolean dateValueFlag;\n\n    public CellResult(Cell cell, CellSpan cellSpan, ExcelType excelType\n            , String stringValue, boolean stringValueFlag\n            , BigDecimal numberValue, boolean numberValueFlag\n            , Boolean booleanValue, boolean booleanValueFlag\n            , LocalDateTime dateValue, boolean dateValueFlag) {\n        this.cell = cell;\n        this.rowIndex = cell == null ? -1 : cell.getRowIndex();\n        this.columnIndex = cell == null ? -1 : cell.getColumnIndex();\n        this.rowspan = cellSpan.getRowspan();\n        this.colspan = cellSpan.getColspan();\n        this.excelType = excelType;\n        this.stringValue = stringValue;\n        this.stringValueFlag = stringValueFlag;\n        this.numberValue = numberValue;\n        this.numberValueFlag = numberValueFlag;\n        this.booleanValue = booleanValue;\n        this.booleanValueFlag = booleanValueFlag;\n        this.dateValue = dateValue;\n        this.dateValueFlag = dateValueFlag;\n    }\n\n    /**\n     * \u5355\u5143\u683c\u4e3a\u7a7a\n     *\n     * @return NULL\u7684CellResult\n     */\n    public static CellResult none() {\n        return new CellResult(null, CellSpan.NONE_CELL_SPAN, ExcelType.NONE\n                , null, true\n                , null, true\n                , null, true\n                , null, true);\n    }\n\n    /**\n     * {@link org.apache.poi.ss.usermodel.CellType#BLANK}\n     * \u5355\u5143\u683c\u4e0d\u4e3a\u7a7a\uff0c\u4f46\u662f\u5355\u5143\u683c\u503c\u4e3a\u7a7a\n     *\n     * @param cell     \u5355\u5143\u683c\n     * @param cellSpan \u5408\u5e76\u4fe1\u606f\n     * @return CellResult\u7684\u503c\u90fd\u4e3anull\n     */\n    public static CellResult blank(Cell cell, CellSpan cellSpan) {\n        return new CellResult(cell, cellSpan, ExcelType.BLANK\n                , null, true\n                , null, true\n                , null, true\n                , null, true);\n\n    }\n\n    /**\n     * \u6570\u503c\u578b {@link org.apache.poi.ss.usermodel.CellType#NUMERIC}\n     *\n     * @param cell        \u5355\u5143\u683c\n     * @param cellSpan    \u5408\u5e76\u4fe1\u606f\n     * @param numberValue \u5355\u5143\u683c\u503c\uff0c\u4e3a\u6570\u503c\u7c7b\u578b\n     * @return \u5355\u5143\u683c\u503c\n     */\n    public static CellResult valueOf(Cell cell, CellSpan cellSpan, double numberValue) {\n        return new CellResult(cell, cellSpan, ExcelType.NUMERIC\n                , null, false\n                , BigDecimal.valueOf(numberValue), true\n                , null, false\n                , null, false);\n    }\n\n    /**\n     * \u5e03\u5c14\u578b {@link org.apache.poi.ss.usermodel.CellType#BOOLEAN}\n     *\n     * @param cell         \u5355\u5143\u683c\n     * @param cellSpan     \u5408\u5e76\u4fe1\u606f\n     * @param booleanValue \u5355\u5143\u683c\u503c\uff0c\n     * @return \u5355\u5143\u683c\u503c\n     */\n    public static CellResult valueOf(Cell cell, CellSpan cellSpan, boolean booleanValue) {\n        return new CellResult(cell, cellSpan, ExcelType.BOOLEAN\n                , null, false\n                , null, false\n                , booleanValue, true\n                , null, false);\n    }\n\n    /**\n     * \u6587\u672c\u578b {@link org.apache.poi.ss.usermodel.CellType#BOOLEAN}\n     *\n     * @param cell        \u5355\u5143\u683c\n     * @param cellSpan    \u5408\u5e76\u4fe1\u606f\n     * @param stringValue \u5355\u5143\u683c\u503c\uff0c\n     * @return \u5355\u5143\u683c\u503c\n     */\n    public static CellResult valueOf(Cell cell, CellSpan cellSpan, String stringValue) {\n        return new CellResult(cell, cellSpan, ExcelType.STRING\n                , stringValue, true\n                , null, false\n                , null, false\n                , null, false);\n    }\n\n    /**\n     * \u7a7a\u6570\u636e\n     *\n     * @return \u662f\u5426\u4e3a\u7a7a\u503c\n     */\n    public boolean isBlank() {\n        return excelType.equals(ExcelType.BLANK);\n    }\n\n    /**\n     * \u5355\u5143\u683c\u4e3a\u7a7a\n     * \u65e0\u6548\u6570\u636e\u3002\u4e00\u822c\u5c5e\u4e8e\u5408\u5e76\u5355\u5143\u683c\uff0c\u4f46\u662f\u4e0d\u662f\u7b2c\u4e00\u4e2a\u5355\u5143\u683c\u7684\u6570\u636e\u3002\u5373\u6b64\u6570\u636e\u65e0\u6548\n     *\n     * @return \u662f\u5426\u4e3anull\n     */\n    public boolean isNone() {\n        return excelType.equals(ExcelType.NONE);\n    }\n\n    /**\n     * \u83b7\u53d6\u5b57\u7b26\u578b\u503c\u3002\u82e5\u975e\u5b57\u7b26\u4e32\u578b\uff0c\u5219\u9700\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32\n     *\n     * @return \u5b57\u7b26\u4e32\u7ed3\u679c\n     */\n    public String getStringValue() {\n        if (!stringValueFlag) {\n            stringValue = this.recalculateStringValue();\n        }\n        return stringValue;\n    }\n\n    /**\n     * \u82e5\u975e\u6570\u503c\u578b\uff0c\u5219\u9700\u8f6c\u6362\n     *\n     * @return \u6570\u503c\u7ed3\u679c\n     */\n    public BigDecimal getNumberValue() {\n        if (!numberValueFlag) {\n            numberValue = this.recalculateNumberValue();\n        }\n        return numberValue;\n    }\n\n    /**\n     * \u82e5\u975e\u5e03\u5c14\u578b\uff0c\u5219\u9700\u8f6c\u6362\n     *\n     * @return \u5e03\u5c14\u503c\u7ed3\u679c\n     */\n    public Boolean getBooleanValue() {\n        if (!booleanValueFlag) {\n            booleanValue = this.recalculateBooleanValue();\n        }\n        return booleanValue;\n    }\n\n    /**\n     * \u65f6\u95f4\u7c7b\u578b\u3002\u9700\u8981\u4ece\u5355\u5143\u683c\u8bfb\u53d6\u6216\u8005\u5b57\u7b26\u4e32\u8f6c\u6362\u800c\u6765\n     *\n     * @return \u65f6\u95f4\u7ed3\u679c\n     */\n    public LocalDateTime getDateValue(String format) {\n        if (!dateValueFlag) {\n            dateValue = this.recalculateDateValue(format);\n        }\n        return dateValue;\n    }\n\n    /**\n     * \u5b57\u7b26\u4e32\u8f6c\u6362\n     *\n     * @return \u7ed3\u679c\n     */\n    private String recalculateStringValue() {\n        String str;\n        switch (excelType) {\n            case NUMERIC:\n                str = numberValue.toString();\n                break;\n            case BOOLEAN:\n                str = Boolean.toString(booleanValue);\n                break;\n            default:\n                str = null;\n                break;\n        }\n        stringValueFlag = true;\n        return str;\n    }\n\n    /**\n     * \u6570\u503c\u8f6c\u6362\n     *\n     * @return \u7ed3\u679c\n     */\n    private BigDecimal recalculateNumberValue() {\n        BigDecimal bigDecimal;\n        switch (excelType) {\n            case STRING:\n                try {\n                    bigDecimal = stringValue.trim().length() == 0 ? null : new BigDecimal(stringValue);\n                } catch (NumberFormatException e) {\n                    throw new ExcelException(e, \"\u975e\u6570\u5b57\u5b57\u7b26\uff1a%s\", stringValue);\n                }\n                break;\n            case BOOLEAN:\n                bigDecimal = booleanValue ? TRUE_VALUE_BIG_DECIMAL : FALSE_VALUE_BIG_DECIMAL;\n                break;\n            default:\n                bigDecimal = null;\n                break;\n        }\n        numberValueFlag = true;\n        return bigDecimal;\n    }\n\n    /**\n     * \u5e03\u5c14\u503c\u8f6c\u6362\n     *\n     * @return \u7ed3\u679c\n     */\n    private Boolean recalculateBooleanValue() {\n        Boolean booleanValue;\n        switch (excelType) {\n            case NUMERIC:\n                booleanValue = TRUE_VALUE_BIG_DECIMAL.compareTo(numberValue) == 0;\n                break;\n            case STRING:\n                booleanValue = Boolean.valueOf(stringValue);\n                break;\n            default:\n                booleanValue = null;\n                break;\n        }\n        booleanValueFlag = true;\n        return booleanValue;\n    }\n\n    /**\n     * \u65e5\u671f\u8f6c\u6362\n     *\n     * @param format \u65e5\u671f\u8f6c\u6362pattern,\u53ef\u4ee5\u4e3anull,\u4e3a\u7a7a\u5b57\u7b26\u4e32\u3002\u5916\u90e8\u914d\u7f6e\u4f20\u5165\n     * @return \u7ed3\u679c\n     */\n    private LocalDateTime recalculateDateValue(String format) {\n        LocalDateTime localDateTime;\n        switch (excelType) {\n            case NUMERIC:\n                localDateTime = cell.getLocalDateTimeCellValue();\n                break;\n            case STRING:\n                localDateTime = ExcelDateParseUtils.parseDateTime(stringValue, format);\n                break;\n            default:\n                localDateTime = null;\n                break;\n        }\n        dateValueFlag = true;\n        return localDateTime;\n    }\n}\n"
    },
    {
        "detailed_description": "The public final class CollectionUtils is a utility class that provides static methods for handling collections and arrays. This class is marked as final, which means it cannot be subclassed. The private constructor ensures that this class cannot be instantiated, reinforcing its role as a utility class.\n\nThe class provides two overloaded isNullOrEmpty methods, one for collections and one for arrays. These methods return true if the collection or array is null or empty, and false otherwise. These methods are useful for checking the state of a collection or array before performing operations that require them to contain elements.\n\nThe class also provides three overloaded excEmpty methods, one for collections, one for arrays, and one for iterables. These methods throw an InvalidSettingException if the collection, array, or iterable is empty. The exception message is provided as a parameter to these methods. These methods are useful for enforcing requirements that collections, arrays, or iterables contain elements.\n\nThe author of this class is Tracy, and it has been available since version 0.2.1 of the software.\"",
        "sketchy_description": "The public final class CollectionUtils is a utility class that provides a collection of static methods for performing various operations related to collections, arrays, and iterables. The class is marked as final to prevent subclassing, and it features a private constructor to prevent instantiation, as utility classes are not meant to be instantiated but rather to provide a set of static methods that can be called directly.\n\nThe static method `isNullOrEmpty(Collection<?> col)` checks whether a given collection is null or empty. It returns a boolean value: `true` if the collection is null or has no elements, and `false` otherwise. This method is useful for validating collections before performing operations that require them to have elements.\n\nSimilarly, the method `isNullOrEmpty(Object[] os)` performs the same check for arrays. It takes an array of objects as an argument and returns `true` if the array is null or contains no elements.\n\nThe `excEmpty(Collection<?> col, String msg)` method is designed to throw an exception if the provided collection is empty. It takes a collection and a custom message string as arguments. If the collection is empty, it throws an IllegalArgumentException with the provided message, allowing for more informative error handling.\n\nThe method `excEmpty(Object[] os, String msg)` serves the same purpose for arrays. It throws an IllegalArgumentException with a custom message if the array passed to it is empty.\n\nLastly, the `excEmpty(Iterable<?> is, String msg)` method checks if an iterable is empty and throws an IllegalArgumentException with a custom message if it is. This allows for consistent error handling across different types of iterable data structures.\n\nThese methods are particularly useful for developers who need to ensure that collections, arrays, or iterables are not empty before proceeding with further logic, providing a convenient way to validate and handle potential issues early in the execution flow.",
        "file": "imglib/core/src/main/java/cn/core/utils/CollectionUtils.java",
        "class_name": "CollectionUtils",
        "repo_metadata": {
            "repo_name": "imglib"
        },
        "evaluation_metadata": {
            "test_class_name": "CollectionUtilsTest",
            "test_file": "imglib/core/src/test/java/cn/core/utils/CollectionUtilsTest.java"
        },
        "task_id": 117,
        "ground_truth_class_body": "package cn.core.utils;\n\nimport cn.core.ex.InvalidSettingException;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n/**\n * An util class for collection.\n *\n * @author tracy\n * @since 0.2.1\n */\npublic final class CollectionUtils {\n    private CollectionUtils(){}\n\n    public static boolean isNullOrEmpty(Collection<?> col) {\n        return col == null || col.isEmpty();\n    }\n\n    public static boolean isNullOrEmpty(Object[] os) {\n        return os == null || os.length == 0;\n    }\n\n    public static void excEmpty(Collection<?> col, String msg) {\n        if (col.isEmpty()) {\n            throw new InvalidSettingException(msg);\n        }\n    }\n\n    public static void excEmpty(Object[] os, String msg) {\n        if (os.length == 0) {\n            throw new InvalidSettingException(msg);\n        }\n    }\n\n    public static void excEmpty(Iterable<?> is, String msg) {\n        Iterator<?> ite = is.iterator();\n        if (!ite.hasNext()) {\n            throw new InvalidSettingException(msg);\n        }\n    }\n\n}\n"
    },
    {
        "detailed_description": "The public class LocalTimeDateHandler is a subclass of the AbstractLocalTimeCellHandler class. This class is designed to handle the conversion of local time data into a format that can be used in an Excel spreadsheet. \n\nThe setCellValue method is overridden from the superclass and is responsible for setting the value of a cell in an Excel spreadsheet. It takes four arguments: a RowContext object, an ExcelFieldConfig object, a Cell object, and a LocalTime object. The method first converts the LocalTime object into a LocalDateTime object, with the date set to the day after the Unix epoch (1970-01-01). It then sets the hour, minute, second, and nanosecond of the LocalDateTime object to match those of the LocalTime object. Finally, it sets the value of the cell to the LocalDateTime object.\n\nThe getExcelType method is also overridden from the superclass and returns the ExcelType of the data, which in this case is DATE.\n\nThe getDefaultExcelFormat method is the third method that is overridden from the superclass. This method returns the default format for the Excel data, which is \"HH:mm:ss\". This format represents hours, minutes, and seconds, and is commonly used for time data.",
        "sketchy_description": "The public class LocalTimeDateHandler, which extends the AbstractLocalTimeCellHandler, is specialized in handling the conversion of LocalTime values, which represent time without a date, into a format suitable for Excel cells with date formatting. This class overrides several methods to provide this functionality.\n\nThe setCellValue method is overridden to take a RowContext, an ExcelFieldConfig, a Cell, and a LocalTime value as parameters. It is responsible for setting the cell's value to the corresponding LocalDateTime representation of the provided LocalTime value, ensuring that the time is correctly represented in the Excel cell according to the specified formatting rules.\n\nThe getExcelType method is also overridden and is used to retrieve the ExcelType enumeration value that corresponds to the date type. This method informs the system of the type of Excel cell that should be used to represent the LocalTime value.\n\nLastly, the getDefaultExcelFormat method is overridden to provide the default Excel format string for time representation, which is \"HH:mm:ss\". This string dictates how the time will be formatted within the Excel cell, ensuring consistency and readability for users who will be viewing the data in Excel.\n\nOverall, the LocalTimeDateHandler class provides a set of methods that are crucial for the accurate and user-friendly representation of time data within Excel spreadsheets.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/localtime/LocalTimeDateHandler.java",
        "class_name": "LocalTimeDateHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "LocalTimeDateHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/LocalTimeDateHandlerTest.java"
        },
        "task_id": 118,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.localtime;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport org.apache.poi.ss.usermodel.Cell;\nimport org.apache.poi.ss.usermodel.DateUtil;\n\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class LocalTimeDateHandler extends AbstractLocalTimeCellHandler {\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, LocalTime value) {\n        LocalDateTime localDateTime = DateUtil.getLocalDateTime(0)\n                .plusDays(1)\n                .withHour(value.getHour())\n                .withMinute(value.getMinute())\n                .withSecond(value.getSecond())\n                .withNano(value.getNano());\n        cell.setCellValue(localDateTime);\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.DATE;\n    }\n\n    @Override\n    public String getDefaultExcelFormat() {\n        return \"HH:mm:ss\";\n    }\n}\n"
    },
    {
        "detailed_description": "The public class PeriodicActionRunnable implements the Runnable interface, which means it is designed to be executed by a thread. The class contains a private static final Logger object, which is used to log information about the state of the class. It also contains a private final Action object, which represents the action to be performed periodically, and a private final long value, which represents the period of time between each execution of the action in milliseconds. A private volatile Thread object is also included, which is the thread that will execute the action.\n\nThe constructor for this class takes an Action object and an integer representing the keep alive period in seconds. It initializes the action and keepAlivePeriodInMilliseconds variables with these values, and creates a new Thread object with this Runnable.\n\nThe class provides a public start method, which starts the execution of the thread, and a public stop method, which interrupts the thread if it is alive, and then waits for it to die.\n\nThe run method, which is overridden from the Runnable interface, is where the periodic action is performed. It first checks if the current thread is the same as the thread that was created in the constructor. If it is, it then sleeps for the keep alive period, logs an informational message, and then calls the action. If an InterruptedException is thrown during the sleep, it simply returns. If an ActionException is thrown during the call to the action, it throws a new RuntimeException with a message indicating that an exception occurred while calling the action.\"",
        "sketchy_description": "The public class PeriodicActionRunnable is designed to encapsulate a periodic action that should be executed repeatedly at a fixed time interval, and it implements the Runnable interface to allow it to be run in a separate thread. This functionality is particularly useful for tasks that need to be performed regularly, such as monitoring, scheduled updates, or any repetitive background operation.\n\nThe class contains a static final Logger instance, which is used to log information related to the actions performed by instances of this class. This is a common practice in Java to facilitate debugging and monitoring of the application's behavior.\n\nThe class also defines instance variables including an Action object that represents the action to be performed periodically, a long value that specifies the keep-alive period in milliseconds, and a volatile Thread reference that will be used to run the action in a separate thread.\n\nThe constructor of the PeriodicActionRunnable class takes an Action object and an integer representing the keep-alive period in seconds. It initializes the instance with the specified action and converts the keep-alive period into milliseconds for internal use.\n\nThe start method is responsible for initiating the periodic action. It does this by creating a new Thread with the current instance as its target and then starting that thread. This allows the periodic action to run concurrently with other processes without blocking the main application flow.\n\nThe run method contains the logic to execute the action periodically. It uses a loop that continues to execute the action at the specified interval, as long as the thread has not been interrupted. If the thread is interrupted, the method will catch the InterruptedException and exit the loop, effectively stopping the periodic execution.\n\nFinally, the stop method is used to terminate the periodic action. It interrupts the thread that is running the action, which should cause the run method to exit its loop. The method then waits for the thread to terminate, ensuring that the action is no longer being executed before the method returns.\n\nIn summary, the PeriodicActionRunnable class provides a structured way to manage periodic actions in a Java application, with methods to start, execute, and stop the action as needed.",
        "file": "sleeper/java/common-job/src/main/java/sleeper/job/common/action/thread/PeriodicActionRunnable.java",
        "class_name": "PeriodicActionRunnable",
        "repo_metadata": {
            "repo_name": "sleeper"
        },
        "evaluation_metadata": {
            "test_class_name": "PeriodicActionRunnableTest",
            "test_file": "sleeper/java/common-job/src/test/java/sleeper/job/common/action/thread/PeriodicActionRunnableTest.java"
        },
        "task_id": 119,
        "ground_truth_class_body": "/*\n * Copyright 2022-2023 Crown Copyright\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage sleeper.job.common.action.thread;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport sleeper.job.common.action.Action;\nimport sleeper.job.common.action.ActionException;\n\n/**\n * A {@link Runnable} that calls an {@link Action} every N seconds, sleeping\n * in between calls.\n */\npublic class PeriodicActionRunnable implements Runnable {\n    private static final Logger LOGGER = LoggerFactory.getLogger(PeriodicActionRunnable.class);\n\n    private final Action action;\n    private final long keepAlivePeriodInMilliseconds;\n    private volatile Thread thread;\n\n    public PeriodicActionRunnable(Action action, int keepAlivePeriodInSeconds) {\n        this.action = action;\n        this.keepAlivePeriodInMilliseconds = keepAlivePeriodInSeconds * 1000L;\n        this.thread = new Thread(this);\n    }\n\n    public void start() {\n        thread.start();\n    }\n\n    @Override\n    public void run() {\n        Thread thisThread = Thread.currentThread();\n\n        while (thisThread == thread) {\n            try {\n                LOGGER.info(\"PeriodicActionRunnable is sleeping for {} milliseconds\", keepAlivePeriodInMilliseconds);\n                Thread.sleep(keepAlivePeriodInMilliseconds);\n            } catch (InterruptedException ex) {\n                return;\n            }\n            try {\n                action.call();\n            } catch (ActionException e) {\n                throw new RuntimeException(\"ActionException calling PeriodicActionRunnable \" + action, e);\n            }\n        }\n    }\n\n    public void stop() {\n        if (thread != null) {\n            Thread theThread = thread;\n            thread = null;\n            if (theThread.isAlive()) {\n                theThread.interrupt();\n            }\n            try {\n                theThread.join();\n            } catch (InterruptedException e) {\n            }\n        }\n    }\n\n}\n"
    },
    {
        "detailed_description": "The public class RowFootWriteRegistry is designed to manage instances of RowFootWrite, which is likely a class that handles writing to the footer of a row in a spreadsheet or similar data structure. The class contains a static final field DEFAULT_ROW_FOOT_WRITE_CLASS, which holds the class object of DefaultRowFootWrite, likely a default implementation of the RowFootWrite interface.\n\nThe class also contains a private final field configuration of type Configuration, which is likely used to store configuration settings for the registry. This field is initialized in the constructor, which takes a Configuration object as an argument.\n\nThe class also contains a private final field rowFootWriteMap, which is a concurrent hash map that maps classes that extend RowFootWrite to instances of those classes. This map is used to store registered instances of RowFootWrite.\n\nThe class exposes a public method getConfiguration, which returns the configuration object. It also exposes a public method register, which takes an instance of RowFootWrite and adds it to the map, using the class of the instance as the key.\n\nFinally, the class exposes a public method getMappingRowWrite, which takes a class that extends RowFootWrite as an argument and returns the registered instance of that class from the map. If no instance is found, it throws an ExcelException with a message indicating that the requested RowFootWrite does not exist.\"",
        "sketchy_description": "The public class RowFootWriteRegistry is designed to manage the registration of RowFootWrite instances which are used for configuration purposes. The class contains a static class variable DEFAULT_ROW_FOOT_WRITE_CLASS which holds a reference to the DefaultRowFootWrite class. The constructor of the RowFootWriteRegistry class takes a Configuration object as a parameter and uses it to initialize the registry, also ensuring that the default RowFootWrite is registered. The getConfiguration method allows retrieval of the configuration object associated with the registry. The register method is used to add a new RowFootWrite instance to the registry. Lastly, the getMappingRowWrite method is responsible for finding a registered RowFootWrite instance by its class type; it throws an ExcelException if the requested instance is not found in the registry. These methods collectively facilitate the management and retrieval of RowFootWrite instances for various configuration needs.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/write/registry/RowFootWriteRegistry.java",
        "class_name": "RowFootWriteRegistry",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "RowFootWriteRegistryTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/write/registry/RowFootWriteRegistryTest.java"
        },
        "task_id": 120,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.write.registry;\n\nimport io.github.zouzhiy.excel.exceptions.ExcelException;\nimport io.github.zouzhiy.excel.metadata.Configuration;\nimport io.github.zouzhiy.excel.write.RowFootWrite;\nimport io.github.zouzhiy.excel.write.defaults.DefaultRowFootWrite;\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class RowFootWriteRegistry {\n\n    public final static Class<DefaultRowFootWrite> DEFAULT_ROW_FOOT_WRITE_CLASS = DefaultRowFootWrite.class;\n\n    private final Configuration configuration;\n\n    private final Map<Class<? extends RowFootWrite>, RowFootWrite> rowFootWriteMap = new ConcurrentHashMap<>(16);\n\n    public RowFootWriteRegistry(Configuration configuration) {\n        this.configuration = configuration;\n        register(new DefaultRowFootWrite());\n    }\n\n    /**\n     * \u5168\u5bb6\u914d\u7f6e\u4fe1\u606f\n     *\n     * @return Configuration\n     */\n    public Configuration getConfiguration() {\n        return configuration;\n    }\n\n    /**\n     * \u6ce8\u518c\n     *\n     * @param rowFootWrite \u5b9e\u4f8b\n     */\n    public void register(RowFootWrite rowFootWrite) {\n        rowFootWriteMap.put(rowFootWrite.getClass(), rowFootWrite);\n    }\n\n    /**\n     * \u6839\u636e class \u67e5\u627e\u5df2\u6ce8\u518c\u7684\u5b9e\u4f8b\u5bf9\u8c61\n     *\n     * @param rowFootWriteClazz class\n     * @return \u8fd4\u56de\u5df2\u6ce8\u518c\u7684\u5b9e\u4f8b\u5bf9\u8c61\n     */\n    public RowFootWrite getMappingRowWrite(Class<? extends RowFootWrite> rowFootWriteClazz) {\n        RowFootWrite rowFootWrite = rowFootWriteMap.get(rowFootWriteClazz);\n        if (rowFootWrite == null) {\n            throw new ExcelException(\"\u4e0d\u5b58\u5728\u7684\uff1aRowFootWrite\");\n        }\n        return rowFootWrite;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class LongBooleanHandler is a subclass of the AbstractLongCellHandler class. This class is designed to handle long boolean values in an Excel spreadsheet. It contains a private static final Long variable named TRUE_VALUE, which is set to 1L. This variable represents the boolean value of true in the context of this class. \n\nThe class overrides two methods from its superclass. The first method, setCellValue, takes four parameters: a RowContext object, an ExcelFieldConfig object, a Cell object, and a Long value. This method is responsible for setting the value of a cell in an Excel spreadsheet. It does this by comparing the provided Long value to TRUE_VALUE. If the comparison returns 0, meaning the two values are equal, the cell's value is set to true. \n\nThe second overridden method, getExcelType, takes no parameters and returns an ExcelType enumeration. Specifically, it returns ExcelType.BOOLEAN, indicating that this handler is used for boolean values in Excel spreadsheets.\"",
        "sketchy_description": "The public class LongBooleanHandler, which extends AbstractLongCellHandler, is designed to handle the conversion of Long values to Boolean values specifically within the context of Excel cells. This class is particularly useful when dealing with Excel spreadsheets that require a representation of Boolean values as Long integers, where a specific Long value (in this case, 1L) is designated to represent the Boolean value true.\n\nThe class contains a single class variable, TRUE_VALUE, which is a private final static Long set to 1L. This variable serves as a reference for the conversion process, indicating the Long value that should be interpreted as true.\n\nThe method setCellValue is a protected method that takes four parameters: RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, and Long value. This method is responsible for setting the value of an Excel cell. It checks if the provided Long value is equal to TRUE_VALUE, and if so, sets the cell's value to true. If the Long value is not equal to TRUE_VALUE, the cell's value is set to false. This method ensures that the Boolean representation in the Excel cell accurately reflects the Long value according to the predefined TRUE_VALUE.\n\nThe method getExcelType is a public method that returns the ExcelType.BOOLEAN, indicating that this handler is associated with Boolean values within Excel. This method is useful for identifying the type of data that the handler is meant to process and can be used to ensure that the handler is used in the correct context within an Excel spreadsheet processing workflow.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/longs/LongBooleanHandler.java",
        "class_name": "LongBooleanHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "LongBooleanHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/LongBooleanHandlerTest.java"
        },
        "task_id": 121,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.longs;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport org.apache.poi.ss.usermodel.Cell;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class LongBooleanHandler extends AbstractLongCellHandler {\n\n    private final static Long TRUE_VALUE = 1L;\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, Long value) {\n        cell.setCellValue(value.compareTo(TRUE_VALUE) == 0);\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.BOOLEAN;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class FileImageSource implements the BufferedImageSource interface with File as its type parameter. This class is designed to read image files and convert them into BufferedImage objects. \n\nThe class has three protected fields: a File object named 'source', a boolean 'readCompleted' to track if the file reading is completed, and a String 'originalFormatName' to store the original format of the image file. \n\nThe class has two constructors, one that accepts a File object and another that accepts a String representing the filename. Both constructors check if the input is null and throw a NullPointerException if it is. The constructors initialize the 'source' field with the provided file or a new File object created from the provided filename.\n\nThe class overrides the 'read' method from the BufferedImageSource interface. This method checks if the file has already been read or if it is unreadable, throwing exceptions in either case. It then reads the image file into a BufferedImage object using an ImageInputStream and an ImageReader. The method also sets the 'originalFormatName' field with the format of the image file and marks the 'readCompleted' field as true before returning the BufferedImage object.\n\nThe class also overrides the 'getOriginalFormatName', 'getSource', and 'isReadCompleted' methods from the BufferedImageSource interface. These methods return the original format name of the image file, the source file, and the read completion status, respectively.\n\nFinally, the class has a protected 'completeRead' method that sets the 'readCompleted' field to true, indicating that the file reading has been completed.\"",
        "sketchy_description": "The public class FileImageSource is an implementation that allows for reading images from a file source, conforming to the BufferedImageSource interface with a generic type of File. The class is designed to handle image input from a file system and provides several methods to facilitate this process.\n\nThe class is initialized through one of two constructors, either by passing a File object directly or by providing a file name in the form of a String. These constructors set up the FileImageSource object to point to the specific source from which the image will be read.\n\nThe read method is a public interface that attempts to read the image from the file and returns a BufferedImage object. This method can throw an IOException if the file cannot be read for any reason, such as if the file does not exist or there are permission issues.\n\nAdditionally, there is a protected read method that takes an ImageInputStream as an argument. This method is likely used internally by the class to perform the actual reading of the image data from the stream, and it also throws an IOException if the image cannot be read.\n\nThe getOriginalFormatName method provides the name of the original format of the image that was read, which can be useful for applications that need to know the image type without relying on the file extension.\n\nThe getSource method returns the File object that represents the source of the image, allowing users of the class to retrieve the file that was used to initialize the FileImageSource object.\n\nThe isReadCompleted method is a simple check to determine if the image read operation has been completed successfully.\n\nLastly, the protected completeRead method is used internally to mark the read operation as completed, which likely updates the readCompleted boolean flag to true.\n\nOverall, the FileImageSource class provides a robust set of methods for reading images from files, handling different initialization scenarios, and allowing for the retrieval of both the image data and metadata related to the read operation.",
        "file": "imglib/core/src/main/java/cn/core/in/FileImageSource.java",
        "class_name": "FileImageSource",
        "repo_metadata": {
            "repo_name": "imglib"
        },
        "evaluation_metadata": {
            "test_class_name": "FileImageSourceTest",
            "test_file": "imglib/core/src/test/java/cn/core/in/FileImageSourceTest.java"
        },
        "task_id": 122,
        "ground_truth_class_body": "package cn.core.in;\n\nimport cn.core.ex.HandlingException;\nimport cn.core.ex.UnsupportedFormatException;\nimport cn.core.utils.ObjectUtils;\nimport cn.core.utils.StringUtils;\n\nimport javax.imageio.IIOException;\nimport javax.imageio.ImageIO;\nimport javax.imageio.ImageReadParam;\nimport javax.imageio.ImageReader;\nimport javax.imageio.stream.ImageInputStream;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Iterator;\n\n/**\n * Buffered image data source whose from image File.\n *\n * @author tracy\n * @since 0.2.1\n */\npublic class FileImageSource implements BufferedImageSource<File> {\n\n    protected final File source;\n    protected boolean readCompleted = false;\n    protected String originalFormatName;\n\n    public FileImageSource(File file) {\n        if (ObjectUtils.isNull(file)) {\n            throw new NullPointerException(\"File is null.\");\n        }\n        this.source = file;\n    }\n\n    public FileImageSource(String filename) {\n        if (StringUtils.isEmpty(filename)) {\n            throw new NullPointerException(\"File name is null.\");\n        }\n        this.source = new File(filename);\n    }\n\n    @Override\n    public BufferedImage read() throws IOException {\n        if (readCompleted) {\n            throw new HandlingException(\"File reading has already completed.\");\n        }\n        // check the file is readable\n        if (!source.canRead()) {\n            throw new IIOException(\"Cannot read the source file.\");\n        }\n        // get image input stream\n        ImageInputStream stream = ImageIO.createImageInputStream(source);\n\n        // read from file\n        BufferedImage bi = read(stream);\n\n        // mark the status to completed\n        completeRead();\n        return bi;\n    }\n\n    protected BufferedImage read(ImageInputStream stream) throws IOException {\n        Iterator<ImageReader> iter = ImageIO.getImageReaders(stream);\n        if (!iter.hasNext()) {\n            // can not parse input stream\n            stream.close();\n            throw new UnsupportedFormatException(\"No suitable ImageReader found for source file.\");\n        }\n\n        ImageReader reader = iter.next();\n        ImageReadParam param = reader.getDefaultReadParam();\n        reader.setInput(stream, true, true);\n\n        // set the format\n        originalFormatName = reader.getFormatName();\n\n        BufferedImage bi;\n        try {\n            bi = reader.read(0, param);\n        } finally {\n            reader.dispose();\n            stream.close();\n        }\n        return bi;\n    }\n\n    @Override\n    public String getOriginalFormatName() {\n        return originalFormatName;\n    }\n\n    @Override\n    public File getSource() {\n        return source;\n    }\n\n    @Override\n    public boolean isReadCompleted() {\n        return readCompleted;\n    }\n\n    protected void completeRead() {\n        this.readCompleted = true;\n    }\n\n}\n"
    },
    {
        "detailed_description": "The public class BulkImportJobSerDe is designed to handle serialization and deserialization of BulkImportJob objects into JSON format. It uses the Gson library to perform these operations. The class has two private final Gson instances, 'gson' and 'prettyGson'. The 'gson' instance is a standard Gson object, while 'prettyGson' is a Gson object with pretty printing enabled, which means it formats the JSON output in a way that's easier for humans to read.\n\nThe constructor for this class initializes the 'gson' and 'prettyGson' instances. The 'gson' instance is created using the default Gson constructor, while the 'prettyGson' instance is created using a GsonBuilder to enable pretty printing.\n\nThe class provides three public methods for interacting with BulkImportJob objects. The 'toJson' method takes a BulkImportJob object and returns a string representation of the object in JSON format. The 'toPrettyJson' method does the same thing, but formats the JSON string in a way that's easier to read. The 'fromJson' method takes a string in JSON format and returns a BulkImportJob object. This method is useful for converting JSON data received from an external source into a BulkImportJob object that can be used in the application.\"",
        "sketchy_description": "The public class BulkImportJobSerDe is tasked with the serialization and deserialization of BulkImportJob objects, utilizing the Gson library to convert between objects and their JSON representation. The class is equipped with two distinct Gson instances: one for standard JSON conversion and another for generating pretty-printed JSON strings, which are more human-readable.\n\nThe constructor of the BulkImportJobSerDe class is responsible for initializing these Gson instances, setting up the environment for subsequent serialization and deserialization processes.\n\nThe toJson method takes a BulkImportJob object as an argument and converts it into a compact JSON string. This method is particularly useful when there is a need to store or transmit the object in a standardized data interchange format.\n\nIn contrast, the toPrettyJson method also takes a BulkImportJob object but returns a well-formatted, pretty-printed JSON string. This is especially helpful for debugging or displaying the JSON in a more readable format for humans.\n\nLastly, the fromJson method is designed to take a JSON string and deserialize it back into a BulkImportJob object. This allows for the reconstruction of the object from its JSON representation, enabling the persistence and retrieval of object states in a format that is both language and platform-independent.",
        "file": "sleeper/java/bulk-import/bulk-import-common/src/main/java/sleeper/bulkimport/job/BulkImportJobSerDe.java",
        "class_name": "BulkImportJobSerDe",
        "repo_metadata": {
            "repo_name": "sleeper"
        },
        "evaluation_metadata": {
            "test_class_name": "BulkImportJobSerDeTest",
            "test_file": "sleeper/java/bulk-import/bulk-import-common/src/test/java/sleeper/bulkimport/job/BulkImportJobSerDeTest.java"
        },
        "task_id": 123,
        "ground_truth_class_body": "/*\n * Copyright 2022-2023 Crown Copyright\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage sleeper.bulkimport.job;\n\nimport com.google.gson.Gson;\nimport com.google.gson.GsonBuilder;\n\npublic class BulkImportJobSerDe {\n    private final Gson gson;\n    private final Gson prettyGson;\n\n    public BulkImportJobSerDe() {\n        this.gson = new Gson();\n        prettyGson = new GsonBuilder().setPrettyPrinting().create();\n    }\n\n    public String toJson(BulkImportJob job) {\n        return gson.toJson(job);\n    }\n\n    public String toPrettyJson(BulkImportJob job) {\n        return prettyGson.toJson(job);\n    }\n\n    public BulkImportJob fromJson(String jsonStr) {\n        return gson.fromJson(jsonStr, BulkImportJob.class);\n    }\n}\n"
    },
    {
        "detailed_description": "The public class RowTitleReadRegistry is designed to manage the reading of row titles in a spreadsheet or similar data structure. It contains a static final field DEFAULT_ROW_TITLE_READ_CLASS, which is a reference to the DefaultRowTitleRead class. This class is presumably the default implementation of the RowTitleRead interface, which is used to read row titles.\n\nThe class also contains a private final field configuration of type Configuration, which is likely used to store configuration settings for the registry. This field is initialized in the constructor, which takes a Configuration object as an argument.\n\nThe class also contains a private final field rowTitleReadMap, which is a concurrent hash map that maps classes implementing the RowTitleRead interface to instances of those classes. This map is used to store registered RowTitleRead instances.\n\nThe class provides a public method getConfiguration, which returns the configuration object. It also provides a public method register, which takes a RowTitleRead object as an argument and adds it to the rowTitleReadMap, using the object's class as the key.\n\nFinally, the class provides a public method getMappingRowRead, which takes a Class object representing a class that implements the RowTitleRead interface as an argument. This method retrieves the corresponding RowTitleRead instance from the rowTitleReadMap. If no such instance exists, it throws an ExcelException with a message indicating that the requested RowTitleRead does not exist.\"",
        "sketchy_description": "The public class RowTitleReadRegistry is designed to manage a registry of RowTitleRead instances, which are presumably used for reading row titles in some context, such as processing Excel files or similar tabular data. The class contains a static class variable DEFAULT_ROW_TITLE_READ_CLASS, which holds a reference to the DefaultRowTitleRead class, indicating that this is the default implementation to be used if no other is specified.\n\nThe constructor of the RowTitleReadRegistry class takes a Configuration object as an argument. This configuration is likely used to set up the registry with specific settings or parameters. Upon initialization, the constructor also registers the default RowTitleRead instance, ensuring that there is at least one RowTitleRead available for use.\n\nThe getConfiguration method is a public method that returns the Configuration object associated with the registry. This allows external entities to query the registry for its configuration settings.\n\nThe register method is another public method that takes a RowTitleRead object as a parameter. This method is used to add a new RowTitleRead instance to the registry, expanding the set of available RowTitleRead implementations that can be used.\n\nFinally, the getMappingRowRead method is a public method that takes a Class object as a parameter, which extends the RowTitleRead class. This method is responsible for retrieving the corresponding RowTitleRead instance for the specified class from the registry. If the requested instance does not exist in the registry, the method is documented to throw an ExcelException, indicating an error condition that must be handled by the caller. This method is essential for obtaining the correct RowTitleRead instance for a given class type, enabling dynamic retrieval of row title readers based on the class provided.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/read/registry/RowTitleReadRegistry.java",
        "class_name": "RowTitleReadRegistry",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "RowTitleReadRegistryTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/read/registry/RowTitleReadRegistryTest.java"
        },
        "task_id": 124,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.read.registry;\n\nimport io.github.zouzhiy.excel.exceptions.ExcelException;\nimport io.github.zouzhiy.excel.metadata.Configuration;\nimport io.github.zouzhiy.excel.read.RowTitleRead;\nimport io.github.zouzhiy.excel.read.defaults.DefaultRowTitleRead;\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class RowTitleReadRegistry {\n\n    public final static Class<DefaultRowTitleRead> DEFAULT_ROW_TITLE_READ_CLASS = DefaultRowTitleRead.class;\n\n    private final Configuration configuration;\n\n    private final Map<Class<? extends RowTitleRead>, RowTitleRead> rowTitleReadMap = new ConcurrentHashMap<>(16);\n\n    public RowTitleReadRegistry(Configuration configuration) {\n        this.configuration = configuration;\n        register(new DefaultRowTitleRead());\n    }\n\n    public Configuration getConfiguration() {\n        return configuration;\n    }\n\n    public void register(RowTitleRead rowTitleRead) {\n        rowTitleReadMap.put(rowTitleRead.getClass(), rowTitleRead);\n    }\n\n    public RowTitleRead getMappingRowRead(Class<? extends RowTitleRead> rowTitleReadClazz) {\n        RowTitleRead rowTitleRead = rowTitleReadMap.get(rowTitleReadClazz);\n        if (rowTitleRead == null) {\n            throw new ExcelException(\"\u4e0d\u5b58\u5728\u7684\uff1aRowTitleRead\");\n        }\n        return rowTitleRead;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class LongNumberHandler is a subclass of the AbstractLongCellHandler class. This class is designed to handle long numbers in an Excel cell. It overrides two methods from its superclass. The first method, setCellValue, is responsible for setting the value of a cell in an Excel row. It takes four parameters: a RowContext object that represents the context of the row in which the cell is located, an ExcelFieldConfig object that contains configuration information for the Excel field, a Cell object that represents the cell itself, and a Long value that represents the value to be set in the cell. The method then calls the setCellValue method on the Cell object, passing the Long value as an argument. The second method, getExcelType, returns the type of the Excel cell. In this case, it returns ExcelType.NUMERIC, indicating that the cell is expected to contain a numeric value.\"",
        "sketchy_description": "The public class LongNumberHandler, which extends the AbstractLongCellHandler, is specifically designed to manage the assignment of long number values to cells within an Excel spreadsheet. This functionality is crucial when dealing with large numeric datasets that need to be accurately represented in Excel documents.\n\nThe class provides a protected method setCellValue, which takes a RowContext, an ExcelFieldConfig, a Cell, and a Long value as parameters. This method is tasked with setting the value of a specific cell in an Excel sheet to the long value that is provided. This operation is essential for ensuring that numeric data is correctly inputted into the spreadsheet, maintaining data integrity and accuracy.\n\nAdditionally, the class offers a public method getExcelType, which returns an ExcelType enumeration value. This value corresponds to the numeric type, indicating the data format that Excel should use to represent the long values. This method is particularly useful for ensuring that the data is displayed in a format that is consistent with its numeric type, which can be critical for users who are performing data analysis or presenting data in a professional context.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/longs/LongNumberHandler.java",
        "class_name": "LongNumberHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "LongNumberHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/LongNumberHandlerTest.java"
        },
        "task_id": 125,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.longs;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport org.apache.poi.ss.usermodel.Cell;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class LongNumberHandler extends AbstractLongCellHandler {\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, Long value) {\n        cell.setCellValue(value);\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.NUMERIC;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class NoneCellHandler is an implementation of the CellHandler interface, which is designed to handle operations related to cells in an Excel spreadsheet. This particular implementation, however, does not support any of the methods defined in the interface, and instead throws an ExcelException with the message \"\u4e0d\u652f\u6301\u7684\u65b9\u6cd5\" (method not supported) for each one.\n\nThe getJavaType method, which is supposed to return the Java type of the cell's content, is not supported in this implementation. Similarly, the getExcelType method, which is supposed to return the Excel type of the cell's content, is also not supported.\n\nThe read method, which is supposed to read the content of a cell in a given SheetContext, ExcelFieldConfig, and CellResultSet, is not supported either. The SheetContext represents the current state of the sheet being processed, the ExcelFieldConfig represents the configuration of the field being processed, and the CellResultSet represents the result set of the cell being processed.\n\nFinally, the write method, which is supposed to write a value to a cell in a given RowContext, columnIndex, ExcelFieldConfig, and value, is not supported. The RowContext represents the current state of the row being processed, the columnIndex represents the index of the column where the value should be written, the ExcelFieldConfig represents the configuration of the field being processed, and the value is the value to be written to the cell.\"",
        "sketchy_description": "The public class NoneCellHandler implements the CellHandler interface with a generic Object type, and it is specifically designed to handle cell operations for cells that do not support certain methods. This class is typically used in scenarios where certain operations on cells are not applicable or not implemented, and it provides a consistent way to handle such cases.\n\nThe getJavaType method is intended to return the Java type associated with the cell, but since the NoneCellHandler class represents unsupported operations, this method will throw an exception to indicate that the operation is not supported.\n\nSimilarly, the getExcelType method is supposed to return the Excel type of the cell, but in the context of the NoneCellHandler, it also throws an exception to signal that this method is not supported for the cells being handled by this class.\n\nThe read method would normally read data from a cell based on the provided SheetContext, ExcelFieldConfig, and CellResultSet. However, in the case of the NoneCellHandler, this method is not supported and will throw an exception when called.\n\nLastly, the write method is designed to write a value to a cell at a specified column index within a row, using the provided RowContext, ExcelFieldConfig, and the value to be written. As with the other methods in this class, the write method is not supported and will throw an exception if an attempt is made to use it.\n\nIn summary, the NoneCellHandler class serves as a placeholder for cell operations that are not supported, and all of its methods throw exceptions to clearly communicate that the associated operations cannot be performed.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/NoneCellHandler.java",
        "class_name": "NoneCellHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "NoneCellHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/NoneCellHandlerTest.java"
        },
        "task_id": 126,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.context.SheetContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.exceptions.ExcelException;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport io.github.zouzhiy.excel.metadata.result.CellResultSet;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class NoneCellHandler implements CellHandler<Object> {\n\n    @Override\n    public Class<Object> getJavaType() {\n        throw new ExcelException(\"\u4e0d\u652f\u6301\u7684\u65b9\u6cd5\");\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        throw new ExcelException(\"\u4e0d\u652f\u6301\u7684\u65b9\u6cd5\");\n    }\n\n    @Override\n    public Object read(SheetContext sheetContext, ExcelFieldConfig excelFieldConfig, CellResultSet cellResultSet) {\n        throw new ExcelException(\"\u4e0d\u652f\u6301\u7684\u65b9\u6cd5\");\n    }\n\n\n    @Override\n    public void write(RowContext rowContext, Integer columnIndex, ExcelFieldConfig excelFieldConfig, Object value) {\n        throw new ExcelException(\"\u4e0d\u652f\u6301\u7684\u65b9\u6cd5\");\n\n    }\n}\n"
    },
    {
        "detailed_description": "The public class ImageUrlCellHandler is a subclass of the AbstractImageCellHandler class, with a generic type of String. This class is designed to handle image URLs in an Excel spreadsheet. It overrides three methods from its superclass.\n\nThe first overridden method, getCellValue, takes three parameters: a SheetContext object, an ExcelFieldConfig object, and a CellResult object. This method is designed to return the value of a cell in the spreadsheet, but in this implementation, it simply returns null.\n\nThe second overridden method, toImageUrlResource, takes three parameters: a RowContext object, an ExcelFieldConfig object, and a String value. This method is designed to convert the String value, which is expected to be a URL, into a byte array. It does this by creating a new URL object from the String value, and then converting this to a byte array using the IOUtils.toByteArray method. If an IOException is thrown during this process, it catches the exception and throws a new ExcelException with a message indicating that the image could not be read.\n\nThe third overridden method, getExcelType, does not take any parameters and returns an ExcelType enumeration. In this implementation, it simply returns ExcelType.NONE, indicating that this handler does not correspond to any specific type of Excel cell.\"",
        "sketchy_description": "The public class ImageUrlCellHandler, which extends the abstract class AbstractImageCellHandler with a generic type of String, is specifically designed to handle the conversion of image URLs into byte arrays that can be used in Excel cells. This functionality is particularly useful when dealing with spreadsheets that require the inclusion of images via URLs.\n\nThe class provides a protected method named getCellValue, which takes a SheetContext, an ExcelFieldConfig, and a CellResult as parameters. This method is designed to retrieve the cell value based on the given context and configuration and is intended to be overridden by subclasses to implement specific behavior for cell value retrieval.\n\nAnother protected method, toImageUrlResource, accepts a RowContext, an ExcelFieldConfig, and a String value representing the image URL. This method is responsible for converting the image URL into a byte array resource, which can then be used within an Excel cell. If the method encounters any issues while reading the image, such as an invalid URL or network problems, it throws an ExcelException to signal the failure.\n\nLastly, the class includes a public final method named getExcelType, which returns the ExcelType associated with this handler. In this case, the method returns ExcelType.NONE, indicating that this handler does not deal with a specific Excel type but rather provides a general functionality that can be applied to Excel cells without a specific type constraint.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/image/ImageUrlCellHandler.java",
        "class_name": "ImageUrlCellHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "ImageUrlCellHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/old/handler/image/ImageUrlCellHandlerTest.java"
        },
        "task_id": 127,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.image;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.context.SheetContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.exceptions.ExcelException;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport io.github.zouzhiy.excel.metadata.result.CellResult;\nimport org.apache.commons.io.IOUtils;\n\nimport java.io.IOException;\nimport java.net.URL;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class ImageUrlCellHandler extends AbstractImageCellHandler<String> {\n\n    @Override\n    protected String getCellValue(SheetContext sheetContext, ExcelFieldConfig excelFieldConfig, CellResult firstCellResult) {\n        return null;\n    }\n\n    @Override\n    protected byte[] toImageUrlResource(RowContext rowContext, ExcelFieldConfig excelFieldConfig, String value) {\n        try {\n            return IOUtils.toByteArray(new URL(value));\n        } catch (IOException e) {\n            throw new ExcelException(e, \"\u8bfb\u53d6\u56fe\u7247\u5931\u8d25:%s\", value);\n        }\n    }\n\n    @Override\n    public final ExcelType getExcelType() {\n        return ExcelType.NONE;\n    }\n}\n"
    },
    {
        "detailed_description": "The public class RowHeadReadRegistry is designed to manage and provide access to different types of RowHeadRead objects. It contains a static final field DEFAULT_ROW_HEAD_READ_CLASS which holds the class type of DefaultRowHeadRead. It also contains a private final field configuration of type Configuration, which is used to store the configuration settings for the registry. \n\nThe class also maintains a private map, rowHeadReadMap, which is a concurrent hash map that maps Class objects representing subclasses of RowHeadRead to instances of those subclasses. This map is used to store and retrieve different types of RowHeadRead objects.\n\nThe constructor of this class takes a Configuration object as an argument and initializes the configuration field with it. It also registers a new instance of DefaultRowHeadRead in the rowHeadReadMap.\n\nThe class provides a public method getConfiguration that returns the Configuration object stored in the configuration field. \n\nThe register method is a public method that takes a RowHeadRead object as an argument and adds it to the rowHeadReadMap, using the class of the object as the key.\n\nThe getMappingRowRead method is a public method that takes a Class object representing a subclass of RowHeadRead as an argument. It retrieves the corresponding RowHeadRead object from the rowHeadReadMap. If no such object exists, it throws an ExcelException with a message indicating that the requested RowHeadRead does not exist.\"",
        "sketchy_description": "The public class RowHeadReadRegistry is designed to manage a registry of RowHeadRead instances, which are presumably used for reading row headers in some context, such as processing Excel files or similar tabular data structures. The class is initialized with a Configuration object, which likely contains settings and preferences for how the RowHeadRead instances should operate. Additionally, the class maintains a concurrent hash map to store the RowHeadRead instances, allowing for thread-safe access and modification.\n\nThe constructor of the RowHeadReadRegistry takes a Configuration object as a parameter and uses it to set up the registry. It also registers a default RowHeadRead instance, which is specified by the DEFAULT_ROW_HEAD_READ_CLASS class variable, ensuring that there is a baseline implementation available for use.\n\nThe getConfiguration method allows users to retrieve the Configuration object associated with the registry, which can be useful for inspecting or modifying the configuration settings.\n\nThe register method is used to add a new RowHeadRead instance to the registry. This allows for the expansion of the registry with custom implementations of RowHeadRead that may be tailored to specific use cases or data formats.\n\nFinally, the getMappingRowRead method is designed to retrieve a specific RowHeadRead instance based on its class. This method is essential for obtaining the correct reader for a given type of row header. If the requested RowHeadRead instance is not found in the registry, the method is documented to throw an ExcelException, indicating that the operation cannot be completed due to the absence of the required instance.\n\nOverall, the RowHeadReadRegistry class provides a structured way to manage and access different RowHeadRead instances, ensuring that the correct reader can be easily retrieved and used based on the class type, while also allowing for customization and extension through registration of new instances.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/read/registry/RowHeadReadRegistry.java",
        "class_name": "RowHeadReadRegistry",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "RowHeadReadRegistryTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/read/registry/RowHeadReadRegistryTest.java"
        },
        "task_id": 128,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.read.registry;\n\nimport io.github.zouzhiy.excel.exceptions.ExcelException;\nimport io.github.zouzhiy.excel.metadata.Configuration;\nimport io.github.zouzhiy.excel.read.RowHeadRead;\nimport io.github.zouzhiy.excel.read.defaults.DefaultRowHeadRead;\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class RowHeadReadRegistry {\n\n    public final static Class<DefaultRowHeadRead> DEFAULT_ROW_HEAD_READ_CLASS = DefaultRowHeadRead.class;\n\n    private final Configuration configuration;\n\n    private final Map<Class<? extends RowHeadRead>, RowHeadRead> rowHeadReadMap = new ConcurrentHashMap<>(16);\n\n    public RowHeadReadRegistry(Configuration configuration) {\n        this.configuration = configuration;\n        register(new DefaultRowHeadRead());\n    }\n\n    public Configuration getConfiguration() {\n        return configuration;\n    }\n\n    public void register(RowHeadRead rowHeadRead) {\n        rowHeadReadMap.put(rowHeadRead.getClass(), rowHeadRead);\n    }\n\n    public RowHeadRead getMappingRowRead(Class<? extends RowHeadRead> rowHeadReadClazz) {\n        RowHeadRead rowHeadRead = rowHeadReadMap.get(rowHeadReadClazz);\n        if (rowHeadRead == null) {\n            throw new ExcelException(\"\u4e0d\u5b58\u5728\u7684\uff1aRowHeadRead\");\n        }\n        return rowHeadRead;\n    }\n\n}\n"
    },
    {
        "detailed_description": "The public class LocalDateTimeDateHandler is a subclass of the AbstractLocalDateTimeCellHandler class. This class is designed to handle date and time data in Excel cells. It overrides three methods from its superclass. \n\nThe first overridden method, setCellValue, is responsible for setting the value of a cell in an Excel row. It takes four parameters: a RowContext object that represents the current row, an ExcelFieldConfig object that contains configuration information for the Excel field, a Cell object that represents the cell to be modified, and a LocalDateTime object that represents the value to be set in the cell. The method uses the setCellValue method of the Cell object to set the cell's value to the provided LocalDateTime value.\n\nThe second overridden method, getExcelType, returns the type of Excel data that this handler is designed to work with. In this case, it returns ExcelType.DATE, indicating that this handler works with date data.\n\nThe third overridden method, getDefaultExcelFormat, returns the default format for date data in Excel. In this case, it returns a string representing the format \"yyyy-MM-dd HH:mm:ss\", which corresponds to a date and time format.\"",
        "sketchy_description": "The public class LocalDateTimeDateHandler, which extends the AbstractLocalDateTimeCellHandler, is specifically designed to manage the process of setting cell values in Excel spreadsheets with LocalDateTime objects. LocalDateTime objects represent date-time values without a time-zone in the ISO-8601 calendar system, which is the standard calendar system used by most of the world.\n\nThe class provides a protected method setCellValue, which takes a RowContext, an ExcelFieldConfig, a Cell, and a LocalDateTime value as parameters. This method is responsible for setting the value of a cell in an Excel spreadsheet to the provided LocalDateTime value, ensuring that date-time data is accurately represented within the spreadsheet.\n\nAdditionally, the class includes a public method getExcelType, which returns an ExcelType enumeration value. This value corresponds to a date, indicating the type of data that the handler is dealing with, which in this case is date-related data.\n\nLastly, the class offers a public method getDefaultExcelFormat, which returns a String representing the default Excel format for LocalDateTime values. The default format is specified as \"yyyy-MM-dd HH:mm:ss\", which is a common format for representing date and time values in a year-month-day hour-minute-second pattern. This format is useful for users to understand and interpret the date-time values within the spreadsheet consistently.",
        "file": "zouzhiy-excel/src/main/java/io/github/zouzhiy/excel/handler/localdatetime/LocalDateTimeDateHandler.java",
        "class_name": "LocalDateTimeDateHandler",
        "repo_metadata": {
            "repo_name": "zouzhiy-excel"
        },
        "evaluation_metadata": {
            "test_class_name": "LocalDateTimeDateHandlerTest",
            "test_file": "zouzhiy-excel/src/test/java/io/github/zouzhiy/excel/handler/LocalDateTimeDateHandlerTest.java"
        },
        "task_id": 129,
        "ground_truth_class_body": "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.zouzhiy.excel.handler.localdatetime;\n\nimport io.github.zouzhiy.excel.context.RowContext;\nimport io.github.zouzhiy.excel.enums.ExcelType;\nimport io.github.zouzhiy.excel.metadata.config.ExcelFieldConfig;\nimport org.apache.poi.ss.usermodel.Cell;\n\nimport java.time.LocalDateTime;\n\n/**\n * @author zouzhiy\n * @since 2022/7/2\n */\npublic class LocalDateTimeDateHandler extends AbstractLocalDateTimeCellHandler {\n\n    @Override\n    protected void setCellValue(RowContext rowContext, ExcelFieldConfig excelFieldConfig, Cell cell, LocalDateTime value) {\n        cell.setCellValue(value);\n    }\n\n    @Override\n    public ExcelType getExcelType() {\n        return ExcelType.DATE;\n    }\n\n    @Override\n    public String getDefaultExcelFormat() {\n        return \"yyyy-MM-dd HH:mm:ss\";\n    }\n}\n"
    }
]